unit SchedaPreventiviOrdini;

interface

uses
  Windows, Messages, SysUtils, Classes, Graphics, Controls, Forms, Dialogs,
  cxStyles, cxCustomData, cxGraphics, cxDataStorage,
  cxEdit, cxTextEdit, cxCurrencyEdit, cxCheckBox, IB_Components,
  IBODataset, DB, Menus, bmpPanel, cxContainer, StdCtrls, cxGridLevel,
  cxGridCardView, cxGridCustomTableView, cxGridTableView, cxClasses,
  cxControls, cxGridCustomView, cxGrid, DBCtrls, ExtCtrls, Mask,
  Buttons, ComCtrls, quickrpt, IniFiles,
  MAURI_SB, Variants, cxGridDBTableView, cxGridDBCardView, cxMaskEdit,
  cxDropDownEdit,
  cxDBEdit, cxTrackBar, cxLabel,
  cxCheckComboBox, cxCalendar, cxTimeEdit,
  cxSpinEdit, DataModule1, cxMemo, cxRadioGroup, StrUtils, cxImageComboBox,
  Bancolini_B31WIN32, cxCalc, cxButtonEdit, FormLevanteListAnag,
  cxDBLookupComboBox, cxRichEdit, cxPC,
  cxSplitter, FormAllegati, FormFileAllegatoModificato, cxFilter, cxData,
  cxPCdxBarPopupMenu,
  cxNavigator, cxGridCustomLayoutView, cxLookupEdit, cxDBLookupEdit, cxDBData,
  Vcl.ActnList, cxLookAndFeels, cxLookAndFeelPainters, Vcl.ExtDlgs, cxButtons,
  UnitTotaleACorpo.Interfaces, cxPropertiesStore, cxGridBandedTableView,
  cxBlobEdit, Datasnap.DBClient, Vcl.ImgList, cxGroupBox, dxBarBuiltInMenu,
  dxDateRanges, dxScrollbarAnnotations, System.Actions, ZLIBArchive;

const
  // Costanti che vengono usate per accedere ai sottorighi, sia normali che di ore/manodopera,
  // indicano l'indice della "relazione", in pratica il livello di sottorighi a cui accedere
  // a partire dal MasterDataController usando la sua funzione GetDetailDataController
  RELATION_IDX_SOTTORIGHI_NORMALI = 0;
  RELATION_IDX_SOTTORIGHI_ORE = 1;
  // COstanti che indica il TabiIndex dei Tabs presenti nella parte
  // supuriore del documento e che compare negli interventi o negli
  // articoli composti
  DOCTABIDX_APPUNTAMENTO = 0;
  DOCTABIDX_RICAMBIMANODOPERA = 1;
  DOCTABIDX_OPERAZIONIPIANIFICATE = 2;
  DOCTABIDX_INTERVENTIPRECEDENTI = 3;
  DOCTABIDX_ALLEGATI = 4;
  DOCTABIDX_ANAGRAFICAARTICOLO = 5;
  DOCTABIDX_DISTINTABASE = 6;
  DOCTABIDX_MAPPA = 7;
  // Costanti che indicano il tipo di salvataggio selezionato per il sistema
  // delle preferenze di stampa
  STMPREF_SAVEMODE_NONE = 0;
  STMPREF_SAVEMODE_MODIFIED = 1;
  STMPREF_SAVEMODE_ALL = 2;
  // Costanti che indicano la dimensione del pannello dell'intestatario del documento
  INTESTATARIO_OPEN = 106;
  INTESTATARIO_CLOSE = 37;
  // Constanti contentnei l'ID della colonna della griglia del corpo documento
  // NB: RICORDARSI QUANDO SI MODIFICANO O AGGIUNGONO I VALORI DI QUESTE COSTANTI DI FARLO ANCHE NELLA
  // FUNZIONE CHE RITORNA IL VALORE DEI CAMPI DEL CORPO DOC.
  IDX_MovMag = 0;
  IDX_CodiceMagazzino = 1;
  IDX_CodiceArticolo = 2;
  IDX_Descrizione = 3;
  IDX_PrezzoUnitario = 4;
  IDX_PrezzoUnitarioIVACompresa = 5;
  IDX_UnitaDiMisura = 6;
  IDX_QTA = 7;
  IDX_ScontoRigo = 8;
  IDX_ScontoRigo2 = 9;
  IDX_ScontoRigo3 = 10;
  IDX_ImportoRigo = 11;
  IDX_ImportoRigoIVACompresa = 12;
  IDX_CodiceIVA = 13;
  IDX_DescrizioneIVA = 14;
  IDX_NoteRigo = 15;
  IDX_PrezzoAcquistoArticolo = 16;
  IDX_Margine = 17;
  IDX_ImportoMargine = 18;
  IDX_AliquotaIVA = 19;
  // MOdalità di richiamo della form
  MODE_FATTURAZIONE_DIFFERITA = 0;
  MODE_OPEN = 1;
  MODE_NEW = 2;
  MODE_KIOSK = 3;
  MODE_TELETRASPORTO = 4;

type
  // Struttura che contiene il riferimento ad un documento di cui poi si deve variare
  // ad esempio lo STATO (dopo la conferma, prima lo faceva prima) oppure il
  // RifDoc_COrrispettivoNonPagato quando il documento di provenienza
  // viene fatturato o similare.
  TImportedDocument = record
    TipoDoc: String;
    NumDoc: Integer;
    RegDoc: String;
    DataDoc: TDateTime;
    RifDoc_CorrispNoPag: String;
  end;

  // Array che contiene elementi della struttura di cui sopra
  TImportedDocumentsArray = array of TImportedDocument;

  // Struttura che contiene i dati per la conversione delle misure usate per fare in modo
  // che il piede del documento, quando il documento è stampato nella modalità con il piede
  // solo sull'ultima pagina, sia allineato al fondo della pagina.
  TConvDataPerPiedeUltimaPagina = record
    StartAvailableSpace: Integer;
    EndAvailableSpace: Integer;
    StartCurrentY: Integer;
    EndCurrentY: Integer;
    FactorAvailableSpace: Double;
    FactorCurrentY: Double;
    ScreenBandHeight: Integer;
    FinalBandsHeightConvertedToAvailableSpace: Integer;
    FinalBandsOffset: Integer;
    FinalBandsPageNumber: Integer;
  end;

  // Dichiara la struttura che contiene i dati dell'aliquota IVA di default del documento, in modo che non debba
  // rieseguire una query ogni volta che servono tali dati.
  TDocIVADefault = record
    Codice: Integer;
    Descrizione: String;
    AliquotaIVA: Double;
    IsDefault: Boolean;
    // Flag che indica se l'aliquota IVA di default è quella di default oppure quella impostata
    // nell'anagrafica soggetti.
  end;

  // Indica lo stato di visualizzazione del corpo documento
  TBodyScreenState = (bssNormal, bssHorzStretched, bssFullStretched);
  // Indica il livello di dettaglio per quanto riguarda le colonne che sono utili all'analisi
  // dei costi del documento
  TBodyView = (vacNormale, vacExt1, vacExt2, vacExt3, vacExt4, vacExt5, vacFull, vacDebug);

  // Classe che verifica la necessità o meno di abilitare il raggruppamento per SEZIONE
  // dei righi. In pratica se rileva che nei righi  presente più di una sezione
  // raggruppa per sezione, altrimenti no.
  TSectionGrouped = class
  const
    STARTVALUE = 'StartValue';
  private
    class var FGrouped: Boolean;
    class var FPrevious: String;
  public
    class procedure StartCheck;
    class procedure CheckRow(const DC: TcxCustomDataController; const Idx: Integer);
    class procedure EndCheck;
  end;

  TPreventiviOrdiniForm = class(TForm)
    MenuRxDBGridCorpoDoc: TPopupMenu;
    MICopiaRighiSelezionati: TMenuItem;
    MIIncollaRighiSelezionati: TMenuItem;
    MIAggiornaPrezzi: TMenuItem;
    MICreaScadenze: TMenuItem;
    N3: TMenuItem;
    Salvaimpostazionidocumento1: TMenuItem;
    FloppyCONAD: TMenuItem;
    MITotaleACorpo: TMenuItem;
    MenuStampe: TPopupMenu;
    Stampadocumento1: TMenuItem;
    Anteprimadistampa1: TMenuItem;
    Stampa2: TMenuItem;
    QryDocumento: TIBOQuery;
    SourceDocumento: TDataSource;
    QryDocumentoTIPODOCUMENTO: TStringField;
    QryDocumentoREGISTRO: TStringField;
    QryDocumentoNUMORDPREV: TIntegerField;
    QryDocumentoDATADOCUMENTO: TDateTimeField;
    QryDocumentoCODICECLIENTE: TIntegerField;
    QryDocumentoSELEZIONATO: TStringField;
    QryDocumentoSCONTOALIQUOTA1: TIBOFloatField;
    QryDocumentoSCONTOALIQUOTA2: TIBOFloatField;
    QryDocumentoSCONTOALIQUOTA3: TIBOFloatField;
    QryDocumentoSCONTOALIQUOTA4: TIBOFloatField;
    QryDocumentoTOTALEMARGINE: TIBOFloatField;
    QryDocumentoTOTALERIGHI1: TIBOFloatField;
    QryDocumentoTOTALERIGHI2: TIBOFloatField;
    QryDocumentoTOTALERIGHI3: TIBOFloatField;
    QryDocumentoTOTALERIGHI4: TIBOFloatField;
    QryDocumentoIMPORTOIVA1: TIBOFloatField;
    QryDocumentoIMPORTOIVA2: TIBOFloatField;
    QryDocumentoIMPORTOIVA3: TIBOFloatField;
    QryDocumentoIMPORTOIVA4: TIBOFloatField;
    QryDocumentoTOTALEIMPONIBILE1: TIBOFloatField;
    QryDocumentoTOTALEIMPONIBILE2: TIBOFloatField;
    QryDocumentoTOTALEIMPONIBILE3: TIBOFloatField;
    QryDocumentoTOTALEIMPONIBILE4: TIBOFloatField;
    QryDocumentoTOTALEDOCUMENTO: TIBOFloatField;
    QryDocumentoCAUSALE: TStringField;
    QryDocumentoSEGNOOPERAZIONE: TStringField;
    QryDocumentoDAFATTURARE: TStringField;
    QryDocumentoTRASPORTOACURA: TStringField;
    QryDocumentoDATIVETTORE: TStringField;
    QryDocumentoLISTINO: TSmallintField;
    QryDocumentoPRATICA: TIntegerField;
    QryDocumentoPAGAMENTO: TIntegerField;
    QryDocumentoINDIRIZZODESTMERCI: TStringField;
    QryDocumentoCAPDESTMERCI: TStringField;
    QryDocumentoCITTADESTMERCI: TStringField;
    QryDocumentoPROVINCIADESTMERCI: TStringField;
    QryDocumentoCODICEIVA1: TIntegerField;
    QryDocumentoCODICEIVA2: TIntegerField;
    QryDocumentoCODICEIVA3: TIntegerField;
    QryDocumentoCODICEIVA4: TIntegerField;
    QryDocumentoPRATICA2: TIntegerField;
    QryDocumentoPRATICA3: TIntegerField;
    QryDocumentoDATAPRATICA1: TDateTimeField;
    QryDocumentoDATAPRATICA2: TDateTimeField;
    QryDocumentoDATAPRATICA3: TDateTimeField;
    QryDocumentoSTATODESCRIZIONE: TStringField;
    QryDocumentoSTATOFOREGROUND: TStringField;
    QryDocumentoSTATOBACKGROUND: TStringField;
    QryDocumentoARGOMENTO: TStringField;
    QryDocumentoABBUONO: TIBOFloatField;
    QryDocumentoTOTALEDAPAGARE: TIBOFloatField;
    QryDocumentoNOTE: TStringField;
    QryDocumentoMESSAGGI: TStringField;
    QryDocumentoCODICEDESTMERCI: TIntegerField;
    QryDocumentoRAGSOCCLI: TStringField;
    QryDocumentoINDIRIZZOCLI: TStringField;
    QryDocumentoCITTACLI: TStringField;
    QryDocumentoCAPCLI: TStringField;
    QryDocumentoPROVINCIACLI: TStringField;
    QryDocumentoPARTITAIVACLI: TStringField;
    QryDocumentoABI: TStringField;
    QryDocumentoCAB: TStringField;
    QryDocumentoDATASCAD1: TDateTimeField;
    QryDocumentoDATASCAD2: TDateTimeField;
    QryDocumentoDATASCAD3: TDateTimeField;
    QryDocumentoDATASCAD4: TDateTimeField;
    QryDocumentoDATASCAD5: TDateTimeField;
    QryDocumentoIMPORTOSCAD1: TIBOFloatField;
    QryDocumentoIMPORTOSCAD2: TIBOFloatField;
    QryDocumentoIMPORTOSCAD3: TIBOFloatField;
    QryDocumentoIMPORTOSCAD4: TIBOFloatField;
    QryDocumentoIMPORTOSCAD5: TIBOFloatField;
    QryDocumentoRAGSOCDESTMERCI: TStringField;
    QryDocumentoDATATRASP: TStringField;
    QryDocumentoORATRASP: TStringField;
    QryDocumentoCODICESUBSOGG: TIntegerField;
    QryDocumentoSUBSOGGCAMPO1: TStringField;
    QryDocumentoSUBSOGGCAMPO2: TStringField;
    QryDocumentoSUBSOGGCAMPO3: TStringField;
    QryDocumentoTIPODOCUMENTOESTESO: TStringField;
    QryDocumentoCODICEMAGAZZINO: TSmallintField;
    QryDocumentoDescrizioneIVA1: TStringField;
    QryDocumentoDescrizioneIVA2: TStringField;
    QryDocumentoDescrizioneIVA3: TStringField;
    QryDocumentoDescrizioneIVA4: TStringField;
    QryDocumentoMESECOMPETENZA: TSmallintField;
    QryDocumentoOPERATORE: TStringField;
    QryDocumentoASPETTOESTERIOREBENI: TStringField;
    QryDocumentoPORTO: TStringField;
    QryDocumentoSINCHRO: TStringField;
    QryDocumentoTOTALEMERCE: TIBOFloatField;
    QryDocumentoTOTALESCONTI: TIBOFloatField;
    QryDocumentoTOTALENETTOMERCE: TIBOFloatField;
    QryDocumentoSPESE: TIBOFloatField;
    QryDocumentoTOTALEIMPONIBILE: TIBOFloatField;
    QryDocumentoTOTALEIVA: TIBOFloatField;
    QryDocumentoNUMCOLLI: TStringField;
    WidthRighi: TIBOQuery;
    QryDocumentoALIQUOTAIVA1: TFloatField;
    QryDocumentoALIQUOTAIVA2: TFloatField;
    QryDocumentoALIQUOTAIVA3: TFloatField;
    QryDocumentoALIQUOTAIVA4: TFloatField;
    WidthRighiTIPODOCUMENTO: TStringField;
    WidthRighiREGISTRO: TStringField;
    WidthRighiNUMORDPREV: TIntegerField;
    WidthRighiDATADOCUMENTO: TDateTimeField;
    WidthRighiPROGRIGO: TIntegerField;
    WidthRighiCODICECLIENTE: TIntegerField;
    WidthRighiCODICEARTICOLO: TStringField;
    WidthRighiPREZZOUNITARIO: TIBOFloatField;
    WidthRighiQTA: TIBOFloatField;
    WidthRighiSCONTORIGO: TIBOFloatField;
    WidthRighiSCONTORIGO2: TIBOFloatField;
    WidthRighiSCONTORIGO3: TIBOFloatField;
    WidthRighiUNITADIMISURA: TStringField;
    WidthRighiPREZZOACQUISTOARTICOLO: TIBOFloatField;
    WidthRighiSELEZIONATO: TStringField;
    WidthRighiCODICEIVA: TIntegerField;
    WidthRighiMARGINE: TIBOFloatField;
    WidthRighiNOTERIGO: TStringField;
    WidthRighiMOVMAG: TStringField;
    WidthRighiPREZZOUNITARIOIVACOMPRESA: TIBOFloatField;
    WidthRighiIMPORTORIGO: TIBOFloatField;
    WidthRighiIMPORTOMARGINE: TIBOFloatField;
    WidthRighiIMPORTORIGOIVACOMPRESA: TIBOFloatField;
    WidthRighiDESCRIZIONEIVA: TStringField;
    WidthRighiALIQUOTAIVA: TIBOFloatField;
    WidthRighiCODICEMAGAZZINO: TSmallintField;
    WidthRighiSINCHRO: TStringField;
    ClientTopPanel: TbmpPanel;
    Stampaleetichettedegliarticolideldocumento1: TMenuItem;
    QryDocumentoPRZUNITOPERA: TIBOFloatField;
    Stampadocumentoconesplosionearticolicomposti1: TMenuItem;
    Anteprimadistampa3: TMenuItem;
    Stampa3: TMenuItem;
    Esplodiirighiselezionati1: TMenuItem;
    Esplodituttiirighideldocumento1: TMenuItem;
    N5: TMenuItem;
    QryDocumentoCODICEIVAFORZATA: TIntegerField;
    QryDocumentoDESCRIZIONEIVAFORZATA: TStringField;
    QryDocumentoALIQUOTAIVAFORZATA: TIBOFloatField;
    WidthRighiPROGRIGO2: TIntegerField;
    WidthRighiDESCRIZIONE: TMemoField;
    WidthRighiPRZUNITOPERA: TIBOFloatField;
    WidthRighiQTAOPERA: TIBOFloatField;
    WidthRighiIMPORTOOPERA: TIBOFloatField;
    WidthRighiIMPORTOCOMPONENTI: TIBOFloatField;
    QryDocumentoSTARTMEMO: TBlobField;
    QryDocumentoENDMEMO: TBlobField;
    N6: TMenuItem;
    Editordescrizione1: TMenuItem;
    Azzeragliscontideirighiselezionati1: TMenuItem;
    Azzeragliscontidituttiirighi1: TMenuItem;
    WidthRighiMINUTIPREVISTI: TIntegerField;
    QryDocumentoCAUSALECANTIERE: TStringField;
    QryDocumentoSEGNOOPERAZIONECANTIERE: TStringField;
    WidthRighiSOTTOCANTIERE1: TStringField;
    WidthRighiSOTTOCANTIERE2: TStringField;
    WidthRighiSOTTOCANTIERE3: TStringField;
    Convertinomearticoloinnomegruppo1: TMenuItem;
    QryDocumentoVALIDITAGG: TSmallintField;
    QryDocumentoVALIDITADATA: TDateTimeField;
    QryDocumentoCONSEGNAGG: TSmallintField;
    QryDocumentoCONSEGNADATA: TDateTimeField;
    QryDocumentoCONSEGNATO: TStringField;
    Button1: TButton;
    QryDocumentoNUMCIVICOCLI: TStringField;
    QryDocumentoCODICEFISCALECLI: TStringField;
    QryDocumentoVALIDITADOCUMENTO: TStringField;
    QryDocumentoCONSEGNA: TStringField;
    QryDocumentoNUMCIVICODESTMERCI: TStringField;
    WidthRighiSOTTOCANTIERE4: TStringField;
    WidthRighiSOTTOCANTIERE5: TStringField;
    WidthRighiSOTTOCANTIERE6: TStringField;
    Selezionecumulativasottocantieri1: TMenuItem;
    QryDocumentoRITACCPERC: TIBOFloatField;
    QryDocumentoRITACC: TIBOFloatField;
    MenuEmail: TPopupMenu;
    Inviadocumentonormale1: TMenuItem;
    Inviadocumentoconesplosionearticolicomposti1: TMenuItem;
    WidthRighiSEGNOOPERAZIONECANTIERE: TStringField;
    WidthRighiPRATICA: TIntegerField;
    WidthRighiDATAPRATICA1: TDateTimeField;
    WidthRighiCODICECONF: TIntegerField;
    WidthRighiDATACONF: TDateTimeField;
    WidthRighiPROGRIGOCONF: TIntegerField;
    WidthRighiTIPO: TSmallintField;
    WidthRighiBITMAPFILENAME: TStringField;
    WidthRighiBITMAPFILENAME2: TStringField;
    WidthRighiQTAEVASA: TIBOFloatField;
    WidthRighiTIPO1: TStringField;
    WidthRighiTIPO2: TStringField;
    WidthRighiTIPO3: TStringField;
    WidthRighiTIPO4: TStringField;
    WidthRighiTIPO5: TStringField;
    WidthRighiTIPO6: TStringField;
    EsportaleQtinevasionenellabacheca1: TMenuItem;
    QryDocumentoORDINECHIUSO: TStringField;
    QryDocumentoRITACCPERCIMPONIBILE: TIBOFloatField;
    SelezionecumulativaaliquotaIVA1: TMenuItem;
    Aumentocumulativoprezzoarticoli1: TMenuItem;
    Consideralasituazioneattualecomecostoericarica1: TMenuItem;
    PanelRicarico: TPanel;
    Label124: TLabel;
    BtnRicaricoOk: TBitBtn;
    BtnRicaricoExit: TBitBtn;
    eRicarico: TcxMaskEdit;
    QTipoOre1: TIBOQuery;
    QTipoOre1DESCRIZIONE: TStringField;
    STipoOre1: TDataSource;
    QTipoOre2: TIBOQuery;
    StringField1: TStringField;
    STipoOre2: TDataSource;
    QTipoOre3: TIBOQuery;
    StringField2: TStringField;
    STipoOre3: TDataSource;
    TotaleacorpoSOLOdeirighiselezionati1: TMenuItem;
    QryDocumentoBARCODE: TStringField;
    QryDocumentoRIFSOGG1_CODICE: TIntegerField;
    QryDocumentoRIFSOGG1_TIPO: TStringField;
    QryDocumentoRIFSOGG1_RAGIONESOCIALE: TStringField;
    QryDocumentoRIFSOGG2_CODICE: TIntegerField;
    QryDocumentoRIFSOGG2_TIPO: TStringField;
    QryDocumentoRIFSOGG2_RAGIONESOCIALE: TStringField;
    QryDocumentoRIFSOGG3_CODICE: TIntegerField;
    QryDocumentoRIFSOGG3_TIPO: TStringField;
    QryDocumentoRIFSOGG3_RAGIONESOCIALE: TStringField;
    QryDocumentoRIFSOGG4_CODICE: TIntegerField;
    QryDocumentoRIFSOGG4_TIPO: TStringField;
    QryDocumentoRIFSOGG4_RAGIONESOCIALE: TStringField;
    QryDocumentoRIFSOGG5_CODICE: TIntegerField;
    QryDocumentoRIFSOGG5_TIPO: TStringField;
    QryDocumentoRIFSOGG5_RAGIONESOCIALE: TStringField;
    QryDocumentoRIFSOGG6_CODICE: TIntegerField;
    QryDocumentoRIFSOGG6_TIPO: TStringField;
    QryDocumentoRIFSOGG6_RAGIONESOCIALE: TStringField;
    QryDocumentoAGENTE: TStringField;
    QryDocumentoPRZUNITOPERA1: TIBOFloatField;
    QryDocumentoPRZUNITOPERA2: TIBOFloatField;
    QryDocumentoPRZUNITOPERA3: TIBOFloatField;
    QryDocumentoPRZUNITOPERA4: TIBOFloatField;
    Button2: TButton;
    RE: TcxRichEdit;
    QryDocumentoRIFSOGG7_CODICE: TIntegerField;
    QryDocumentoRIFSOGG7_TIPO: TStringField;
    QryDocumentoRIFSOGG7_RAGIONESOCIALE: TStringField;
    QryDocumentoRIFSOGG8_CODICE: TIntegerField;
    QryDocumentoRIFSOGG8_TIPO: TStringField;
    QryDocumentoRIFSOGG8_RAGIONESOCIALE: TStringField;
    QryDocumentoRIFSOGG9_CODICE: TIntegerField;
    QryDocumentoRIFSOGG9_TIPO: TStringField;
    QryDocumentoRIFSOGG9_RAGIONESOCIALE: TStringField;
    QryDocumentoRIFSOGG10_CODICE: TIntegerField;
    QryDocumentoRIFSOGG10_TIPO: TStringField;
    QryDocumentoRIFSOGG10_RAGIONESOCIALE: TStringField;
    QryDocumentoSTMPREF: TBlobField;
    QryDocumentoEXPORTED: TStringField;
    QryDocumentoPROTOCOLLO: TIntegerField;
    Button6: TButton;
    QryDocumentoRITACCSUPERCIMP: TStringField;
    QryDocumentoRITACCSUIMPORTOIMP: TStringField;
    QryDocumentoRITACCIMPONIBILE: TIBOFloatField;
    EsportaTesto1: TMenuItem;
    EsportaExcel1: TMenuItem;
    QryDocumentoCODICEMAGAZZINO2: TSmallintField;
    WidthRighiCODICEMAGAZZINO2: TSmallintField;
    N7: TMenuItem;
    N8: TMenuItem;
    N9: TMenuItem;
    N11: TMenuItem;
    Aggiornaiprezzideirighiselezionati1: TMenuItem;
    N1: TMenuItem;
    Mostralacolonnadelcodicearticoloreale1: TMenuItem;
    TimerDocState: TTimer;
    QryDocumentoAGENTE2: TStringField;
    QryDocumentoAGENTE3: TStringField;
    QryDocumentoAGENTE4: TStringField;
    FormMainPanel: TPanel;
    ClientArea: TcxPageControl;
    TabDoc: TcxTabSheet;
    DocClientArea: TScrollBox;
    PanelCorpoDoc: TPanel;
    GridCorpo: TcxGrid;
    tvCorpo: TcxGridTableView;
    tvCorpoMOVMAG: TcxGridColumn;
    tvCorpoCODICEMAGAZZINO: TcxGridColumn;
    tvCorpoCODICEMAGAZZINO2: TcxGridColumn;
    tvCorpoCODICEARTICOLO: TcxGridColumn;
    tvCorpoCODICEARTICOLOSTM: TcxGridColumn;
    tvCorpoDESCRIZIONE: TcxGridColumn;
    tvCorpoPREZZOUNITARIO: TcxGridColumn;
    tvCorpoPREZZOUNITARIOIVACOMPRESA: TcxGridColumn;
    tvCorpoPRZUNITNETTO: TcxGridColumn;
    tvCorpoUNITADIMISURA: TcxGridColumn;
    tvCorpoQTA: TcxGridColumn;
    tvCorpoQTAINEVASIONE: TcxGridColumn;
    tvCorpoQTAEVASA: TcxGridColumn;
    tvCorpoQTADAEVADERE: TcxGridColumn;
    tvCorpoSCONTORIGO: TcxGridColumn;
    tvCorpoSCONTORIGO2: TcxGridColumn;
    tvCorpoSCONTORIGO3: TcxGridColumn;
    tvCorpoIMPORTORIGO: TcxGridColumn;
    tvCorpoIMPORTORIGOIVACOMPRESA: TcxGridColumn;
    tvCorpoCODICEIVA: TcxGridColumn;
    tvCorpoDESCRIZIONEIVA: TcxGridColumn;
    tvCorpoALIQUOTAIVA: TcxGridColumn;
    tvCorpoNOTERIGO: TcxGridColumn;
    tvCorpoPREZZOACQUISTOARTICOLO: TcxGridColumn;
    tvCorpoMARGINE: TcxGridColumn;
    tvCorpoIMPORTOMARGINE: TcxGridColumn;
    tvCorpoQTAOPERA: TcxGridColumn;
    tvCorpoIMPORTOOPERA: TcxGridColumn;
    tvCorpoIMPORTOCOMPONENTI: TcxGridColumn;
    tvCorpoSELEZIONATO: TcxGridColumn;
    tvCorpoMINUTIPREVISTI: TcxGridColumn;
    tvCorpoSOTTOCANTIERE1: TcxGridColumn;
    tvCorpoSOTTOCANTIERE2: TcxGridColumn;
    tvCorpoSOTTOCANTIERE3: TcxGridColumn;
    tvCorpoSOTTOCANTIERE4: TcxGridColumn;
    tvCorpoSOTTOCANTIERE5: TcxGridColumn;
    tvCorpoSOTTOCANTIERE6: TcxGridColumn;
    tvCorpoTIPO1: TcxGridColumn;
    tvCorpoTIPO2: TcxGridColumn;
    tvCorpoTIPO3: TcxGridColumn;
    tvCorpoTIPO4: TcxGridColumn;
    tvCorpoTIPO5: TcxGridColumn;
    tvCorpoTIPO6: TcxGridColumn;
    tvCorpoTODELETE: TcxGridColumn;
    tvCorpoGC_COSTONETTOUNITARIO_MOD: TcxGridColumn;
    tvCorpoGC_COSTONETTOUNITARIO: TcxGridColumn;
    tvCorpoGC_RICARICO_MOD: TcxGridColumn;
    tvCorpoGC_RICARICO: TcxGridColumn;
    tvCorpoGC_QTA_MOD: TcxGridColumn;
    tvCorpoGC_QTA: TcxGridColumn;
    tvCorpoGC_DESCRIZIONE_MOD: TcxGridColumn;
    tvCorpoGC_DESCRIZIONE: TcxGridColumn;
    tvCorpoGUID: TcxGridColumn;
    tvCorpoGUID_REF: TcxGridColumn;
    tvCorpoGUID_ANCESTOR: TcxGridColumn;
    tvCorpoORDER: TcxGridColumn;
    tvDiBa: TcxGridTableView;
    tvDiBaMOVMAG: TcxGridColumn;
    tvDiBaCODICEMAGAZZINO: TcxGridColumn;
    tvDiBaCODICEMAGAZZINO2: TcxGridColumn;
    tvDiBaCODICEARTICOLO: TcxGridColumn;
    tvDiBaCODICEARTICOLOSTM: TcxGridColumn;
    tvDiBaDESCRIZIONE: TcxGridColumn;
    tvDiBaPREZZOUNITARIO: TcxGridColumn;
    tvDiBaPREZZOUNITARIOIVACOMPRESA: TcxGridColumn;
    tvDiBaPRZUNITNETTO: TcxGridColumn;
    tvDiBaUNITADIMISURA: TcxGridColumn;
    tvDiBaQTA: TcxGridColumn;
    tvDiBaQTAINEVASIONE: TcxGridColumn;
    tvDiBaQTAEVASA: TcxGridColumn;
    tvDiBaQTADAEVADERE: TcxGridColumn;
    tvDiBaSCONTORIGO: TcxGridColumn;
    tvDiBaSCONTORIGO2: TcxGridColumn;
    tvDiBaSCONTORIGO3: TcxGridColumn;
    tvDiBaIMPORTORIGO: TcxGridColumn;
    tvDiBaIMPORTORIGOIVACOMPRESA: TcxGridColumn;
    tvDiBaCODICEIVA: TcxGridColumn;
    tvDiBaDESCRIZIONEIVA: TcxGridColumn;
    tvDiBaALIQUOTAIVA: TcxGridColumn;
    tvDiBaNOTERIGO: TcxGridColumn;
    tvDiBaPREZZOACQUISTOARTICOLO: TcxGridColumn;
    tvDiBaMARGINE: TcxGridColumn;
    tvDiBaIMPORTOMARGINE: TcxGridColumn;
    tvDiBaQTAOPERA: TcxGridColumn;
    tvDiBaIMPORTOOPERA: TcxGridColumn;
    tvDiBaIMPORTOCOMPONENTI: TcxGridColumn;
    tvDiBaSELEZIONATO: TcxGridColumn;
    tvDiBaMINUTIPREVISTI: TcxGridColumn;
    tvDiBaSOTTOCANTIERE1: TcxGridColumn;
    tvDiBaSOTTOCANTIERE2: TcxGridColumn;
    tvDiBaSOTTOCANTIERE3: TcxGridColumn;
    tvDiBaSOTTOCANTIERE4: TcxGridColumn;
    tvDiBaSOTTOCANTIERE5: TcxGridColumn;
    tvDiBaSOTTOCANTIERE6: TcxGridColumn;
    tvDiBaTIPO1: TcxGridColumn;
    tvDiBaTIPO2: TcxGridColumn;
    tvDiBaTIPO3: TcxGridColumn;
    tvDiBaTIPO4: TcxGridColumn;
    tvDiBaTIPO5: TcxGridColumn;
    tvDiBaTIPO6: TcxGridColumn;
    tvDiBaTODELETE: TcxGridColumn;
    tvDiBaGC_COSTONETTOUNITARIO_MOD: TcxGridColumn;
    tvDiBaGC_COSTONETTOUNITARIO: TcxGridColumn;
    tvDiBaGC_RICARICO_MOD: TcxGridColumn;
    tvDiBaGC_RICARICO: TcxGridColumn;
    tvDiBaGC_QTA_MOD: TcxGridColumn;
    tvDiBaGC_QTA: TcxGridColumn;
    tvDiBaGC_DESCRIZIONE_MOD: TcxGridColumn;
    tvDiBaGC_DESCRIZIONE: TcxGridColumn;
    tvDiBaGUID: TcxGridColumn;
    tvDiBaGUID_REF: TcxGridColumn;
    tvDiBaGUID_ANCESTOR: TcxGridColumn;
    tvDiBaORDER: TcxGridColumn;
    tvOre: TcxGridTableView;
    tvOreCODDIPENDENTE: TcxGridColumn;
    tvOreDESCRIZDIPENDENTE: TcxGridColumn;
    tvOreQTA: TcxGridColumn;
    tvOreNOTE: TcxGridColumn;
    tvOreTIPOORE1: TcxGridColumn;
    tvOreTIPOORE2: TcxGridColumn;
    tvOreTIPOORE3: TcxGridColumn;
    tvOrePRZUNITVEND: TcxGridColumn;
    tvOreIMPORTOVEND: TcxGridColumn;
    tvOreCOSTOORARIO: TcxGridColumn;
    tvOreIMPORTOCOSTOORARIO: TcxGridColumn;
    tvOreOPERAINDEX: TcxGridColumn;
    tvOreGC_COSTONETTOUNITARIO_MOD: TcxGridColumn;
    tvOreGC_COSTONETTOUNITARIO: TcxGridColumn;
    tvOreGC_RICARICO_MOD: TcxGridColumn;
    tvOreGC_RICARICO: TcxGridColumn;
    tvOreGC_QTA_MOD: TcxGridColumn;
    tvOreGC_QTA: TcxGridColumn;
    tvOreGC_DESCRIZIONE_MOD: TcxGridColumn;
    tvOreGC_DESCRIZIONE: TcxGridColumn;
    tvOreGUID: TcxGridColumn;
    tvOreGUID_REF: TcxGridColumn;
    tvOreGUID_ANCESTOR: TcxGridColumn;
    lvCorpo: TcxGridLevel;
    lvDiBa: TcxGridLevel;
    lvOre: TcxGridLevel;
    PanelDescrizione: TPanel;
    MemoDescrizione: TMemo;
    PanelButtonsDescrizione: TPanel;
    BtnDescrizioneOk: TBitBtn;
    BtnDescrizioneCancel: TBitBtn;
    PanelAddArt: TPanel;
    Label73: TLabel;
    SBAddArt: TSpeedButton;
    ExtTermImport: TSpeedButton;
    SBImportPalmare: TSpeedButtonRollOver;
    Label131: TLabel;
    SBTrovaArt: TSpeedButton;
    Shape4: TShape;
    Shape20: TShape;
    Shape21: TShape;
    Shape22: TShape;
    AddArt: TEdit;
    PanelBodyStateSelector: TPanel;
    sbBodyFullStretched: TSpeedButtonRollOver;
    sbBodyHorzStretched: TSpeedButtonRollOver;
    sbBodyNormal: TSpeedButtonRollOver;
    TrovaArt: TEdit;
    PanelSottocantieriCumulativi: TPanel;
    Label55: TLabel;
    Label115: TLabel;
    Label116: TLabel;
    SCC1: TcxComboBox;
    SCC2: TcxComboBox;
    SCC3: TcxComboBox;
    BtnOk: TBitBtn;
    BtnExit: TBitBtn;
    PanelAumentoPrezzi: TPanel;
    Label123: TLabel;
    BtnAumentoOk: TBitBtn;
    BtnAumentoExit: TBitBtn;
    eAumento: TcxMaskEdit;
    PanelUpper: TPanel;
    PanelNumDataDocumento: TPanel;
    ShapeDocumento: TShape;
    ShapeAzioni: TShape;
    LabelData: TLabel;
    SBKioskConfermaDoc: TSpeedButtonRollOver;
    LabelDocumento: TLabel;
    LabelAzioni: TLabel;
    LabelAzioneMagazzino: TLabel;
    LabelAzioneCantiere: TLabel;
    LabelNumReg: TLabel;
    TipoDocumento: TcxDBComboBox;
    DBEditNumDoc: TcxDBTextEdit;
    DBComboRegistro: TcxDBComboBox;
    DBEDataDoc: TcxDBDateEdit;
    DbeAzioneMagazzino: TcxComboBox;
    DbeAzioneCantiere: TcxComboBox;
    DBEditSegnoOperazione: TDBEdit;
    DBEditSegnoOperazioneCantiere: TDBEdit;
    PanelCantiere: TPanel;
    LabelCantiere: TLabel;
    BitBtnPratica1: TSpeedButtonRollOver;
    DbeDescrizioneCantiere: TcxTextEdit;
    DBEditProtocollo: TcxDBTextEdit;
    MainPanelOpzioni: TPanel;
    Label72: TLabel;
    PanelTipoNumData: TPanel;
    Label18: TLabel;
    Label20: TLabel;
    BitBtnCausale: TSpeedButtonRollOver;
    Label16: TLabel;
    BitBtnForzaIva: TSpeedButtonRollOver;
    DBEditCausale: TDBEdit;
    DBEFOrzaIVA: TDBEdit;
    PanelSubSogg: TPanel;
    LabelSubSogg1: TLabel;
    LabelSubSogg2: TLabel;
    LabelSubSogg3: TLabel;
    BitBtnSubSogg: TSpeedButtonRollOver;
    DBESubSogg1: TDBEdit;
    DBESubSogg2: TDBEdit;
    DBESubSogg3: TDBEdit;
    PanelStato: TPanel;
    LabelMagazzino: TLabel;
    LabelMeseCompetenza: TLabel;
    BitBtnMagazzino: TSpeedButtonRollOver;
    BitBtnSelezioneStato: TSpeedButtonRollOver;
    LabelStatoDocumento: TLabel;
    LabelAgente: TLabel;
    LabelMagazzino2: TLabel;
    BitBtnMagazzino2: TSpeedButtonRollOver;
    DBEditMagazzino: TDBEdit;
    DBEditStatoDocumento: TDBEdit;
    DbeOrdineChiuso: TcxDBCheckBox;
    DBEditMagazzino2: TDBEdit;
    PanelAgenti: TPanel;
    LabelAgente2: TLabel;
    LabelAgente3: TLabel;
    LabelAgente4: TLabel;
    PanelDatiArticolo: TPanel;
    Label98: TLabel;
    Label99: TLabel;
    Label100: TLabel;
    LabelDescrizioneArticolo: TLabel;
    LabelCodiceArticolo: TLabel;
    PanelDestinatario: TPanel;
    Label27: TLabel;
    MittenteDestinatario: TLabel;
    BitBtnCliente: TSpeedButtonRollOver;
    BitBtnEspandiCliente: TSpeedButtonRollOver;
    DBText1: TDBText;
    Label54: TLabel;
    DBERagSocCli: TDBEdit;
    DBEdit3: TDBEdit;
    DBEdit4: TDBEdit;
    DBEdit5: TDBEdit;
    DBEdit6: TDBEdit;
    dbePartitaIVA: TDBEdit;
    dbeCodiceFiscale: TDBEdit;
    DBEdit8: TDBEdit;
    PanelLuogoDestinazione: TPanel;
    LabelPanelDestinazioneMerce: TLabel;
    BitBtnDestinazioneMerci: TSpeedButtonRollOver;
    DBEdit23: TDBEdit;
    DBEdit24: TDBEdit;
    DBEdit25: TDBEdit;
    DBEdit26: TDBEdit;
    DBERagSocDest: TDBEdit;
    DBEdit10: TDBEdit;
    PanelLower: TPanel;
    PanelPiede1: TPanel;
    Shape19: TShape;
    Label43: TLabel;
    Shape2: TShape;
    Label36: TLabel;
    Label39: TLabel;
    Label40: TLabel;
    Label41: TLabel;
    Label42: TLabel;
    Label44: TLabel;
    Label45: TLabel;
    Label58: TLabel;
    Label59: TLabel;
    Label60: TLabel;
    Label61: TLabel;
    Shape3: TShape;
    DBText12: TDBText;
    DBText13: TDBText;
    DBText14: TDBText;
    TotaleMerce11: TDBText;
    TotaleMerce21: TDBText;
    TotaleMerce31: TDBText;
    TotaleMerce41: TDBText;
    Imponibile11: TDBText;
    Imponibile21: TDBText;
    Imponibile31: TDBText;
    Imponibile41: TDBText;
    DescIVA11: TDBText;
    DescIVA21: TDBText;
    DescIVA31: TDBText;
    DescIVA41: TDBText;
    ImportoIVA11: TDBText;
    ImportoIVA21: TDBText;
    ImportoIVA31: TDBText;
    ImportoIVA41: TDBText;
    DBText35: TDBText;
    dbeTotaleDaPagare: TDBText;
    LabelAbbuono: TLabel;
    Label121: TLabel;
    Label117: TLabel;
    Label118: TLabel;
    DbeRitAccSuimportoImp: TcxDBCheckBox;
    DbeRitAccSuPercImp: TcxDBCheckBox;
    Sconto11: TDBEdit;
    Sconto21: TDBEdit;
    Sconto31: TDBEdit;
    Sconto41: TDBEdit;
    DBEdit105: TDBEdit;
    DBEdit120: TDBEdit;
    PanelFinalePiede: TPanel;
    SBApriChiudiTotaliMargini1: TSpeedButtonRollOver;
    DBEdit13: TDBEdit;
    DBEdit14: TDBEdit;
    dbeAbbuono: TDBEdit;
    DBEdit2: TDBEdit;
    PanelPiede2: TPanel;
    Label74: TLabel;
    Label75: TLabel;
    Label76: TLabel;
    Label78: TLabel;
    Label79: TLabel;
    Label80: TLabel;
    Label81: TLabel;
    Label82: TLabel;
    Label83: TLabel;
    Label84: TLabel;
    Label85: TLabel;
    Label86: TLabel;
    Label87: TLabel;
    Label88: TLabel;
    Shape5: TShape;
    Shape6: TShape;
    Shape7: TShape;
    DBText37: TDBText;
    DBText38: TDBText;
    DBText40: TDBText;
    DBText41: TDBText;
    DBText42: TDBText;
    DBText43: TDBText;
    DBText44: TDBText;
    TotaleMerce12: TDBText;
    TotaleMerce22: TDBText;
    TotaleMerce32: TDBText;
    TotaleMerce42: TDBText;
    Imponibile12: TDBText;
    Imponibile22: TDBText;
    Imponibile32: TDBText;
    Imponibile42: TDBText;
    DescIVA12: TDBText;
    DescIVA22: TDBText;
    DescIVA32: TDBText;
    DescIVA42: TDBText;
    ImportoIVA12: TDBText;
    ImportoIVA22: TDBText;
    ImportoIVA32: TDBText;
    ImportoIVA42: TDBText;
    Sconto12: TDBEdit;
    Sconto22: TDBEdit;
    Sconto32: TDBEdit;
    Sconto42: TDBEdit;
    DBEdit156: TDBEdit;
    DBEdit160: TDBEdit;
    PanelPiede3: TPanel;
    Label5: TLabel;
    Label6: TLabel;
    Label7: TLabel;
    Label8: TLabel;
    Label9: TLabel;
    Label24: TLabel;
    Label25: TLabel;
    Label26: TLabel;
    Label34: TLabel;
    Label37: TLabel;
    Label68: TLabel;
    Label69: TLabel;
    Shape9: TShape;
    DBText39: TDBText;
    DBText65: TDBText;
    DBText66: TDBText;
    DBText67: TDBText;
    DBText68: TDBText;
    DBText69: TDBText;
    TotaleMerce13: TDBText;
    TotaleMerce23: TDBText;
    TotaleMerce33: TDBText;
    TotaleMerce43: TDBText;
    Imponibile13: TDBText;
    Imponibile23: TDBText;
    Imponibile33: TDBText;
    Imponibile43: TDBText;
    DescIVA13: TDBText;
    DescIVA23: TDBText;
    DescIVA33: TDBText;
    DescIVA43: TDBText;
    ImportoIVA13: TDBText;
    ImportoIVA23: TDBText;
    ImportoIVA33: TDBText;
    ImportoIVA43: TDBText;
    Sconto13: TDBEdit;
    Sconto23: TDBEdit;
    Sconto33: TDBEdit;
    Sconto43: TDBEdit;
    DBEdit79: TDBEdit;
    PanelAnnotazioni: TPanel;
    Label17: TLabel;
    PanelArgomento: TPanel;
    Label51: TLabel;
    DBEdit110: TDBEdit;
    PanelNote: TPanel;
    Label35: TLabel;
    DbeNote: TDBMemo;
    PanelMessaggi: TPanel;
    LabelMessaggi: TLabel;
    DbeMessaggi: TDBMemo;
    MainPanelPagamento: TPanel;
    Label19: TLabel;
    PanelBanca: TPanel;
    Label13: TLabel;
    Label14: TLabel;
    Label2: TLabel;
    BitBtnBanca: TSpeedButtonRollOver;
    Banca: TEdit;
    ABI: TEdit;
    CAB: TEdit;
    PanelScadenze: TPanel;
    Label10: TLabel;
    DBEdit16: TDBEdit;
    DBEdit17: TDBEdit;
    DBEdit18: TDBEdit;
    DBEdit19: TDBEdit;
    DBEdit20: TDBEdit;
    DBEdit21: TDBEdit;
    DBEdit111: TDBEdit;
    DBEdit112: TDBEdit;
    DBEdit113: TDBEdit;
    DBEdit114: TDBEdit;
    PanelPagamento: TPanel;
    Label49: TLabel;
    BitBtnPagamento: TSpeedButtonRollOver;
    DescrizionePagamento: TEdit;
    PanelOperatore: TPanel;
    Label56: TLabel;
    Label30: TLabel;
    DBText90: TDBText;
    Label3: TLabel;
    Label31: TLabel;
    Label28: TLabel;
    Label114: TLabel;
    DBEConsegnaGG: TDBEdit;
    DBEValiditaGG: TDBEdit;
    DBEConsegnato: TDBCheckBox;
    PanelPratiche: TPanel;
    Label1: TLabel;
    Label22: TLabel;
    Label23: TLabel;
    LabelPanelPraticheCaption: TLabel;
    BitBtnPratica2: TSpeedButtonRollOver;
    BitBtnPratica3: TSpeedButtonRollOver;
    Label32: TLabel;
    Label33: TLabel;
    Label38: TLabel;
    Label62: TLabel;
    Label63: TLabel;
    Label64: TLabel;
    Label65: TLabel;
    Label66: TLabel;
    Label67: TLabel;
    BitBtnPratica1_1: TSpeedButtonRollOver;
    DBECodicePratica1: TDBEdit;
    DBECodicePratica2: TDBEdit;
    DBECodicePratica3: TDBEdit;
    DBEdit11: TDBEdit;
    DBEdit12: TDBEdit;
    DBEdit15: TDBEdit;
    EditDescrizionePratica1: TEdit;
    EditDescrizionePratica2: TEdit;
    EditDescrizionePratica3: TEdit;
    MainPanelTrasporto: TPanel;
    Label29: TLabel;
    PanelTrasporto: TPanel;
    Label48: TLabel;
    Label50: TLabel;
    Label57: TLabel;
    dbeDatiVettore: TDBEdit;
    PanelColli: TPanel;
    Label11: TLabel;
    Label4: TLabel;
    Label53: TLabel;
    DBEdit116: TDBEdit;
    DBEdit9: TDBEdit;
    DBEdit22: TDBEdit;
    DBEdit1: TDBEdit;
    PanelTotaliMargini: TPanel;
    Label110: TLabel;
    Label107: TLabel;
    Shape11: TShape;
    Shape13: TShape;
    LabelDescOpera: TLabel;
    LabelDescOpera1: TLabel;
    LabelDescOpera2: TLabel;
    LabelDescOpera3: TLabel;
    LabelDescOpera4: TLabel;
    Label15: TLabel;
    TBVariazioneMargine: TcxTrackBar;
    EditVariazioneMargine: TcxCurrencyEdit;
    PanelTesti: TPanel;
    Label113: TLabel;
    DBMStartPreventivo: TDBMemo;
    DBMEndPreventivo: TDBMemo;
    PanelAltriSoggetti: TPanel;
    Label70: TLabel;
    Label21: TLabel;
    Label71: TLabel;
    Label125: TLabel;
    SbRifSogg2: TSpeedButtonRollOver;
    SbRifSogg3: TSpeedButtonRollOver;
    SbRifSogg1: TSpeedButtonRollOver;
    Label126: TLabel;
    Label127: TLabel;
    Label128: TLabel;
    SbRifSogg5: TSpeedButtonRollOver;
    SbRifSogg6: TSpeedButtonRollOver;
    SbRifSogg4: TSpeedButtonRollOver;
    Label132: TLabel;
    SbRifSogg7: TSpeedButtonRollOver;
    Label133: TLabel;
    SbRifSogg8: TSpeedButtonRollOver;
    Label134: TLabel;
    SbRifSogg9: TSpeedButtonRollOver;
    Label135: TLabel;
    SbRifSogg10: TSpeedButtonRollOver;
    DbeRifSogg1Tipo: TDBEdit;
    DbeRifSogg2Tipo: TDBEdit;
    DbeRifSogg3Tipo: TDBEdit;
    DbeRifSogg4Tipo: TDBEdit;
    DbeRifSogg5Tipo: TDBEdit;
    DbeRifSogg6Tipo: TDBEdit;
    DbeRifSogg1Codice: TDBEdit;
    DbeRifSogg2Codice: TDBEdit;
    DbeRifSogg3Codice: TDBEdit;
    DbeRifSogg4Codice: TDBEdit;
    DbeRifSogg5Codice: TDBEdit;
    DbeRifSogg6Codice: TDBEdit;
    DbeRifSogg1RagSoc: TDBEdit;
    DbeRifSogg2RagSoc: TDBEdit;
    DbeRifSogg3RagSoc: TDBEdit;
    DbeRifSogg4RagSoc: TDBEdit;
    DbeRifSogg5RagSoc: TDBEdit;
    DbeRifSogg6RagSoc: TDBEdit;
    DbeRifSogg7Tipo: TDBEdit;
    DbeRifSogg7Codice: TDBEdit;
    DbeRifSogg7RagSoc: TDBEdit;
    DbeRifSogg8Tipo: TDBEdit;
    DbeRifSogg8Codice: TDBEdit;
    DbeRifSogg8RagSoc: TDBEdit;
    DbeRifSogg9Tipo: TDBEdit;
    DbeRifSogg9Codice: TDBEdit;
    DbeRifSogg9RagSoc: TDBEdit;
    DbeRifSogg10Tipo: TDBEdit;
    DbeRifSogg10Codice: TDBEdit;
    DbeRifSogg10RagSoc: TDBEdit;
    TabFullBody: TcxTabSheet;
    TabStampa: TcxTabSheet;
    StampaClientArea: TScrollBox;
    PanelGruppo1: TPanel;
    LabelGruppo1: TLabel;
    RichEdit1: TRichEdit;
    StmColCodiceArticolo: TcxCheckBox;
    StmColDescrizione: TcxCheckBox;
    StmColPrezzoUnitario: TcxCheckBox;
    StmColUM: TcxCheckBox;
    StmColQta: TcxCheckBox;
    StmColSconto1: TcxCheckBox;
    StmColSconto2: TcxCheckBox;
    StmColSconto3: TcxCheckBox;
    StmColImporto: TcxCheckBox;
    StmColCodiceIVA: TcxCheckBox;
    StmColDescrizioneIVA: TcxCheckBox;
    StmColNote: TcxCheckBox;
    StmColCostoUnitario: TcxCheckBox;
    StmColRicarico: TcxCheckBox;
    StmColRicaricoImporto: TcxCheckBox;
    Panel1: TPanel;
    Label52: TLabel;
    RichEdit2: TRichEdit;
    StmSezDestinazioneMerce: TcxCheckBox;
    StmSezCantiere: TcxCheckBox;
    StmSezCastellettoIVA: TcxCheckBox;
    StmSezRifAltriSogg: TcxCheckBox;
    StmSezNote: TcxCheckBox;
    StmSezMessaggi: TcxCheckBox;
    StmSezTrasporto: TcxCheckBox;
    StmSezTotaliDoc: TcxCheckBox;
    StmSezScadenze: TcxCheckBox;
    StmSezPagamento: TcxCheckBox;
    StmSezBanca: TcxCheckBox;
    StmSezOperatore: TcxCheckBox;
    StmSezLogo: TcxCheckBox;
    Panel4: TPanel;
    Label111: TLabel;
    RichEdit3: TRichEdit;
    StmPrzIvaComp: TcxRadioButton;
    StmPrzIvaEscl: TcxRadioButton;
    cxLabel1: TcxLabel;
    cxLabel2: TcxLabel;
    Panel5: TPanel;
    Label129: TLabel;
    RichEdit4: TRichEdit;
    StmTotIvaComp: TcxRadioButton;
    StmTotIvaEscl: TcxRadioButton;
    tvOreSOTTOCANTIERE1: TcxGridColumn;
    tvOreSOTTOCANTIERE2: TcxGridColumn;
    tvOreSOTTOCANTIERE3: TcxGridColumn;
    Inversionecodiciarticolo1: TMenuItem;
    QryDocumentoRIFDOC_TIPO: TStringField;
    QryDocumentoRIFDOC_NUM: TIntegerField;
    QryDocumentoRIFDOC_REG: TStringField;
    QryDocumentoRIFDOC_DATA: TDateTimeField;
    PanelRifDoc: TPanel;
    Label136: TLabel;
    Label137: TLabel;
    Label138: TLabel;
    dbeRifDoc_TipoDoc: TcxDBComboBox;
    dbeRifDoc_NumDoc: TcxDBTextEdit;
    dbeRifDoc_RegDoc: TcxDBComboBox;
    dbeRifDoc_DataDoc: TcxDBDateEdit;
    tvCorpoIDAPPARECCHIO: TcxGridColumn;
    QryPratApp: TIBOQuery;
    QryPratAppID: TIntegerField;
    QryPratAppCOSTRUTTORE: TStringField;
    QryPratAppMODELLO: TStringField;
    QryPratAppMATRICOLA: TStringField;
    QryPratAppUBICAZIONE: TStringField;
    QryPratAppTIPOAPPARECCHIO: TStringField;
    QryPratAppANNOCOSTRUZIONE: TIntegerField;
    QryPratAppDATAINSTALLAZIONE: TDateTimeField;
    QryPratAppDATACOLLAUDO: TDateTimeField;
    QryPratAppCOMPUTED_APPARECCHIO_FULL: TStringField;
    SourcePratApp: TDataSource;
    tvDiBaIDAPPARECCHIO: TcxGridColumn;
    tvCorpoIDOPIMPEGNO: TcxGridColumn;
    tvDiBaIDOPIMPEGNO: TcxGridColumn;
    PanelTabs: TPanel;
    Button3: TButton;
    Button4: TButton;
    Button5: TButton;
    TabControlPagineDocumento: TcxTabControl;
    PanelAllegati: TPanel;
    SplitterAllegati: TcxSplitter;
    dbeAgente: TcxDBComboBox;
    dbeAgente2: TcxDBComboBox;
    dbeAgente3: TcxDBComboBox;
    dbeAgente4: TcxDBComboBox;
    QryDocumentoRIFDOC_CORRISPNOPAG: TStringField;
    dbeRifDoc_CorrispNoPag: TcxDBImageComboBox;
    Label139: TLabel;
    Shape8: TShape;
    ComboBox1: TComboBox;
    SBEspandiPratica1: TSpeedButtonRollOver;
    cxDBDateEdit1: TcxDBDateEdit;
    cxDBDateEdit2: TcxDBDateEdit;
    RxSpeedButtonResetQuery: TSpeedButton;
    RxSpeedButtonFax: TSpeedButton;
    RxSpeedButtonVisualizza: TSpeedButton;
    RxSpeedButtonUscita: TSpeedButton;
    RxSpeedModifica: TSpeedButton;
    RxSpeedButtonNuovo: TSpeedButton;
    RxSpeedButtonElimina: TSpeedButton;
    RxSpeedButtonTrova: TSpeedButton;
    RxSpeedButtonStampa: TSpeedButton;
    RxSpeedButtonHelp: TSpeedButton;
    RxSpeedButtonMail: TSpeedButton;
    SBCalcola1: TSpeedButton;
    dbeListino: TcxDBComboBox;
    dbeMeseCompetenza: TcxDBComboBox;
    dbeTrasportoACura: TcxDBComboBox;
    dbePorto: TcxDBComboBox;
    Shape10: TShape;
    Label12: TLabel;
    Shape23: TShape;
    DBText2: TDBText;
    Label130: TLabel;
    DBText3: TDBText;
    DBText4: TDBText;
    QryDocumentoOPERATOREULTMOD_ULTMOD: TStringField;
    QryDocumentoDATAULTMOD_CREAZIONE: TDateTimeField;
    QryDocumentoDATAULTMOD_ULTMOD: TDateTimeField;
    DBEditProtocolloData: TcxDBDateEdit;
    QryDocumentoPROTOCOLLO_DATA: TDateTimeField;
    QryDocumentoRITACCCAUSALEPAGAMENTOSIGLA770S: TStringField;
    QryDocumentoBOLLOIMPORTO: TIBOFloatField;
    QryDocumentoIBAN: TStringField;
    dbeIBAN: TDBEdit;
    Label140: TLabel;
    Label141: TLabel;
    BIC: TEdit;
    Label142: TLabel;
    DBEdit27: TDBEdit;
    cbBolloVirtuale: TcxDBCheckBox;
    QryDocumentoBOLLOVIRTUALE: TStringField;
    DBEdit29: TDBEdit;
    QryDocumentoBOLLOID: TStringField;
    TabDocumentiCorrelati: TcxTabSheet;
    DocCorrClientArea: TScrollBox;
    Panel2: TPanel;
    Label144: TLabel;
    GridDocCorr: TcxGrid;
    TableViewDocCorr: TcxGridTableView;
    TableViewDocCorr_Tipo: TcxGridColumn;
    TableViewDocCorr_IDDoc: TcxGridColumn;
    TableViewDocCorr_Data: TcxGridColumn;
    TableViewDocCorr_CUP: TcxGridColumn;
    TableViewDocCorr_CIG: TcxGridColumn;
    TableViewDocCorr_NumItem: TcxGridColumn;
    TableViewDocCorr_RifNumLinea: TcxGridColumn;
    TableViewDocCorr_CodCommConv: TcxGridColumn;
    LevelDocCorr: TcxGridLevel;
    Label145: TLabel;
    Panel3: TPanel;
    Label146: TLabel;
    Label147: TLabel;
    GridDDTCorr: TcxGrid;
    TableViewDDTCorr: TcxGridTableView;
    TableViewDDTCorr_Numero: TcxGridColumn;
    TableViewDDTCorr_Data: TcxGridColumn;
    LevelDDTCorr: TcxGridLevel;
    TableViewDDTCorr_RifNumLinea: TcxGridColumn;
    Panel6: TPanel;
    Label148: TLabel;
    Label149: TLabel;
    Label150: TLabel;
    DBEdit30: TDBEdit;
    QryDocumentoDATISAL_RIFERIMENTOFASE: TStringField;
    TableViewDocCorr_ID: TcxGridColumn;
    TableViewDDTCorr_ID: TcxGridColumn;
    LabelPA_CausalePagRitenuta: TLabel;
    dbePA_CausalePagRitenuta: TcxDBLookupComboBox;
    ActionList1: TActionList;
    LabelSplitPayment: TLabel;
    ShapeSplitPayment: TShape;
    dbeSplitPayment: TDBText;
    QryDocumentoSPLITPAYMENT: TStringField;
    QryDocumentoTOTALESPLITPAYMENT: TCurrencyField;
    QryDocumentoALIQUOTAIVA1BOLLOAUTOMATICO: TStringField;
    QryDocumentoALIQUOTAIVA2BOLLOAUTOMATICO: TStringField;
    QryDocumentoALIQUOTAIVA3BOLLOAUTOMATICO: TStringField;
    QryDocumentoALIQUOTAIVA4BOLLOAUTOMATICO: TStringField;
    Caricaarticolidafile1: TMenuItem;
    tvCorpoIMPORTOCOSTOOPERA: TcxGridColumn;
    tvCorpoIMPORTOCOSTOCOMPONENTI: TcxGridColumn;
    tvDiBaIMPORTOCOSTOOPERA: TcxGridColumn;
    tvDiBaIMPORTOCOSTOCOMPONENTI: TcxGridColumn;
    tvCorpoPREZZOUNITARIOAUTOCALC: TcxGridColumn;
    tvCorpoROWTYPE: TcxGridColumn;
    tvCorpoROWPRINTPRICES: TcxGridColumn;
    tvCorpoQTAOPERAUNIT: TcxGridColumn;
    tvCorpoOPERAUNIT: TcxGridColumn;
    tvCorpoCOSTOOPERAUNIT: TcxGridColumn;
    tvCorpoCOMPONENTIUNIT: TcxGridColumn;
    tvCorpoCOSTOCOMPONENTIUNIT: TcxGridColumn;
    tvCorpoROWSECTION: TcxGridColumn;
    tvDiBaQTAOPERAUNIT: TcxGridColumn;
    tvDiBaOPERAUNIT: TcxGridColumn;
    tvDiBaCOMPONENTIUNIT: TcxGridColumn;
    tvDiBaCOSTOOPERAUNIT: TcxGridColumn;
    tvDiBaCOSTOCOMPONENTIUNIT: TcxGridColumn;
    tvDiBaPREZZOUNITARIOAUTOCALC: TcxGridColumn;
    tvDiBaROWTYPE: TcxGridColumn;
    tvDiBaROWPRINTPRICES: TcxGridColumn;
    tvDiBaROWSECTION: TcxGridColumn;
    tvCorpoIMPORTOMARGINEOPERA: TcxGridColumn;
    tvCorpoIMPORTOMARGINECOMPONENTI: TcxGridColumn;
    tvCorpoPERCMARGINEOPERA: TcxGridColumn;
    tvCorpoPERCMARGINECOMPONENTI: TcxGridColumn;
    tvDiBaPERCMARGINECOMPONENTI: TcxGridColumn;
    tvDiBaIMPORTOMARGINECOMPONENTI: TcxGridColumn;
    tvDiBaPERCMARGINEOPERA: TcxGridColumn;
    tvDiBaIMPORTOMARGINEOPERA: TcxGridColumn;
    tvCorpoIMPORTOCOSTO: TcxGridColumn;
    tvDiBaIMPORTOCOSTO: TcxGridColumn;
    WidthRighiPREZZOUNITARIOAUTOCALC: TStringField;
    WidthRighiIMPORTOCOSTO: TIBOFloatField;
    WidthRighiQTAOPERAUNIT: TIBOFloatField;
    WidthRighiOPERAUNIT: TIBOFloatField;
    WidthRighiCOSTOOPERAUNIT: TIBOFloatField;
    WidthRighiCOMPONENTIUNIT: TIBOFloatField;
    WidthRighiCOSTOCOMPONENTIUNIT: TIBOFloatField;
    WidthRighiMARGINECOMPONENTI: TIBOFloatField;
    WidthRighiMARGINEOPERA: TIBOFloatField;
    WidthRighiIMPORTOCOSTOOPERA: TIBOFloatField;
    WidthRighiIMPORTOCOSTOCOMPONENTI: TIBOFloatField;
    WidthRighiIMPORTOMARGINECOMPONENTI: TIBOFloatField;
    WidthRighiIMPORTOMARGINEOPERA: TIBOFloatField;
    WidthRighiGC_COMMESSA_QTA: TIBOFloatField;
    WidthRighiGC_COMMESSA_IMPORTOACQ: TIBOFloatField;
    WidthRighiGC_COMMESSA_IMPORTOVEND: TIBOFloatField;
    WidthRighiGC_CARICO_QTA: TIBOFloatField;
    WidthRighiGC_CARICO_IMPORTOACQ: TIBOFloatField;
    WidthRighiGC_CARICO_IMPORTOVEND: TIBOFloatField;
    WidthRighiGC_SCARICO_QTA: TIBOFloatField;
    WidthRighiGC_SCARICO_IMPORTOACQ: TIBOFloatField;
    WidthRighiGC_SCARICO_IMPORTOVEND: TIBOFloatField;
    WidthRighiGC_MONTATO_QTA: TIBOFloatField;
    WidthRighiGC_MONTATO_IMPORTOACQ: TIBOFloatField;
    WidthRighiGC_MONTATO_IMPORTOVEND: TIBOFloatField;
    WidthRighiGC_FATTURATO_QTA: TIBOFloatField;
    WidthRighiGC_FATTURATO_IMPORTOACQ: TIBOFloatField;
    WidthRighiGC_FATTURATO_IMPORTOVEND: TIBOFloatField;
    WidthRighiGC_COSTONETTOUNITARIO: TIBOFloatField;
    WidthRighiGC_COSTONETTOUNITARIO_MOD: TStringField;
    WidthRighiGC_RICARICO: TIBOFloatField;
    WidthRighiGC_RICARICO_MOD: TStringField;
    WidthRighiGC_QTA: TIBOFloatField;
    WidthRighiGC_QTA_MOD: TStringField;
    WidthRighiGC_DESCRIZIONE: TMemoField;
    WidthRighiGC_DESCRIZIONE_MOD: TStringField;
    WidthRighiGUID: TStringField;
    WidthRighiGUID_REF: TStringField;
    WidthRighiGUID_ANCESTOR: TStringField;
    WidthRighiDESTQTAEVASA: TStringField;
    WidthRighiDESTQTADAEVADERE: TStringField;
    WidthRighiCOMPUTED_QTADAEVADERE: TIBOFloatField;
    WidthRighiCOMPUTED_MAG_QTA: TIBOFloatField;
    WidthRighiCOMPUTED_MAG_QTA2: TIBOFloatField;
    WidthRighiCOMPUTED_MAG_IMP: TIBOFloatField;
    WidthRighiCOMPUTED_MAG_ORD: TIBOFloatField;
    WidthRighiCODICEARTICOLOSTM: TStringField;
    WidthRighiIDAPPARECCHIOPRAT: TIntegerField;
    WidthRighiIDOPIMPEGNO: TIntegerField;
    WidthRighiROWTYPE: TStringField;
    WidthRighiROWPRINTPRICES: TStringField;
    WidthRighiROWSECTION: TStringField;
    Panel8: TPanel;
    SBCollapseSoggetti: TSpeedButton;
    SBExpandSoggetti: TSpeedButton;
    SBFilterRowSoggetti: TSpeedButton;
    spRigoComposto: TSpeedButtonRollOver;
    acCreaRigoComposto: TAction;
    LabelBodyView: TLabel;
    cbBodyView: TcxComboBox;
    Shape1: TShape;
    EditVariazioneOpera1: TcxDBCurrencyEdit;
    EditVariazioneOpera2: TcxDBCurrencyEdit;
    EditVariazioneOpera3: TcxDBCurrencyEdit;
    EditVariazioneOpera4: TcxDBCurrencyEdit;
    EditVariazioneOpera5: TcxDBCurrencyEdit;
    Label108: TLabel;
    ButtonApplicaVariazioni: TcxButton;
    PropertiesStore: TcxPropertiesStore;
    EditVariazioneCostoOpera5: TcxDBCurrencyEdit;
    EditVariazioneCostoOpera4: TcxDBCurrencyEdit;
    EditVariazioneCostoOpera3: TcxDBCurrencyEdit;
    EditVariazioneCostoOpera2: TcxDBCurrencyEdit;
    EditVariazioneCostoOpera1: TcxDBCurrencyEdit;
    Label77: TLabel;
    Label89: TLabel;
    QryDocumentoCOSTOUNITOPERA: TIBOFloatField;
    QryDocumentoCOSTOUNITOPERA1: TIBOFloatField;
    QryDocumentoCOSTOUNITOPERA2: TIBOFloatField;
    QryDocumentoCOSTOUNITOPERA3: TIBOFloatField;
    QryDocumentoCOSTOUNITOPERA4: TIBOFloatField;
    rbMargineVariaz: TcxRadioButton;
    rbMargineVariazAssoluta: TcxRadioButton;
    StmSezFirme: TcxCheckBox;
    TabNotifiche: TcxTabSheet;
    NotificheFEClientArea: TScrollBox;
    PanelNotifiche: TPanel;
    Label90: TLabel;
    GridNotifiche: TcxGrid;
    LevelNotifiche: TcxGridLevel;
    btvNotifiche: TcxGridBandedTableView;
    btvNotificheTipo: TcxGridBandedColumn;
    btvNotificheMsgCode: TcxGridBandedColumn;
    btvNotificheMsgText: TcxGridBandedColumn;
    btvNotificheFileName: TcxGridBandedColumn;
    btvNotificheResponseDate: TcxGridBandedColumn;
    btvNotificheNotificationDate: TcxGridBandedColumn;
    btvNotificheID: TcxGridBandedColumn;
    btvNotificheMsgRAW: TcxGridBandedColumn;
    Panel9: TPanel;
    Label92: TLabel;
    Label94: TLabel;
    DBEdit31: TDBEdit;
    cxDBCheckBox3: TcxDBCheckBox;
    cxDBDateEdit3: TcxDBDateEdit;
    Label96: TLabel;
    DBEdit32: TDBEdit;
    Label97: TLabel;
    cxDBImageComboBox1: TcxDBImageComboBox;
    Label93: TLabel;
    QryDocumentoFE_ID: TStringField;
    QryDocumentoFE_STATUS: TStringField;
    QryDocumentoFE_LASTNOTIFICATION: TDateTimeField;
    QryDocumentoFE_CHECKFORNOTIFICATIONS: TStringField;
    QryDocumentoFE_NOTIFICATIONWAITDAYS: TIntegerField;
    btvNotificheDone: TcxGridBandedColumn;
    QryDocumentoTIPOPERSONA: TStringField;
    QryDocumentoFE_STATUS_EXT: TStringField;
    MemoNotifiche: TcxMemo;
    MenuXML: TPopupMenu;
    Inviafatturaelettronica1: TMenuItem;
    EsportafileXML1: TMenuItem;
    N2: TMenuItem;
    acInviaFatturaElettronica: TAction;
    acEsportaFileXML: TAction;
    PanelJollyNums: TPanel;
    LabelJollyNum1: TLabel;
    dbeJollyNum1: TDBEdit;
    QryDocumentoJOLLY_NUM_1: TIBOFloatField;
    btvNotificheHide: TcxGridBandedColumn;
    dbeStatus: TcxDBComboBox;
    QryDocumentoNAZIONESIGLA: TStringField;
    SBCalcola2: TSpeedButton;
    SBCalcola3: TSpeedButton;
    cxDBLookupComboBox1: TcxDBLookupComboBox;
    Label91: TLabel;
    cbBolloAddebita: TcxDBCheckBox;
    QryDocumentoBOLLOADDEBITAINFATTURA: TStringField;
    PopupMenuAzzeraCantiereImpianto: TPopupMenu;
    Deselezionacantiereimpianto1: TMenuItem;
    Aggiornaledescrizionidallelencoarticoli1: TMenuItem;
    Aggiornaledescrizionidallelencoarticoli2: TMenuItem;
    N10: TMenuItem;
    EsportagrigliacorpodocumentoinformatoExcel1: TMenuItem;
    StmColQtaEvasa: TcxCheckBox;
    StmColQtaDaEvadere: TcxCheckBox;
    tvOreTIPO1: TcxGridColumn;
    tvOreTIPO2: TcxGridColumn;
    tvOreTIPO3: TcxGridColumn;
    tvOreTIPO4: TcxGridColumn;
    tvOreTIPO5: TcxGridColumn;
    tvOreTIPO6: TcxGridColumn;
    dbePA_CausalePagRitenuta_Sigla: TcxDBTextEdit;
    PopupMenuAzzeraAliquotaIVA: TPopupMenu;
    AzzeraAliquotaIVA1: TMenuItem;
    dbeAbbuonoPerc: TDBEdit;
    QryDocumentoABBUONOPERC: TIBOFloatField;
    PanelAltriDatiGestionaliRighiFE: TPanel;
    Label95: TLabel;
    Shape12: TShape;
    Label101: TLabel;
    Label102: TLabel;
    Label103: TLabel;
    Label104: TLabel;
    Label105: TLabel;
    Label106: TLabel;
    dbeADG1_TipoDato: TcxDBTextEdit;
    dbeADG1_RiferimentoTesto: TcxDBTextEdit;
    dbeADG1_RiferimentoNumero: TcxDBTextEdit;
    dbeADG1_RiferimentoData: TcxDBTextEdit;
    dbeADG2_TipoDato: TcxDBTextEdit;
    dbeADG2_RiferimentoTesto: TcxDBTextEdit;
    dbeADG2_RiferimentoNumero: TcxDBTextEdit;
    dbeADG2_RiferimentoData: TcxDBTextEdit;
    QryDocumentoADG1_TIPODATO: TStringField;
    QryDocumentoADG1_RIFERIMENTOTESTO: TStringField;
    QryDocumentoADG1_RIFERIMENTONUMERO: TIBOFloatField;
    QryDocumentoADG1_RIFERIMENTODATA: TDateTimeField;
    QryDocumentoADG2_TIPODATO: TStringField;
    QryDocumentoADG2_RIFERIMENTOTESTO: TStringField;
    QryDocumentoADG2_RIFERIMENTONUMERO: TIBOFloatField;
    QryDocumentoADG2_RIFERIMENTODATA: TDateTimeField;
    tvCorpoADG1_TIPODATO: TcxGridColumn;
    tvCorpoADG1_RIFERIMENTOTESTO: TcxGridColumn;
    tvCorpoADG1_RIFERIMENTONUMERO: TcxGridColumn;
    tvCorpoADG1_RIFERIMENTODATA: TcxGridColumn;
    tvDiBaADG1_TIPODATO: TcxGridColumn;
    tvDiBaADG1_RIFERIMENTOTESTO: TcxGridColumn;
    tvDiBaADG1_RIFERIMENTONUMERO: TcxGridColumn;
    tvDiBaADG1_RIFERIMENTODATA: TcxGridColumn;
    WidthRighiADG1_TIPODATO: TStringField;
    WidthRighiADG1_RIFERIMENTOTESTO: TStringField;
    WidthRighiADG1_RIFERIMENTONUMERO: TIBOFloatField;
    WidthRighiADG1_RIFERIMENTODATA: TDateTimeField;
    Aggiungidiciturapercessionecreditodimpostaecobonus1: TMenuItem;
    PopupMenuAzzeramentoStato: TPopupMenu;
    AzzeraStato1: TMenuItem;
    LabelAbbuonoPerc: TLabel;
    LabelAbbuonoPerc2: TLabel;
    Shape14: TShape;
    QryDocumentoABBUONOSU: TStringField;
    RGAbbuono: TcxDBRadioGroup;
    PopupNascondiScontoPercentuale: TPopupMenu;
    Nascondiscontopercentuale1: TMenuItem;
    ZLB1: TZLBArchive;
    Label46: TLabel;
    DBText5: TDBText;
    Label47: TLabel;
    eAbbbuono3: TDBEdit;
    Shape15: TShape;
    AggiornairicarichiperfascedicostoTUTTIIRIGHI1: TMenuItem;
    AggiornairicarichiperfascedicostoSOLORIGHISELEZIONATI1: TMenuItem;
    AggiornairicarichiperfascedicostoCOLORIGHISELEZIONATI2: TMenuItem;
    dbeFETipoDocumento: TDBText;
    QryDocumentoFE_TIPODOCUMENTO: TStringField;
    procedure RxSpeedButtonUscitaClick(Sender: TObject);
    procedure RxSpeedModificaClick(Sender: TObject);
    procedure FormShow(Sender: TObject);
    procedure FormCreate(Sender: TObject);
    procedure RxSpeedButtonNuovoClick(Sender: TObject);
    procedure FormKeyUp(Sender: TObject; var Key: Word; Shift: TShiftState);
    procedure RxSpeedButtonVisualizzaClick(Sender: TObject);
    procedure RxSpeedButtonEliminaClick(Sender: TObject);
    procedure RxDBGrid4GetCellParams(Sender: TObject; Field: TField; AFont: TFont; var Background: TColor; Highlight: Boolean); // Personale
    procedure NuovoRigoDocumento(CodTutti, CodArt, CodBarre, CodForn, CodMag: String; Mode: TAddArtMode; Qta: Double = 0;
  RicalcoloTotali: Boolean = True);
    procedure InserisciNuovoRigoDocumento(CodArt, StmCodArt: String; CodMag: String; Mode: TAddArtMode; Qta: Double = 0; RicalcoloTotali: Boolean = True);
    procedure RxSpeedButtonNuovoMouseUp(Sender: TObject; Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
    procedure FormClose(Sender: TObject; var Action: TCloseAction);
    procedure DBEditStatoDocumentoChange(Sender: TObject);
    procedure MICopiaRighiSelezionatiClick(Sender: TObject);
    procedure MIIncollaRighiSelezionatiClick(Sender: TObject);
    procedure MICreaScadenzeClick(Sender: TObject);
    procedure MIAggiornaPrezziClick(Sender: TObject);
    procedure MenuRxDBGridCorpoDocPopup(Sender: TObject);
    procedure RxSpeedButtonStampaClick(Sender: TObject);
    procedure SBCalcolaClick(Sender: TObject);
    procedure Salvaimpostazionidocumento1Click(Sender: TObject); // Personale
    procedure CaricaLayoutDocumento;
    procedure RxSpeedButtonStampaMouseUp(Sender: TObject; Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
    procedure FloppyCONADClick(Sender: TObject);
    procedure DBEdit1Enter(Sender: TObject);
    procedure DBEdit1Exit(Sender: TObject);
    procedure MITotaleACorpoClick(Sender: TObject);
    procedure Stampa2Click(Sender: TObject);
    procedure Anteprimadistampa1Click(Sender: TObject);
    procedure RxSpeedButtonHelpClick(Sender: TObject);
    procedure CaricaRighiDocumento(DocTipo, Registro: String; DocNum: Longint; DocData: TDate);
    procedure SalvaRighiDocumento(TipoDocumento, Reg: String; NumDoc: Longint; DocData: TDate; Soggetto: Longint; AccorpaRighi: Boolean);
    procedure SalvaRighiAccorpatiInUnUnicoRigo(TipoDocumento, Registro: String; NumDoc: Longint; DocData: TDate; Soggetto, RowIdx, ProgRigo: Longint);
    procedure SalvaRigo(TipoDocumento, Registro: String; NumDoc: Longint; DocData: TDate; Soggetto, RowIdx, ProgRigo, ProgRigo2: Longint;
      DC: TcxCustomDataController);
    procedure SalvaRigoManodopera(TipoDocumento, Registro: String; NumDoc: Longint; DocData: TDate; Soggetto: Integer; CodPrat: Integer; DataPrat: String;
      RowIdx, ProgRigo, ProgRigo2: Longint; DC: TcxCustomDataController);
    procedure AssegnaAliquotaIVA(CodIVA, Row: Integer; LocDataController: TcxCustomDataController);
    procedure RicalcolaMarginePerModificaPrzVend(i: Integer; DC: TcxCustomDataController);
    procedure CalcolaPerModificaPrezzoUnitario(i: Integer; DC: TcxCustomDataController);
    procedure CalcolaPerModificaPrezzoAcquistoArticolo(i: Integer; DC: TcxCustomDataController);
    procedure CalcolaPerModificaMargine(i: Integer; DC: TcxCustomDataController);
    procedure CalcolaPerModificaPrezzoUnitarioIVACompresa(i: Integer; DC: TcxCustomDataController);
    procedure CalcolaImportoRigo(DC: TcxCustomDataController; i: Integer);
    procedure CalcolaTotali(const AForceRecalc: Boolean);
    procedure CalcolaTotaliNormale(const ACalcolaTotali: Boolean);
    procedure CalcolaTotaliConScorporoIVA(const ACalcolaTotali: Boolean);
    procedure CalcolaAbbuonoSePercentuale(const ATotaleDocumento: Double);
    procedure EsportaRigoDocFisc(TV: TcxGridTableView); // Personale
    procedure ImportaDocFisc(TipoDoc, Registro: String; NumDoc: Longint; DataDoc: TDate; AbilitaRiferimento: Integer; Inserisci: Boolean);
    procedure AggiornaPrezziDocumento(MDC: TcxCustomDataController; SoloRighiSelezionati: Boolean = False);
    procedure AggiornaRicarichiPerFasceDiCosto(const DC: TcxCustomDataController; const ASoloRighiSelezionati: Boolean);
    procedure StampaDocFisc(TipoDoc, Registro: String; NumDoc: Longint; DataDoc: TDate; StmPrevFax, Copie: Shortint; Esploso: Boolean);
    procedure EseguiStampaTxt(NomeFile: String);
    function ConvertiLineaTxt(Linea: String; RowIdx: Integer): String;
    function ElaboraComandoTxt(Comando: String; RowIdx: Integer): String;
    function RitornaCampoTxt(Comando: String): String;
    function RitornaComponente(Stringa: String): TComponent;
    function RitornaCorpoDoc(Comando: String; RowIdx: Integer): String;
    procedure CreaScadenzeDocumento;
    procedure QryDocumentoCODICECLIENTEChange(Sender: TField);
    procedure QryDocumentoCAUSALEChange(Sender: TField);
    procedure QryDocumentoCODICEDESTMERCIChange(Sender: TField);
    function CaricaDocumento(LocTipoDoc, LocRegistro: String; LocNumDoc: Longint; LocDataDoc: TDate): Boolean;
    procedure AggiornaMeseDiCompetenzaFatturazione(DocDate: TDate);
    procedure EliminaDocImportato(DocTipo, DocReg: String; DocNum: Longint; DocData: TDate);
    procedure AggiornaCondVendArticolo(CodiceArticolo: String; CodiceSoggetto: Longint; TipoDocum: String; Riga: Integer);
    procedure CambiaTipoDocumento;
    procedure RxSpeedButtonTrovaClick(Sender: TObject);
    procedure QryDocumentoDATADOCUMENTOValidate(Sender: TField);
    procedure QryDocumentoBeforePost(DataSet: TDataSet);
    procedure QryDocumentoPAGAMENTOChange(Sender: TField);
    procedure CaricaAliquotaIVADefaultDocumento;
    function RitornaEditText(Comando: String): String;
    procedure BitBtnMagazzinoClick(Sender: TObject);
    procedure BitBtnCausaleClick(Sender: TObject);
    procedure BitBtnSelezioneStatoClick(Sender: TObject);
    procedure BitBtnSubSoggClick(Sender: TObject);
    procedure BitBtnPagamentoClick(Sender: TObject);
    procedure BitBtnBancaClick(Sender: TObject);
    procedure BitBtnPratica1Click(Sender: TObject);
    procedure BitBtnPratica2Click(Sender: TObject);
    procedure BitBtnPratica3Click(Sender: TObject);
    procedure BitBtnClienteClick(Sender: TObject);
    procedure BitBtnEspandiClienteClick(Sender: TObject);
    procedure BitBtnDestinazioneMerciClick(Sender: TObject);
    procedure AggiornaLabelTipoDocumento;
    procedure DisableLabelTipoDocumento;
    procedure SBKioskConfermaDocClick(Sender: TObject);
    procedure RxSpeedButtonEliminaDragOver(Sender, Source: TObject; X, Y: Integer; State: TDragState; var Accept: Boolean);
    procedure ControllaVisualizzazioneCastellettoIVA;
    procedure tvCorpoEditValueChanged(Sender: TcxCustomGridTableView; AItem: TcxCustomGridTableItem);
    procedure tvCorpoEditing(Sender: TcxCustomGridTableView; AItem: TcxCustomGridTableItem; var AAllow: Boolean);
    procedure tvCorpoEndDrag(Sender, Target: TObject; X, Y: Integer);
    procedure tvCorpoDragOver(Sender, Source: TObject; X, Y: Integer; State: TDragState; var Accept: Boolean);
    procedure tvCorpoDragDrop(Sender, Source: TObject; X, Y: Integer);
    procedure tvCorpoDblClick(Sender: TObject);
    procedure tvCorpoKeyPress(Sender: TObject; var Key: Char);
    procedure SBAddArtClick(Sender: TObject);
    procedure AddArtChange(Sender: TObject);
    procedure ImpostaNomiTabelle;
    procedure DiBaModificaClick(Sender: TObject);
    procedure LoadDetailRows(MasterRow: Longint; MasterCodArt: String; CodMag: String);
    procedure tvCorpoCustomDrawColumnHeader(Sender: TcxGridTableView; ACanvas: TcxCanvas; AViewInfo: TcxGridColumnHeaderViewInfo; var ADone: Boolean);
    procedure CalcolaTotaliSottorighi(MDC: TcxCustomDataController; MasterRow: Integer);
    procedure GridEdit(SetEdit: Boolean);
    procedure EspandiTutto;
    procedure RefreshImpostazioniColonne;
    procedure tvCorpoColumnSizeChanged(Sender: TcxGridTableView; AColumn: TcxGridColumn);
    function ExpandedRecordCount(TV: TcxGridTableView): Integer;
    procedure tvDiBaKeyDown(Sender: TObject; var Key: Word; Shift: TShiftState);
    procedure tvCorpoSCONTORIGOCustomDrawCell(Sender: TcxCustomGridTableView; ACanvas: TcxCanvas; AViewInfo: TcxGridTableDataCellViewInfo; var ADone: Boolean);
    procedure ApplicaVariazioniMargini(MDC: TcxCustomDataController);
    procedure TBVariazioneMarginePropertiesChange(Sender: TObject);
    procedure Anteprimadistampa3Click(Sender: TObject);
    procedure Stampa3Click(Sender: TObject);
    procedure EsplodiArticoloComposto(MDC: TcxCustomDataController; MRI: Integer);
    procedure Esplodiirighiselezionati1Click(Sender: TObject);
    procedure Esplodituttiirighideldocumento1Click(Sender: TObject);
    procedure OpenPanelTotaliMargini(Open: Boolean);
    procedure AssegnaPanelTotaliMarginiAlPiedeCorrente;
    procedure SBApriChiudiTotaliMargini1Click(Sender: TObject);
    procedure tvCorpoMOVMAGCustomDrawCell(Sender: TcxCustomGridTableView; ACanvas: TcxCanvas; AViewInfo: TcxGridTableDataCellViewInfo; var ADone: Boolean);
    procedure MarcaImportExport(DC: TcxCustomDataController; RI, CI: Integer; V: String);
    procedure ControllaSeTuttiRighiImportExport;
    function NuovoRigoManodopera(CodArt: String; Mode: TAddArtMode): Boolean;
    procedure AddArtKeyPress(Sender: TObject; var Key: Char);
    procedure AddArtKeyUp(Sender: TObject; var Key: Word; Shift: TShiftState);
    function ControllaCorrispondenzaPrezzoDiAcquisto(CodArt, CodArtStm: String; NuovoPrezzoListino: Currency; Q, S1, S2, S3: Real;
      var RichiediConfermaPerProseguire: Boolean): Boolean;
    procedure ControlloSottoscortaArticolo(CodArt: String; Qt: Double; CM: Integer; SegnoOperazione: String);
    procedure QryDocumentoCODICEIVAFORZATAChange(Sender: TField);
    procedure BitBtnForzaIvaClick(Sender: TObject);
    procedure ApriPannelloIntestatario(P: TPanel);
    procedure ChiudiPannelloIntestatario(P: TPanel);
    function ControllaNumDocStessoAnno: Boolean;
    function ControllaSuccessioneNumerazione: Boolean;
    procedure Editordescrizione1Click(Sender: TObject);
    procedure BtnDescrizioneCancelClick(Sender: TObject);
    procedure BtnDescrizioneOkClick(Sender: TObject);
    procedure tvCorpoKeyDown(Sender: TObject; var Key: Word; Shift: TShiftState);
    procedure PanelDescrizioneExit(Sender: TObject);
    procedure Azzeragliscontideirighiselezionati1Click(Sender: TObject);
    procedure Azzeragliscontidituttiirighi1Click(Sender: TObject);
    procedure QryDocumentoPRATICAChange(Sender: TField);
    procedure QryDocumentoPRATICA2Change(Sender: TField);
    procedure QryDocumentoPRATICA3Change(Sender: TField);
    procedure tvCorpoFocusedItemChanged(Sender: TcxCustomGridTableView; APrevFocusedItem, AFocusedItem: TcxCustomGridTableItem);
    procedure QryDocumentoCAUSALECANTIEREChange(Sender: TField);
    procedure Convertinomearticoloinnomegruppo1Click(Sender: TObject);
    procedure QryDocumentoDATADOCUMENTOChange(Sender: TField);
    procedure QryDocumentoVALIDITAGGChange(Sender: TField);
    procedure QryDocumentoCONSEGNAGGChange(Sender: TField);
    procedure QryDocumentoVALIDITADATAChange(Sender: TField);
    procedure QryDocumentoCONSEGNADATAChange(Sender: TField);
    procedure QryDocumentoAfterEdit(DataSet: TDataSet);
    procedure QryDocumentoAfterInsert(DataSet: TDataSet);
    procedure QryDocumentoAfterPost(DataSet: TDataSet);
    procedure IMportaArticoliDaTerminaleEsterno;
    procedure ExtTermImportClick(Sender: TObject);
    procedure Selezionecumulativasottocantieri1Click(Sender: TObject);
    procedure BtnExitClick(Sender: TObject);
    procedure PanelSottocantieriCumulativiExit(Sender: TObject);
    procedure BtnOkClick(Sender: TObject);
    procedure DBEdit120KeyPress(Sender: TObject; var Key: Char);
    procedure QryDocumentoRicalcolaDocumentoEventHandler(Sender: TField);
    procedure RxSpeedButtonMailClick(Sender: TObject);
    procedure Inviadocumentonormale1Click(Sender: TObject);
    procedure Inviadocumentoconesplosionearticolicomposti1Click(Sender: TObject);
    procedure RxSpeedButtonMailMouseUp(Sender: TObject; Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
    procedure EsportaleQtinevasionenellabacheca1Click(Sender: TObject);
    procedure tvCorpoCustomDrawCell(Sender: TcxCustomGridTableView; ACanvas: TcxCanvas; AViewInfo: TcxGridTableDataCellViewInfo; var ADone: Boolean);
    procedure tvCorpoPRZUNITNETTOGetDisplayText(Sender: TcxCustomGridTableItem; ARecord: TcxCustomGridRecord; var AText: String);
    procedure QryDocumentoRITACCGetText(Sender: TField; var Text: String; DisplayText: Boolean);
    procedure SelezionecumulativaaliquotaIVA1Click(Sender: TObject);
    procedure PanelAumentoPrezziExit(Sender: TObject);
    procedure BtnAumentoExitClick(Sender: TObject);
    procedure BtnAumentoOkClick(Sender: TObject);
    procedure Aumentocumulativoprezzoarticoli1Click(Sender: TObject);
    procedure AggiornaDatiRigoForm(DS: TDataSet);
    procedure SelectIVAFocusedRow;
    procedure tvCorpoSelectionChanged(Sender: TcxCustomGridTableView);
    procedure Consideralasituazioneattualecomecostoericarica1Click(Sender: TObject);
    procedure PanelRicaricoExit(Sender: TObject);
    procedure BtnRicaricoExitClick(Sender: TObject);
    procedure BtnRicaricoOkClick(Sender: TObject);
    procedure NuovoRigoOre(CodDip: Integer; Mode: TAddArtMode);
    procedure tvOreEditValueChanged(Sender: TcxCustomGridTableView; AItem: TcxCustomGridTableItem);
    procedure tvOreEditing(Sender: TcxCustomGridTableView; AItem: TcxCustomGridTableItem; var AAllow: Boolean);
    procedure tvOreDESCRIZDIPENDENTEPropertiesButtonClick(Sender: TObject; AButtonIndex: Integer);
    function CalcolaImportoOrario(DC: TcxCustomDataController; Y: Integer): Double;
    procedure tvOreKeyDown(Sender: TObject; var Key: Word; Shift: TShiftState);
    procedure tvOreDataControllerAfterDelete(ADataController: TcxCustomDataController);
    procedure TipoDocumentoPropertiesInitPopup(Sender: TObject);
    procedure TipoDocumentoKeyPress(Sender: TObject; var Key: Char);
    procedure cxDBComboBox1PropertiesInitPopup(Sender: TObject);
    procedure QryDocumentoSEGNOOPERAZIONEChange(Sender: TField);
    procedure QryDocumentoSEGNOOPERAZIONECANTIEREChange(Sender: TField);
    procedure DbeAzioneMagazzinoPropertiesChange(Sender: TObject);
    procedure DbeAzioneCantierePropertiesChange(Sender: TObject);
    procedure EditDescrizionePratica1Change(Sender: TObject);
    procedure VisualizzaRichiestaDatiInizialiDocumento;
    procedure ImpegnoModificaClick(Sender: TObject);
    procedure FormHide(Sender: TObject);
    procedure QryDocumentoRAGSOCCLIChange(Sender: TField);
    procedure QryDocumentoNUMORDPREVChange(Sender: TField);
    procedure QryDocumentoREGISTROChange(Sender: TField);
    procedure tvCorpoStartDrag(Sender: TObject; var DragObject: TDragObject);
    procedure tvCorpoDataControllerBeforePost(ADataController: TcxCustomDataController);
    procedure TotaleacorpoSOLOdeirighiselezionati1Click(Sender: TObject);
    procedure ProcessBarcode(Barcode: String);
    procedure FormResize(Sender: TObject);
    procedure SbRifSogg1Click(Sender: TObject);
    procedure SbRifSogg2Click(Sender: TObject);
    procedure SbRifSogg3Click(Sender: TObject);
    procedure SbRifSogg4Click(Sender: TObject);
    procedure SbRifSogg5Click(Sender: TObject);
    procedure SbRifSogg6Click(Sender: TObject);
    procedure QryDocumentoRIFSOGG1_CODICEChange(Sender: TField);
    procedure QryDocumentoRIFSOGG2_CODICEChange(Sender: TField);
    procedure QryDocumentoRIFSOGG3_CODICEChange(Sender: TField);
    procedure QryDocumentoRIFSOGG4_CODICEChange(Sender: TField);
    procedure QryDocumentoRIFSOGG5_CODICEChange(Sender: TField);
    procedure QryDocumentoRIFSOGG6_CODICEChange(Sender: TField);
    procedure SBImportPalmareClick(Sender: TObject);
    procedure RichiediCantiereTouchScreen;
    procedure QryDocumentoAGENTEChange(Sender: TField);
    procedure tvOreOPERAINDEXGetDataText(Sender: TcxCustomGridTableItem; ARecordIndex: Integer; var AText: String);
    procedure SpostaManodoperaSpeseInFondo(const ASpostaOpera, ASpostaSpese: Boolean);
    procedure Button2Click(Sender: TObject);
    function LocateGUID(DC: TcxCustomDataController; GUIDToSearch: String): Boolean;
    procedure StmPrzIvaCompClick(Sender: TObject);
    procedure StmPrzIvaEsclClick(Sender: TObject);
    procedure StmTotIvaEsclClick(Sender: TObject);
    procedure MenuStampePopup(Sender: TObject);
    procedure DBEditProtocolloEnter(Sender: TObject);
    procedure DBEditProtocolloExit(Sender: TObject);
    procedure Button6Click(Sender: TObject);
    procedure QryDocumentoRITACCIMPONIBILEGetText(Sender: TField; var Text: String; DisplayText: Boolean);
    procedure QryDocumentoRITACCSUPERCIMPValidate(Sender: TField);
    procedure QryDocumentoRITACCSUIMPORTOIMPValidate(Sender: TField);
    procedure EsportaTesto1Click(Sender: TObject);
    procedure EsportaExcel1Click(Sender: TObject);
    procedure BitBtnMagazzino2Click(Sender: TObject);
    procedure Aggiornaiprezzideirighiselezionati1Click(Sender: TObject);
    procedure sbBodyNormalClick(Sender: TObject);
    procedure sbBodyHorzStretchedClick(Sender: TObject);
    procedure sbBodyFullStretchedClick(Sender: TObject);
    procedure PanelAddArtResize(Sender: TObject);
    procedure Mostralacolonnadelcodicearticoloreale1Click(Sender: TObject);
    procedure TimerDocStateTimer(Sender: TObject);
    procedure DBERagSocCliEnter(Sender: TObject);
    procedure DBERagSocCliExit(Sender: TObject);
    procedure GridCorpoEnter(Sender: TObject);
    procedure GridCorpoExit(Sender: TObject);
    procedure SBTrovaArtClick(Sender: TObject);
    procedure TrovaArtKeyUp(Sender: TObject; var Key: Word; Shift: TShiftState);
    procedure TrovaArtChange(Sender: TObject);
    procedure QryDocumentoAGENTE2Change(Sender: TField);
    procedure QryDocumentoAGENTE3Change(Sender: TField);
    procedure QryDocumentoAGENTE4Change(Sender: TField);
    procedure SbRifSogg7Click(Sender: TObject);
    procedure SbRifSogg8Click(Sender: TObject);
    procedure SbRifSogg9Click(Sender: TObject);
    procedure SbRifSogg10Click(Sender: TObject);
    procedure QryDocumentoRIFSOGG7_CODICEChange(Sender: TField);
    procedure QryDocumentoRIFSOGG8_CODICEChange(Sender: TField);
    procedure QryDocumentoRIFSOGG9_CODICEChange(Sender: TField);
    procedure QryDocumentoRIFSOGG10_CODICEChange(Sender: TField);
    procedure FormDestroy(Sender: TObject);
    procedure tvOreSOTTOCANTIERE1PropertiesInitPopup(Sender: TObject);
    procedure tvOreSOTTOCANTIERE2PropertiesInitPopup(Sender: TObject);
    procedure tvOreSOTTOCANTIERE3PropertiesInitPopup(Sender: TObject);
    procedure tvOreDataControllerDataChanged(Sender: TObject);
    procedure Inversionecodiciarticolo1Click(Sender: TObject);
    procedure dbeRifDoc_RegDocPropertiesInitPopup(Sender: TObject);
    procedure TabControlPagineDocumentoChange(Sender: TObject);
    procedure QryDocumentoAfterOpen(DataSet: TDataSet);
    procedure QryPratAppCalcFields(DataSet: TDataSet);

    procedure OP_AddOrUpdate(OP_ID: Integer; OP_Codice, OP_Descrizione: String; OP_PrzUnit, OP_PrzUnitNettoIvaComp, OP_Sconto1, OP_Sconto2, OP_Sconto3: Double;
      OP_CodiceIva, OP_IdApparecchioPrat: Integer);
    procedure OP_Delete(OP_ID: Integer);
    function OP_RifContratto_GetRecordIndex(const ACreateIsNotExists: Boolean): Integer;
    function OP_RifContrattoDicitura_GetRecordIndex(const ACreateIsNotExists: Boolean): Integer;
    procedure OP_RifContratto_Check(const AInAbbonamento, ASetImportoRinnovo: Boolean);
    procedure OP_RifContrattoDicitura_Check(const AInAbbonamento, ASetImportoRinnovo: Boolean);

    procedure dbeAgentePropertiesEditValueChanged(Sender: TObject);
    procedure dbeAgente2PropertiesEditValueChanged(Sender: TObject);
    procedure dbeAgente3PropertiesEditValueChanged(Sender: TObject);
    procedure dbeAgentePropertiesInitPopup(Sender: TObject);
    procedure dbeAgente2PropertiesInitPopup(Sender: TObject);
    procedure dbeAgente3PropertiesInitPopup(Sender: TObject);
    procedure dbeAgente4PropertiesInitPopup(Sender: TObject);
    procedure tvCorpoQTADAEVADEREGetDisplayText(Sender: TcxCustomGridTableItem; ARecord: TcxCustomGridRecord; var AText: String);
    procedure CaricaTitoli;
    procedure QryDocumentoRIFDOC_NUMChange(Sender: TField);
    procedure QryDocumentoRIFDOC_TIPOChange(Sender: TField);
    procedure SBEspandiPratica1Click(Sender: TObject);
    procedure Stampaleetichettedegliarticolideldocumento1Click(Sender: TObject);
    procedure QryDocumentoABIChange(Sender: TField);
    procedure ClientAreaPageChanging(Sender: TObject; NewPage: TcxTabSheet; var AllowChange: Boolean);
    procedure acEsportaFatturaPAUpdate(Sender: TObject);
    procedure QryDocumentoCalcFields(DataSet: TDataSet);
    procedure QryDocumentoSPLITPAYMENTChange(Sender: TField);
    procedure Caricaarticolidafile1Click(Sender: TObject);
    procedure tvCorpoCustomDrawPartBackground(Sender: TcxCustomGridTableView; ACanvas: TcxCanvas; AViewInfo: TcxCustomGridCellViewInfo; var ADone: Boolean);
    procedure tvCorpoDataControllerDetailCollapsed(ADataController: TcxCustomDataController; ARecordIndex: Integer);
    procedure tvCorpoLeftPosChanged(Sender: TObject);
    procedure tvOreCustomDrawCell(Sender: TcxCustomGridTableView; ACanvas: TcxCanvas; AViewInfo: TcxGridTableDataCellViewInfo; var ADone: Boolean);
    procedure tvOreCustomDrawColumnHeader(Sender: TcxGridTableView; ACanvas: TcxCanvas; AViewInfo: TcxGridColumnHeaderViewInfo; var ADone: Boolean);
    procedure SBCollapseSoggettiClick(Sender: TObject);
    procedure SBExpandSoggettiClick(Sender: TObject);
    procedure SBFilterRowSoggettiClick(Sender: TObject);
    procedure acCreaRigoCompostoExecute(Sender: TObject);
    procedure acCreaRigoCompostoUpdate(Sender: TObject);
    procedure cxComboBox1PropertiesChange(Sender: TObject);
    procedure tvCorpoROWSECTIONPropertiesInitPopup(Sender: TObject);
    procedure tvCorpoDataControllerNewRecord(ADataController: TcxCustomDataController; ARecordIndex: Integer);
    procedure tvCorpoDataControllerSummaryAfterSummary(ASender: TcxDataSummary);
    procedure tvCorpoTcxGridDataControllerTcxDataSummaryFooterSummaryItems0GetText(Sender: TcxDataSummaryItem; const AValue: Variant; AIsFooter: Boolean;
      var AText: string);
    procedure tvCorpoTcxGridDataControllerTcxDataSummaryFooterSummaryItems14GetText(Sender: TcxDataSummaryItem; const AValue: Variant; AIsFooter: Boolean;
      var AText: string);
    procedure tvCorpoMARGINECustomDrawFooterCell(Sender: TcxGridTableView; ACanvas: TcxCanvas; AViewInfo: TcxGridColumnHeaderViewInfo; var ADone: Boolean);
    procedure tvCorpoDataControllerBeforeInsert(ADataController: TcxCustomDataController);
    procedure tvCorpoDataControllerAfterInsert(ADataController: TcxCustomDataController);
    procedure ButtonApplicaVariazioniClick(Sender: TObject);
    procedure EditVariazioneMarginePropertiesEditValueChanged(Sender: TObject);
    procedure tvCorpoPREZZOUNITARIOGetDisplayText(Sender: TcxCustomGridTableItem; ARecord: TcxCustomGridRecord; var AText: string);
    procedure tvCorpoQTAGetDisplayText(Sender: TcxCustomGridTableItem; ARecord: TcxCustomGridRecord; var AText: string);
    procedure tvCorpoDataControllerSummaryFooterSummaryItemsSummary(ASender: TcxDataSummaryItems; Arguments: TcxSummaryEventArguments;
      var OutArguments: TcxSummaryEventOutArguments);
    procedure GridCorpoFocusedViewChanged(Sender: TcxCustomGrid; APrevFocusedView, AFocusedView: TcxCustomGridView);
    procedure DbeDescrizioneCantiereKeyPress(Sender: TObject; var Key: Char);
    procedure btvNotificheFocusedRecordChanged(Sender: TcxCustomGridTableView; APrevFocusedRecord, AFocusedRecord: TcxCustomGridRecord;
      ANewItemRecordFocusingChanged: Boolean);
    procedure acInviaFatturaElettronicaExecute(Sender: TObject);
    procedure acEsportaFileXMLExecute(Sender: TObject);
    procedure acInviaFatturaElettronicaUpdate(Sender: TObject);

    function CanSendEInvoice: Boolean;
    procedure InviaFatturaElettronica;

    procedure RxSpeedButtonFaxClick(Sender: TObject);
    procedure Button1Click(Sender: TObject);
    procedure btvNotificheHidePropertiesValidate(Sender: TObject; var DisplayValue: Variant; var ErrorText: TCaption; var Error: Boolean);
    procedure btvNotificheDonePropertiesValidate(Sender: TObject; var DisplayValue: Variant; var ErrorText: TCaption; var Error: Boolean);
    procedure cxDBImageComboBox1FocusChanged(Sender: TObject);
    procedure btvNotificheDataControllerBeforeDelete(ADataController: TcxCustomDataController; ARecordIndex: Integer);
    procedure TableViewAllegatiColumn1PropertiesButtonClick(Sender: TObject; AButtonIndex: Integer);
    procedure Deselezionacantiereimpianto1Click(Sender: TObject);
    procedure Aggiornaledescrizionidallelencoarticoli2Click(Sender: TObject);
    procedure Aggiornaledescrizionidallelencoarticoli1Click(Sender: TObject);
    procedure ClientAreaChange(Sender: TObject);
    procedure EsportagrigliacorpodocumentoinformatoExcel1Click(Sender: TObject);
    procedure dbePA_CausalePagRitenuta_SiglaKeyPress(Sender: TObject; var Key: Char);
    procedure AzzeraAliquotaIVA1Click(Sender: TObject);
    procedure DBEFOrzaIVAKeyUp(Sender: TObject; var Key: Word; Shift: TShiftState);
    procedure QryDocumentoABBUONOChange(Sender: TField);
    procedure Aggiungidiciturapercessionecreditodimpostaecobonus1Click(Sender: TObject);
    procedure tvCorpoMouseDown(Sender: TObject; Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
    procedure AzzeraStato1Click(Sender: TObject);
    procedure DBEditStatoDocumentoKeyUp(Sender: TObject; var Key: Word; Shift: TShiftState);
    procedure RGAbbuonoPropertiesChange(Sender: TObject);
    procedure Nascondiscontopercentuale1Click(Sender: TObject);
    procedure AggiornairicarichiperfascedicostoTUTTIIRIGHI1Click(Sender: TObject);
    procedure AggiornairicarichiperfascedicostoSOLORIGHISELEZIONATI1Click(Sender: TObject);
    procedure QryDocumentoFE_TIPODOCUMENTOGetText(Sender: TField; var Text: string; DisplayText: Boolean);
  private
    { Private declarations }
    fFirstCaricaLayoutDocumento: Boolean;
    fAzioniVisible: Boolean;
    fDatiPrincipaliDocumentoVisible: Boolean;
    fStartDragRowIndex: Integer;
    fSelectedDragRecordIndex: array of Integer;
    fLastPrintedPageCount: Integer;

    // Indica il livello di dettaglio per quanto riguarda le colonne che sono utili all'analisi
    // dei costi del documento
    FBodyView: TBodyView;

    // Query per il salvataggio dei righi documento
    FQrySalvaRighi: TIB_Cursor;
    FQrySalvaRighiOre: TIB_Cursor;

    // Struttura che contiene il riferimento ad un documento di cui poi si deve variare
    // ad esempio lo STATO (dopo la conferma, prima lo faceva prima) oppure il
    // RifDoc_COrrispettivoNonPagato quando il documento di provenienza
    // viene fatturato o similare.
    fImportedDocumentsArray: TImportedDocumentsArray;

    // Campo che contiene il nome del file delle preferenze senza l'estensione in modo
    // da poter usare lo stesso nome per generare sia i nomi del file compresso che normale.
    fStmPref_FileName: String;
    // Variabile che contiene il tipo di salvataggio delle preferenze di stampa
    // ed esattamente: 0=Non salva mai nulla; 1=Salva solo il parametro diverso dal default; 2=Salva sempre tutti i parametri
    fStmPref_SaveMode: Smallint;
    // Variabile che indica se stampare (di default) il documento con totali iva compresa o esclusa
    fStmPref_TotaliIvaEsclusa: Boolean;
    // Flag che indice se è attivo il calcolo dei totali documento con Scorporo dell'IVA oppure no
    fScorporoIVA: Boolean;
    // Flag che mantiene l'informazione se stampare o meno il logo nella stampa del documento
    fDefaultStampaLogoIntestazione: Boolean;
    // Flag che Disabilita le gestione dell'evento che si attiva alla variazione di un dato relativo alla ritenuta d'acconto
    fBodyScreenState: TBodyScreenState;
    // Proprietà che se messa a True fa in modo che alla prossima chiamata della procedure
    // CaricaLayoutDocumento non vengano rielaborate le impostazioni delle colonne del documento
    // in modo da velocizzare un pò l'esecuzione.
    fCaricaLayoutDocumento_NotLoadColumnSettingsNextTime: Boolean;

    // Flag che indica se, quando dei documenti vengono importati nel documento corrente dalla bacheca
    // questi vengono marcati come "Fatturati" oppure no.
    // In pratica posso decidere questa cosa o meno separatamente per la Fattura e anche per
    // l'estratto conto.
    // NB: Per la fattura è True per default mentre per l'estratto conto è False
    DocImportati_SetFatturato, DocImportati_SetStatoDopoFattura, DocImportati_SetStatoDopoEstrattoConto, DocImportati_SetCorrispNoPagChiuso: Boolean;

    // Flag che abilita o meno, alla conferma del documento, la richiesta
    // di creazione automatica delle scadenza
    fScadenzeCreazioneAutomatica, fScadenzeCreazioneAutomaticaSoloDocumento: Boolean;

    // Parametro che abilita o meno la finestrella di richiesta Qta quando si richiama un articolo
    // però separato per documento. Il parametro "RichiediQta" presente nella sezione
    // "FormAnagraficaArticoli" del layouts.ini (quindi generale per tutti i documenti) rimane come
    // interruttore generale e per le parti non facenti parte di un documento (ad es: quando si
    // esporta un articolo dall'elenco articoli alla bacheca).
    fRichiediQtaDoc: Boolean;

    // Parametro che abilita o meno la richiesta di conferma (se continuare o meno l'operazione)
    // nel caso si stia cercando di inserire un articolo che però è già presente all'interno
    // del documento.
    fConfermaNuovoRigoSeArticoloGiaPresente: Boolean;

    // Oggetto che si occupa della gestione dei totali a corpo all'interno del
    // documento
    FTotaleCorpo: ITotaleCorpo;

    // Campi privati che contengono alcuni valori precedenti che mi servono per decidere se
    // ricreare le scadenze oppure no dopo la variazione del documento stesso.
    FPrecCodicePagamento, FPrecCodiceCliente: Integer;
    FPrecTotaleDaPagare: Double;

    // =========================================================================
    // PARTE DELLA FORM ALLEGATI
    // -------------------------------------------------------------------------
    // Puntatore alla form degli Allegati relativa a questa form stessa
    fAllegatiForm: TAllegatiForm;
    procedure Allegati_AggiornaDatiFiltri;
    procedure Allegati_CreaForm;
    procedure Allegati_VerificaAbilitazione;
    // =========================================================================

    function GetQrySalvaRighi: TIB_Cursor;
    function GetQrySalvaRighiOre: TIB_Cursor;
    procedure CaricaItemsSottocantieri;
    procedure ConvertiDescArtInDescGruppo(MDC: TcxCustomDataController);
    function AggiustaQtaManodopera(Man: String): String;
    procedure ControllaCOrrispondenzaPrezzoDiAcquistoDiTuttiIRighi;
    procedure EsportaRigoSingolo(DC: TcxCustomDataController; RI: Integer; Qta: Double = -9999);
    procedure EvadiQtaInEvasioneRigo(DC: TcxCustomDataController; RI: Integer);
    procedure EvadiQtaInEvasione(DC: TcxCustomDataController; EsportaRighi: Boolean = False);
    function QtaEvasioneIsValid(Qta, QtaInEvasione, QtaEvasa: Variant): Boolean;
    procedure ImpostaStatoOrdineFornitore;
    function RigoEvaso(DC: TcxCustomDataController; RI: Integer): Boolean;
    procedure CaricaCausaliDefault;
    procedure CaricaScontoSoggetto;
    procedure ControllaNuoviArticoliDaInserire(DC: TcxCustomDataController);
    function CalcolaImportoVendRigoPerQtaEvasaODaEvadere(ImportoOriginale, QtaOriginale, QtaVoluta: Variant): Double;
    function CalcolaImportoCostoRigoPerQtaEvasaODaEvadere(CostoUnit, QtaVoluta: Variant): Double;
    procedure OpenDatiRigoForm;
    procedure CloseDatiRigoForm;
    procedure CaricaItemsSottocantieriDatiRigo;
    procedure EnableDisableDatiFormFields;
    procedure ConsideraSituazioneAttualeComeCostoERicarica(Ricarico: Double);
    procedure CreaSottorigoTemporaneo(MDC: TcxCustomDataController; Y: Integer);
    procedure CalcolaTotaliSottorighiDiBa(MDC: TcxCustomDataController; MasterRow: Integer);
    procedure CalcolaTotaliSottorighiOre(MDC: TcxCustomDataController; MasterRow: Integer; AggiornaRigoMasterAncheSeVuoto: Boolean = False);
    procedure CaricaSottorighiManodopera(DocTipo, Registro: String; DocNum: Integer; DocData: TDate; ProgRigo, MasterRowIndex: Integer;
      MDC: TcxCustomDataController);
    function SottorighiManodoperaPresenti(MDC: TcxCustomDataController; Y: Integer): Boolean;
    procedure SetAzioniVisible(const Value: Boolean);
    function GetIsImpegno: Boolean;
    procedure FormShowImpegni(Sender: TObject);
    procedure SetDatiPrincipaliDocumentoVisible(const Value: Boolean);
    procedure ReorderRows(ASourceView, ADestView: TcxGridTableView; ADestRec: TcxCustomGridRecord);
    procedure RefreshOrderValues(AView: TcxGridTableView; EseguiBeginUpdate: Boolean = True);
    procedure AggiornaDescrizioniArticoliRighiSelezionati(AView: TcxGridTableView);
    procedure TotaleACorpoRighiSelezionati(AView: TcxGridTableView);
    function RighiSelezionatiConsecutivi(AView: TcxGridTableView): Boolean;
    procedure ImportaRighiCodiceQtaDallaBacheca(TipoDoc, Registro: String; NumDoc: Integer; DataDoc: TDate; AbilitaRiferimento: Integer; Inserisci: Boolean);
    procedure ControllaAbilitazioneImportazionePalmare;
    procedure CaricaItemsTipiRighi;
    procedure CaricaItemsTipiRighiDatiRigo;
    procedure RendeTuttiPrzUnitDaLordiANetti;
    procedure CaricaDescrizioniManodopera;
    procedure AbilitaPanelloVariazioneMargine(Abilita: Boolean);
    procedure AggiornaPrzUnitVendSottorighiOpera(MDC: TcxCustomDataController; Row: Integer);
    procedure SetRowGUID(DC: TcxCustomDataController; Row: Integer);
    procedure SetOperaRowGUID(DC: TcxCustomDataController; Row: Integer);
    procedure CalcolaDimensioniClientAreaChildForm(FixedWidth: Boolean);
    procedure StmPref_LoadPreferences;
    function GetStmPref_FullPathIniFileName: String;
    function GetStmPref_IniFileName: String;
    function GetStmPref_CompressedFileName: String;
    function GetStmPref_FullPathCompressedFileName: String;
    procedure StmPref_SavePreferences;
    procedure StmPref_SetIvaCompresa(Ricalcola: Boolean = False);
    procedure StmPref_SetIvaEsclusa(Ricalcola: Boolean = False);
    function CalcolaPrezzoScontato(PrezzoLordo, Sc1, Sc2, Sc3: Variant; const AArrotonda: Boolean = True): Double;
    procedure CaricaDestinazioneMerceDaPratica(CodicePrat: Integer; DataPrat: TDateTime);
    procedure ControllaSottoscortaCantiere;
    procedure SetRitAccVisiblesFields;
    function GetCodiceMagazzinoDaSalvare(DC: TcxCustomDataController; RowIdx, ColIdx: Longint; CampoTestata: TField): Variant;
    procedure SetBodyScreenState(const Value: TBodyScreenState);
    procedure GestVerDoc_ChiediConferma;
    function GestVerDoc_NextRegistro: String;
    procedure ApriQueryApparecchiPratica;
    function OP_FindByOpApparecchio(DC: TcxCustomDataController; OP_ID: Integer): Integer;
    procedure VisualizzaEditorViaggio;
    procedure ImportedDocuments_Add(var ImportedArray: TImportedDocumentsArray; TipoDoc: String; NumDoc: Longint; RegDoc: String; DataDoc: TDate;
      RifDoc_CorrispNoPag: String = 'F');
    procedure ImportedDocuments_Reset(var ImportedArray: TImportedDocumentsArray);
    function Controlla_RifDocNumStessoAnno_GiaUsato: Boolean;
    procedure ImportedDocuments_SetMarkersAfterImported;
    procedure CaricaNotificheFE;
    procedure CaricaDocumentiCorrelatiPA;
    procedure SalvaDocumentiCorrelatiPA(const TipoDocumento, Reg: String; const NumDoc: Longint; const DocData: TDate);
    procedure SpostaFocus;
    procedure ControllaVisualizzazioneSplitPayment(const ARicalcola: Boolean);
    function CalcolaBollo(var TempTotal1: Double; var TempTotal2: Double; var TempTotal3: Double; var TempTotal4: Double): Double;
    procedure CalcolaSpese(var TempTotal1, TempTotal2, TempTotal3, TempTotal4: Double);
    procedure ImportaArticoliDaFileTxt;
    function ArticoloGiaPresente(const ACodArt, ADescrizione: String): Boolean;
    procedure SetBodyView(const Value: TBodyView);
    procedure CheckForDefaulRowSection(ADataController: TcxCustomDataController; ARecordIndex: Integer);
    function IsPrzUnitAutocalc(const DC: TcxCustomDataController; const RI: Integer): Boolean;
    procedure ControlloBeniSignificativi(const DC: TcxCustomDataController);
    procedure CheckForDefaultIvaAndMag(ADataController: TcxCustomDataController; ARecordIndex: Integer);
    function CreazioneAggiornamentoScadenzeDocumento: Boolean;
//    function GetRDAFromImpegni: String;  // NB: HO lasciato anche il codice commentato
    function CalcolaQtaDaEvadere(const DC: TcxCustomDataController; const ARecIdx: Integer): Double;
  public
    { Public declarations }
    DocIvaDefault: TDocIVADefault;
    // Flag che indica se le preferenze di stampa sono abilitate oppure no
    fStmPref_Enabled: Boolean;
    // Queste contengono i riferimenti al record da visualizzare/editare
    TipoDoc, Registro, PrecCellValue: String;
    NumeroDoc: Longint;
    DataDoc: TDate;
    // Parametro che indica se, quando vengono importati dei righi di altri documenti, deve essere
    // generata automaticamente la riga di riferimento al documento dal quale i righi procengono oppure no
    // NB: 0=Riferimento disabilitato; 1=Riferimento abilitato ma se c'è un riferimento a un documento secondario
    // (es: Ricevute fiscali negli interventi, vedi campi RifDoc_XXX) mette solo il riferimento al documento
    // secondario (solo Ric.Fisc. non dell'intervento); 2=Riferimento abilitato e se c'è anche un riferimento
    // a un documento secondario (vedi sopra) li mette entrambi (sia rif. all'intervento che alla Ric.Fisc)
    RifEnabled: Integer;
    // Flag che quando a True abilita la conversione automatica delle descrizioni degli articoli
    // nella descrizione del gruppo di appartenenza dell'articolo al salvataggio del documento.
    AbilitaConversioneDescArtToDescGruppo: Boolean;
    // Flag che quando a True abilita l'accorpamento automatico al salvataggio del documento
    // C'è anche una variabile numerico che indica il tipo di raggruppamento secondo questo schema
    // 0 = Accorpamento righi disabilitato
    // 1 = Accorpamento righi che controlla tutti i campi del rigo documento e somma della Qtà dei righi assolutamente identici
    // 2 = Accorpamento righi che controlla solo il codice e la descrizione e somma gli importi del rigo e Qtà sempre = 1
    AbilitaAccorpamentoRighi: Boolean;
    TipoAccorpamentoRighi: Byte;
    // Se 'True' quando si crea un nuovo documento pone il focus direttamente sulla ragione sociale del destinatario
    FocusDestinatario: Boolean;
    // Varianile che contiene il nome del controllo che possiede il focus
    ActiveControlName: String;
    // Flag che indica se si tratta di una DistintaBase
    DistintaBase: Boolean;
    // Variabili che contengono i nome delle tabelle del documento
    TestateTable, RighiTable: String;
    // Variabile che contiene il ModalResult da assegnare per la conferma o meno del documento
    // senza che venga richiesto all'utente.
    ModalResultConferma: TModalResult;
    // Variabile che contiene il ModFileMode che determina, se è abilitata la gestione delle versioni multiple di
    // uno stesso documento, se il documento deve essere salvato sovrascrivendo, come nuova versione, come nuovo documento ecc.
    GestVerDoc_Mode: TModFileMode;
    // Variabile che contiene il ModalResult per l'esecuzione o meno della movimentazione
    // di magazzino quando il documento è in Check-In
    ModalResultMovMag: TModalResult;
    // Variabile che contiene il ModalResult per la creazione o meno delle scadenze
    // quando il documento è in Check-In
    ModalResultCreaScad: TModalResult;
    // Flag che indica se il documento è a sola lettora (non modificabile) oppure no.
    SolaLettura: Boolean;
    // Array che contiene il valore che indica, per ogni rigo, di quanto la banda stessa è stata espansa
    // per via di una descrizione lunga. Questo serve per poter poi adeguare l'altezza degli shape
    // del rigo  per la lettura facilitata e le righe verticali di separazione tra i campi.
    RowsExpanded: array of Extended;
    // Parametri relativi alla funione di aggiornamento automatica dei prezzi di acquisto per quanto
    // riguarda i soli documenti di ingresso/acquisto.
    AggiornamentoAutomaticoPrezziDiAcquisto: Boolean;
    RichiediConfermaAggiornamentoAutomaticoPrezziDiAcquisto: Boolean;
    // Parametro che abilita o disabilita la creazione automatica degli articoli (nell'anagrafica articoli)
    // nel caso in cui nel docuemnto siano presenti articoli che invece non sono già codificati nel listino.
    FCaricamentoAutomaticoNuoviArticoli: Boolean;
    // Abilita/disabilita il controllo sul sottoscorta del cantiere
    VerificaSottoscortaCantiere: Boolean;
    // Flag che abilita o disabilita per il tipo di documento l'addebito delle spese
    CaricaSpeseIncasso: Boolean;
    // Flag che indica se la numerazione automatica è abilitata per questo tipo
    // di documento oppure no.
    NumerazioneAutomatica: Boolean;
    // Parametro che indica se la "progressione" del numero documento rispetto alla data deve
    //  essere garantita (quindi blocca nel caso) oppure no (quindi avverte ma non blocca)
    fGarantisciProgressioneNumDoc: boolean;
    // Sconto presente nell'anagrafica soggetto
    ScontoSoggetto: Double;
    // Conferma solo se c'è un soggetto del documento
    ConfermaDocSoloConSoggettoSelezionato: Boolean;
    // Conferma solo se appartenente ad una pratica
    ConfermaDocSoloConPraticaSelezionata: Boolean;
    // Conferma solo se il soggetto del documento è lo stesso della pratica di cui il documento fa parte
    ConfermaDocSoloSeStessoSoggettoDocEPratica: Boolean;
    // Conferma solo se c'è una stato selezionato sul documento
    ConfermaDocSoloConStatoSelezionato: Boolean;
    // Destinazioni delle colonne QTAEVASA e QTADAEVADERE rispetto a Magazzino e Cantiere
    DestMagQtaEvasa, DestMagQtaDaEvadere, DestGCQtaEvasa, DestGCQtaDaEvadere: String;
    // Struttura che contiene i dati per la conversione delle misure usate per fare in modo
    // che il piede del documento, quando il documento è stampato nella modalità con il piede
    // solo sull'ultima pagina, sia allineato al fondo della pagina.
    ConvDataPerPiedeUltimaPagina: TConvDataPerPiedeUltimaPagina;
    // Stampa castelletto IVA
    fStampaCastellettoIVA: Boolean;
    // Flag che abilita o disabilita l'evidenziazione dei righi con possibile dimenticanza, da parte
    // dell'utente, della Qtà oppure del Prezzo
    EvidenziaRighiSenzaQtaPrzUnit: Boolean;
    // Flag che abilita o meno la modalità di funzionamento degli sconti dei righi al contrario
    // (Fatto per la Geotek per gestire le percentuali di avanzamento del cantiere)
    fScontiAlContrario: Boolean;
    // Flag che decide se inserire o meno la ragione sociale dell'intestatario del documento origine
    // nei righi di riferimento quando si importa un docuemnto dalla bacheca.
    // NB: Ora anche per la descrizione della pratica/impianto
    FAbilitaNumInterventoRiferimento, FAbilitaDataInterventoRiferimento, fAbilitaRagSocRiferimento, fRagSocRIferimentoSoloDocAcq, fAbilitaPraticaRiferimento: Boolean;

    // Flag che viene meso a True quando si modificano i dati di un rigo dal pannello laterale
    // in modo da disabilitare il ricalcolo automatico dei totali e altro quando si modifica
    // una campo sempre dal pannello laterale quando ci sono molto righi selezionati.
    // Prima ci metteva una vita.
    fModificandoDaDatiRigoForm: Boolean;

    // Flag che indica se è abilita la gestione delle versioni multiple di uno stesso documento
    // utilizzando il campo Registro come numero di versione
    AbilitaGestioneVersioniDocumento: Boolean;

    // Flag che abilita l'assegnazione automatica del protocollo alle fatture di acquisto
    ProtocolloAutomatico, ProtocolloAutomatico_Data: Boolean;
    ProtocolloAutomatico_DataRiferimento_FieldName: String;

    // Flag che abilita o meno l'aggiunta dell'anno al numero del documento in fase di stampa
    // (es: Fature 125/2013-)
    fNumDocUnivoco_ProgressivoInfinito: Boolean;

    // Discorso dei beni significativi e non significativi automatico
    fCalcoloTotaliAutomatico, fCalcoloTotaliACorpoAutomatico, fCalcoloBeniSignificativiAutomatico: Boolean;
    fRaggruppamentoSezioni: Boolean;

    // Campo che indica il tipo di chiusra del documento
    fChiusuraTipo: Byte;

    // Abilita o meno la gestione dello SplitPayment per tipo di documento
    FSplitPayment: Boolean;

    // Flag che sospende TEMPORANEAMENTE il calcolo dei totali del documento
    FSospendiCalcoloTotali: Boolean;

    // Péroprieta che indica se è visualizzato o meno il pannellino delle zioni documento
    property AzioniVisible: Boolean read fAzioniVisible write SetAzioniVisible;
    // Proprietà che indica se il documento attuale fa parte di un impegno oppure no
    property IsImpegno: Boolean read GetIsImpegno;
    // Proprietà che determina se i dati del documento (Tipo, NUm, Data e Cantiere) sono visibili o meno
    property DatiPrincipaliDocumentoVisible: Boolean read fDatiPrincipaliDocumentoVisible write SetDatiPrincipaliDocumentoVisible;
    // Proprietà che contiene il nomero totale di pagine dell'ultimo documento stampato
    // NB: Lo uso per poter indicare la pagine sul documento nella forma 1/3
    property LastPrintedPageCount: Integer read fLastPrintedPageCount write fLastPrintedPageCount;
    // Serie di proprietà per il funzionamento del sistema di gestione delle preferenze di stampa
    property StmPref_IniFileName: String read GetStmPref_IniFileName;
    property StmPref_FullPathIniFileName: String read GetStmPref_FullPathIniFileName;
    property StmPref_CompressedFileName: String read GetStmPref_CompressedFileName;
    property StmPref_FullPathCompressedFileName: String read GetStmPref_FullPathCompressedFileName;
    // Proprietà che indica in quale stato di visualizzazione di trova il corpo documento
    property BodyScreenState: TBodyScreenState read fBodyScreenState write SetBodyScreenState;
    // Proprietà che se messa a True fa in modo che alla prossima chiamata della procedure
    // CaricaLayoutDocumento non vengano rielaborate le impostazioni delle colonne del documento
    // in modo da velocizzare un pò l'esecuzione.
    property CaricaLayoutDocumento_NotLoadColumnSettingsNextTime: Boolean read fCaricaLayoutDocumento_NotLoadColumnSettingsNextTime
      write fCaricaLayoutDocumento_NotLoadColumnSettingsNextTime;
    // Proprietà che espone la FormAllegati del documento
    property AllegatiForm: TAllegatiForm read fAllegatiForm;
    // Indica il livello di dettaglio per quanto riguarda le colonne che sono utili all'analisi
    // dei costi del documento
    property BodyView: TBodyView read FBodyView write SetBodyView;

    // Procedure e funzioni
    procedure StmPref_Initialize;
    function ControllaProtocolloDocStessoAnno(ProtNum: Integer): Boolean;
    procedure AggiungiRigoRiferimentoSemplice(TipoDoc, Registro: String; NumDoc: Integer; DataDoc: TDate);
    function CodiceCIGPresente: Boolean;
    function IsSplitPayment: Boolean;
    procedure BeginUpdate;
    procedure EndUpdate;
  end;

var
  PreventiviOrdiniForm: TPreventiviOrdiniForm;

implementation

uses SchedaArticoli1, main,
  PreventiviOrdiniReport,
  FormAnagArt,
  QRRicevuteFiscali, FormHelp,
  FormSubSogg, FormAliquoteIVA, FormAnagMaga, FormCausali,
  FormArchivioBanche, FormPagamenti, SchedaClienti, FormDatiRigo,
  FormDipendenti, FormBeforeNewDoc, FormImpegni, ExtTerm_Zebex_Z2031,
  FormVendBancoSeleCant, FormTedoldi, DataModule2, FatturaPA_DM,
  System.Math, UnitTotaleACorpo, UnitTotaleACorpo.Factory, dxCore, IB_Session,
  DForce.ei.Encoding, USNCONTROLLO_CF_PI, DForce.ei.Utils.Sanitizer, DForce.Mini.ei.Invoice.Interfaces,
  DForce.Mini.ei.Invoice.Factory, cxGridExportLink, FormConfirm;

{$R *.DFM}

// =============================================================================
// INIZIO PARTE PER GESTIONE DEGLI ALLEGATI
// -----------------------------------------------------------------------------
// Procedure che crea la form degli allegati se questa non esiste già e la
// apre, alla fine esegue l'interrogazione per mostrare gli allegati.
procedure TPreventiviOrdiniForm.Allegati_CreaForm;
begin
  // Se la form degli allegati non è stata ancora creata la crea.
  if not Assigned(fAllegatiForm) then
  begin
    // Crea la form degli allegati
    fAllegatiForm := MainForm.Allegati_CreaForm(PanelAllegati);
    // Passa lo Splitter alla finestra degli allegati
    fAllegatiForm.Splitter := SplitterAllegati;
    // Se il documento attuale è un intervento e la parte appuntamento è già stata creata e anche
    // la rispettiva FormALlegati è stata creata la linka alla presente.
    if Self.IsImpegno and (ImpegnoForm <> nil) and (ImpegnoForm.AllegatiForm <> nil) then
    begin
      AllegatiForm.LinkedAllegatiForm := ImpegnoForm.AllegatiForm;
    end;
  end;
  // Imposta i filtri
  Allegati_AggiornaDatiFiltri;
end;

// Procedure che aggiorna i filtri di collegamento della form degli allegati
// con la form attuale
procedure TPreventiviOrdiniForm.Allegati_AggiornaDatiFiltri;
begin
  // Ovviamente se la form degli allegati è chiusa esce subito
  if fAllegatiForm = nil then
    Exit;

  // Azzeramento filtri
  fAllegatiForm.AzzeraFiltri;

  // Codice soggetto
  if not QryDocumentoCODICECLIENTE.IsNull then
    fAllegatiForm.Filter_CodSogg := QryDocumentoCODICECLIENTE.Value;

  // Codice Pratica
  if not QryDocumentoPRATICA.IsNull then
    fAllegatiForm.Filter_CodPrat := QryDocumentoPRATICA.Value;
  // Data Pratica
  if not QryDocumentoDATAPRATICA1.IsNull then
    fAllegatiForm.Filter_DataPrat := QryDocumentoDATAPRATICA1.Value;

  // Tipo Documento
  if not QryDocumentoTIPODOCUMENTO.IsNull then
    fAllegatiForm.Filter_TipoDoc := QryDocumentoTIPODOCUMENTO.Value;
  // Registro Documento
  if not QryDocumentoREGISTRO.IsNull then
    fAllegatiForm.Filter_RegDoc := QryDocumentoREGISTRO.Value;
  // Numero documento
  if not QryDocumentoNUMORDPREV.IsNull then
    fAllegatiForm.Filter_NumDoc := QryDocumentoNUMORDPREV.Value;
  // Data documento
  // NB: Se è un Intervento non usa la data perchè è un caso particolare
  if (not QryDocumentoDATADOCUMENTO.IsNull) and (fAllegatiForm.Filter_TipoDoc <> 'Intervento') then
    fAllegatiForm.Filter_DataDoc := QryDocumentoDATADOCUMENTO.Value;

  // Imposta i filtri
  fAllegatiForm.ImpostaFiltri;

  // Effettua l'interrogazione
  fAllegatiForm.EseguiQuery;
end;

// Procedure che determina se la form degli allegati debba essere aperta oppure no e inoltre
// determina anche se l'utente ha la possibilità di aprirla manualmente oppure no.
procedure TPreventiviOrdiniForm.Allegati_VerificaAbilitazione;
begin
  // Se siamo in un inserimento ex-novo di un nuovo documento e il dataset del documento
  // stesso è in stato dsInsert non rende ne visibile ne apribile la form degli allegati
  // perchè abbiamo scelto che non si possono inserire allegati in documento in fase
  // di creazione finchè non è stato confermato almeno la prima volta.
  if (QryDocumento.State = dsInsert) then
  begin
    SplitterAllegati.CloseSplitter;
    SplitterAllegati.Enabled := False;
  end
  else
  begin
    Allegati_CreaForm;
    SplitterAllegati.Enabled := True;
  end;
end;

// -----------------------------------------------------------------------------
// FINE PARTE PER GESTIONE DEGLI ALLEGATI
// =============================================================================








// =============================================================================
// INIZIO PARTE PER GESTIONE DELLE VERIONI MULTIPLE DI UNO STESSO DOCUMENTO
// -----------------------------------------------------------------------------

// Funzione che ritorna il prossimo registro disponibile secondo il formato e le regole
// utilizzate nella gestione delle versioni multiple di uno stesso documento
function TPreventiviOrdiniForm.GestVerDoc_NextRegistro: String;
var
  ParteAnno: String;
  ParteProgressiva: String;
  Q: TIB_Cursor;
begin
  // Inizializzazione
  Result := 'Error';
  // Se il registro attuale è nullo significa che è un nuovo documento e quindi la parte
  // anno la prendo dalla data del documento stesso, altrimenti la prendo dal
  // registro presente.
  if QryDocumentoREGISTRO.IsNull or (QryDocumentoREGISTRO.AsString = '') then
    ParteAnno := FormatDateTime('yy', QryDocumentoDATADOCUMENTO.AsDateTime) + '.'
  else
    ParteAnno := LeftStr(QryDocumentoREGISTRO.AsString, 2) + '.';
  // Per la parte progressiva del registro (la versione del documento) esegue una query
  // per determinare l'ultimo progressivo utilizzato e gli aggiunge 1.
  Q := TIB_Cursor.Create(Self);
  try
    Q.DatabaseName := DM1.ArcDBFile;
    Q.IB_Connection := DM1.DBAzienda;
    Q.SQL.Add('SELECT FIRST 1 REGISTRO FROM PRVORDCL WHERE');
    Q.SQL.Add('     TIPODOCUMENTO = ' + QuotedStr(QryDocumentoTIPODOCUMENTO.AsString));
    Q.SQL.Add(' AND REGISTRO LIKE ' + QuotedStr(ParteAnno + '%'));
    Q.SQL.Add(' AND NUMORDPREV = ' + QryDocumentoNUMORDPREV.AsString);
    Q.SQL.Add('ORDER BY REGISTRO DESC');
    Q.Open;
    if Q.Eof or (Length(Q.Fields[0].AsString) <> 5) then
    begin
      ParteProgressiva := '01';
    end
    else
    begin
      ParteProgressiva := RightStr(Q.Fields[0].AsString, 2);
      ParteProgressiva := IntToStr(StrToInt(ParteProgressiva) + 1);
      if Length(ParteProgressiva) = 1 then
        ParteProgressiva := '0' + ParteProgressiva;
    end;
    Q.Close;
    // Costruisce il risultato da ritornare
    Result := ParteAnno + ParteProgressiva;
  finally
    Q.Free;
  end;
end;

// Procedura che richiede all'utente se vuole salvare il documenco come documento ex novo, oppure come una nuova versione
// dello stesso documento, oppure sovrascrivere oppure anullare le ultime variazioni.
// NB: SOLO CON  GESTIONE DELLE VERSIONI MULTIPLE DELLO STESSO DOCUMENTO ABILITATA
procedure TPreventiviOrdiniForm.GestVerDoc_ChiediConferma;
begin
  // INizializzazione
  GestVerDoc_Mode := mfNone;
  ModalResultConferma := mrNone;
  // Se il numero documento è nullo significa che si tratta di un documento
  // ex-novo e quindi non chiede nulla
  if QryDocumentoNUMORDPREV.IsNull then
  begin
    QryDocumentoREGISTRO.Clear;
    GestVerDoc_Mode := mfNuovoProtocollo;
    Exit;
  end;
  // Apre la form che chiede cosa fare
  // Crea la form per chiedere cosa fare
  Application.CreateForm(TFileAllegatoModificatoForm, FileAllegatoModificatoForm);
  try
    FileAllegatoModificatoForm.Titolo := 'Conferma documento,';
    FileAllegatoModificatoForm.Sottotitolo := 'cosa vuoi che faccia?';
    FileAllegatoModificatoForm.TitoloButtonSostituisci := 'Sostituisci   (stesso numero e versione)';
    FileAllegatoModificatoForm.SottotitoloButtonSostituisci := 'Il nuovo documento sostituirà il vecchio che andrà perduto.';
    FileAllegatoModificatoForm.TitoloButtonNuovaVersione := 'Salva come nuova versione dello stesso documento';
    FileAllegatoModificatoForm.SottotitoloButtonNuovaVersione := 'Mantiene il vecchio e il nuovo come versioni diverse dello stesso documento.';
    FileAllegatoModificatoForm.TitoloButtonNuovo := 'Salva come nuovo documento';
    FileAllegatoModificatoForm.SottotitoloButtonNuovo := 'Lo considera un documento ex-novo indipendente dal precedente.';
    FileAllegatoModificatoForm.TitoloButtonAnnulla := 'Non salvare';
    FileAllegatoModificatoForm.SottotitoloButtonAnnulla := 'Mantiene il vecchio, le nuove modifiche andranno perdute.';
    // Visualizza la form
    FileAllegatoModificatoForm.ShowModal;
    // Assegna la scelta dell'utente
    GestVerDoc_Mode := FileAllegatoModificatoForm.Risultato;
    // IN base alla scelta imposta anche il ModalResultConferma
    if GestVerDoc_Mode = mfNonSalvare then
      ModalResultConferma := mrNo
    else
      ModalResultConferma := mrYes;
  finally
    FreeAndNil(FileAllegatoModificatoForm);
  end;
end;
// -----------------------------------------------------------------------------
// FINE PARTE PER GESTIONE DELLE VERIONI MULTIPLE DI UNO STESSO DOCUMENTO
// =============================================================================

// Procedura che carica i campi relativi alla destinazione della merce con i dati
// dell'ubicazione immobile del cantiere
procedure TPreventiviOrdiniForm.CaricaDestinazioneMerceDaPratica(CodicePrat: Integer; DataPrat: TDateTime);
var
  Q: TIB_Cursor;
begin
  // Inizializzazione
  Q := TIB_Cursor.Create(Self);
  try
    Q.DatabaseName := DM1.ArcDBFile;
    Q.IB_Connection := DM1.DBAzienda;
    Q.SQL.Add('SELECT FIRST 1 TIPO, NOME, DESCRIZIONE, IMMOBCODICE, IMMOBINDIRIZZO, IMMOBNUMCIVICO, IMMOBCAP, IMMOBLOCALITA, IMMOBPROVINCIA,');
    Q.SQL.Add('  RAGSOCIMM, COMUNEIMM, PROVINCIAIMM, INDIRIZZOIMM, NUMCIVICOIMM, CAPIMM');
    Q.SQL.Add('FROM PRATICHE WHERE CODICE = ' + IntToStr(CodicePrat) + ' AND DATAAPERTURA = ' + QuotedStr(FormatDateTime('mm/dd/yyyy', DataPrat)));
    Q.Open;
    if not Q.Eof then
    begin
      // Se si tratta di un impianto/contratto...
      if Q.FieldByName('TIPO').AsString = 'A' then
      begin
        QryDocumentoRAGSOCDESTMERCI.Value := Q.FieldByName('RAGSOCIMM').AsString;;
        QryDocumentoINDIRIZZODESTMERCI.Value := LeftStr(Q.FieldByName('INDIRIZZOIMM').AsString, 40);
        QryDocumentoNUMCIVICODESTMERCI.Value := Q.FieldByName('NUMCIVICOIMM').AsString;
        QryDocumentoCAPDESTMERCI.Value := Q.FieldByName('CAPIMM').AsString;
        QryDocumentoCITTADESTMERCI.Value := Q.FieldByName('COMUNEIMM').AsString;
        QryDocumentoPROVINCIADESTMERCI.Value := Q.FieldByName('PROVINCIAIMM').AsString;
        // Se si tratta di un cantiere...
      end
      else
      begin
        if not Q.FieldByName('IMMOBCODICE').IsNull then
          QryDocumentoCODICEDESTMERCI.Value := Q.FieldByName('IMMOBCODICE').AsInteger;
        QryDocumentoRAGSOCDESTMERCI.Value := Q.FieldByName('NOME').AsString;;
        QryDocumentoINDIRIZZODESTMERCI.Value := Q.FieldByName('IMMOBINDIRIZZO').AsString;
        QryDocumentoNUMCIVICODESTMERCI.Value := Q.FieldByName('IMMOBNUMCIVICO').AsString;
        QryDocumentoCAPDESTMERCI.Value := Q.FieldByName('IMMOBCAP').AsString;
        QryDocumentoCITTADESTMERCI.Value := Q.FieldByName('IMMOBLOCALITA').AsString;
        QryDocumentoPROVINCIADESTMERCI.Value := Q.FieldByName('IMMOBPROVINCIA').AsString;
      end;
    end;
    Q.Close;
  finally
    Q.Free;
  end;
end;

// Procedura che imposta il documento per essere con prezzi IVA compresa oppure
// IVA esclusa in base a quanto selezionato e imposta di conseguenza anche
// il flag dello scorporo dell'IVA
procedure TPreventiviOrdiniForm.StmPref_SetIvaCompresa(Ricalcola: Boolean = False);
begin
  if StmPrzIvaComp.Checked then
  begin
    // Inizializzazione
    tvCorpoPREZZOUNITARIO.Visible := False;
    tvCorpoPRZUNITNETTO.Visible := False;
    tvCorpoIMPORTORIGO.Visible := False;
    // Rende visibili le colonne opportune
    // Rende visibili le colonne opportune
    // NB: Nelle righe sottostanti ho aggiunto le parti " or (tvCorpoPREZZOUNITARIO.Tag > 0)" perchè
    // altrimenti nei documenti in cui i prezzi e gli importi sui righi erano visibili solo a video
    // e non in stampa (D.D.T. e Bolle di entrata) questi non venivano più visualizzati nemmeno
    // a video.
    tvCorpoPREZZOUNITARIOIVACOMPRESA.Visible := StmColPrezzoUnitario.Checked or (tvCorpoPREZZOUNITARIOIVACOMPRESA.Tag > 0);
    tvCorpoIMPORTORIGOIVACOMPRESA.Visible := StmColImporto.Checked or (tvCorpoIMPORTORIGOIVACOMPRESA.Tag > 0);
    // Imposta anche il calcolo dell'IVA mediante scorporo
    DM1.ScorporoIVA := True;
    // Se ho scelto di stampare gli importi dei righi IVA compresa sicuramente
    // voglio anche i totali iva compresa (non ha senso il contrario).
    StmTotIvaComp.Checked := True;
    StmTotIvaComp.Enabled := False;
    StmTotIvaEscl.Enabled := False;
    // Ricalcola i totali
    if QryDocumento.State <> dsBrowse then
      CalcolaTotali(Ricalcola);
  end;
end;

procedure TPreventiviOrdiniForm.StmPref_SetIvaEsclusa(Ricalcola: Boolean = False);
begin
  if StmPrzIvaEscl.Checked then
  begin
    // Inizializzazione
    tvCorpoPREZZOUNITARIOIVACOMPRESA.Visible := False;
    tvCorpoIMPORTORIGOIVACOMPRESA.Visible := False;
    // Rende visibili le colonne opportune
    // NB: Nelle righe sottostanti ho aggiunto le parti " or (tvCorpoPREZZOUNITARIO.Tag > 0)" perchè
    // altrimenti nei documenti in cui i prezzi e gli importi sui righi erano visibili solo a video
    // e non in stampa (D.D.T. e Bolle di entrata) questi non venivano più visualizzati nemmeno
    // a video.
    tvCorpoPREZZOUNITARIO.Visible := StmColPrezzoUnitario.Checked or (tvCorpoPREZZOUNITARIO.Tag > 0);
    tvCorpoIMPORTORIGO.Visible := StmColImporto.Checked or (tvCorpoIMPORTORIGO.Tag > 0);
    tvCorpoPRZUNITNETTO.Visible := StmColPrezzoUnitario.Checked and (tvCorpoPRZUNITNETTO.Tag > 0);
    // Imposta anche il calcolo dell'IVA mediante scorporo
    DM1.ScorporoIVA := False;
    // Se ho scelto di stampare gli importi dei righi IVA esclusa invece devo
    // dare la possibilità di scelta se voglio i totali IVA compresa o esclusa
    // NB: Però devo abilitare questa possibilità solo se i totali del documento
    // sono di tipo PiedeTipo = 3 (quello del preventivo) perchè sarebbe
    // troppo pericoloso dare questa possibilità negli altri piedi che sono
    // utilizzati nei documenti ficali.
    if PanelPiede3.Visible then
    begin
      StmTotIvaComp.Enabled := True;
      StmTotIvaEscl.Enabled := True;
    end;
    // Ricalcola i totali
    if QryDocumento.State <> dsBrowse then
      CalcolaTotali(Ricalcola);
  end;
end;

// Procedura che effettua il salvataggio delle preferenze di stampa all'interno
// del documento stesso.
procedure TPreventiviOrdiniForm.StmPref_SavePreferences;
var
  All: Boolean;
  P: TMemIniFile;
  IniFileEmpty: Boolean;
  i: Integer;
  Sez: String;
begin
  // Se il sistema delle preferenze di stampa è disabilitato oppure
  // se è disabilitato il salvataggio delle preferenze stesse ovviamente
  // esce subito.
  if (not fStmPref_Enabled) or (fStmPref_SaveMode = STMPREF_SAVEMODE_NONE) then
    Exit;
  // Per comodità uso questo flag che è impostato a True se è abilitato il salvataggio totale
  All := (fStmPref_SaveMode = STMPREF_SAVEMODE_ALL);
  // Verifica se dei files con lo stesso nome esistono già nella cartella temporanea
  // ed eventualmente li elimina
  if FileExists(StmPref_FullPathIniFileName) then
    DeleteFile(StmPref_FullPathIniFileName);
  if FileExists(StmPref_FullPathCompressedFileName) then
    DeleteFile(StmPref_FullPathCompressedFileName);
  // ===========================================================================
  // SALVATAGGIO PREFERENZE DI STAMPA NEL FILE INI
  // ---------------------------------------------------------------------------
  // Apre il file in cui salvare i parametri
  P := TMemIniFile.Create(StmPref_FullPathIniFileName);
  try
    // ------------------- COLONNE
    if All or (StmColCodiceArticolo.Checked <> (StmColCodiceArticolo.Tag = 1)) then
      P.WriteBool('Columns', 'Col_CodiceArticolo', StmColCodiceArticolo.Checked);
    if All or (StmColDescrizione.Checked <> (StmColDescrizione.Tag = 1)) then
      P.WriteBool('Columns', 'Col_Descrizione', StmColDescrizione.Checked);
    if All or (StmColPrezzoUnitario.Checked <> (StmColPrezzoUnitario.Tag = 1)) then
      P.WriteBool('Columns', 'Col_PrezzoUnitario', StmColPrezzoUnitario.Checked);
    if All or (StmColUM.Checked <> (StmColUM.Tag = 1)) then
      P.WriteBool('Columns', 'Col_UnitaDiMisura', StmColUM.Checked);
    if All or (StmColQta.Checked <> (StmColQta.Tag = 1)) then
      P.WriteBool('Columns', 'Col_QTA', StmColQta.Checked);
    if All or (StmColQtaEvasa.Checked <> (StmColQtaEvasa.Tag = 1)) then
      P.WriteBool('Columns', 'Col_QTAEvasa', StmColQtaEvasa.Checked);
    if All or (StmColQtaDaEvadere.Checked <> (StmColQtaDaEvadere.Tag = 1)) then
      P.WriteBool('Columns', 'Col_QTADaEvadere', StmColQtaDaEvadere.Checked);
    if All or (StmColSconto1.Checked <> (StmColSconto1.Tag = 1)) then
      P.WriteBool('Columns', 'Col_ScontoRigo1', StmColSconto1.Checked);
    if All or (StmColSconto2.Checked <> (StmColSconto2.Tag = 1)) then
      P.WriteBool('Columns', 'Col_ScontoRigo2', StmColSconto2.Checked);
    if All or (StmColSconto3.Checked <> (StmColSconto3.Tag = 1)) then
      P.WriteBool('Columns', 'Col_ScontoRigo3', StmColSconto3.Checked);
    if All or (StmColImporto.Checked <> (StmColImporto.Tag = 1)) then
      P.WriteBool('Columns', 'Col_ImportoRigo', StmColImporto.Checked);
    if All or (StmColCodiceIVA.Checked <> (StmColCodiceIVA.Tag = 1)) then
      P.WriteBool('Columns', 'Col_CodiceIVA', StmColCodiceIVA.Checked);
    if All or (StmColDescrizioneIVA.Checked <> (StmColDescrizioneIVA.Tag = 1)) then
      P.WriteBool('Columns', 'Col_DescrizioneIVA', StmColDescrizioneIVA.Checked);
    if All or (StmColNote.Checked <> (StmColNote.Tag = 1)) then
      P.WriteBool('Columns', 'Col_NoteRigo', StmColNote.Checked);
    if All or (StmColCostoUnitario.Checked <> (StmColCostoUnitario.Tag = 1)) then
      P.WriteBool('Columns', 'Col_PrezzoAcquistoArticolo', StmColCostoUnitario.Checked);
    if All or (StmColRicarico.Checked <> (StmColRicarico.Tag = 1)) then
      P.WriteBool('Columns', 'Col_Margine', StmColRicarico.Checked);
    if All or (StmColRicaricoImporto.Checked <> (StmColRicaricoImporto.Tag = 1)) then
      P.WriteBool('Columns', 'Col_ImportoMargine', StmColRicaricoImporto.Checked);
    // ------------------- SEZIONI
    if All or (StmSezLogo.Checked <> (StmSezLogo.Tag = 1)) then
      P.WriteBool('Sections', 'V_Logo', StmSezLogo.Checked);
    if All or (StmSezDestinazioneMerce.Checked <> (StmSezDestinazioneMerce.Tag = 1)) then
      P.WriteBool('Sections', 'V_LuogoDestinazione', StmSezDestinazioneMerce.Checked);
    if All or (StmSezCantiere.Checked <> (StmSezCantiere.Tag = 1)) then
      P.WriteBool('Sections', 'V_Cantiere', StmSezCantiere.Checked);
    if All or (StmSezTotaliDoc.Checked <> (StmSezTotaliDoc.Tag = 1)) then
      P.WriteBool('Sections', 'V_Totali', StmSezTotaliDoc.Checked);
    if All or (StmSezCastellettoIVA.Checked <> (StmSezCastellettoIVA.Tag = 1)) then
      P.WriteBool('Sections', 'CastellettoIVA', StmSezCastellettoIVA.Checked);
    if All or (StmSezRifAltriSogg.Checked <> (StmSezRifAltriSogg.Tag = 1)) then
      P.WriteBool('Sections', 'V_AltriSoggetti', StmSezRifAltriSogg.Checked);
    if All or (StmSezNote.Checked <> (StmSezNote.Tag = 1)) then
      P.WriteBool('Sections', 'V_Note', StmSezNote.Checked);
    if All or (StmSezMessaggi.Checked <> (StmSezMessaggi.Tag = 1)) then
      P.WriteBool('Sections', 'V_Messaggi', StmSezMessaggi.Checked);
    if All or (StmSezTrasporto.Checked <> (StmSezTrasporto.Tag = 1)) then
      P.WriteBool('Sections', 'V_Trasporto', StmSezTrasporto.Checked);
    if All or (StmSezPagamento.Checked <> (StmSezPagamento.Tag = 1)) then
      P.WriteBool('Sections', 'V_Pagamento', StmSezPagamento.Checked);
    if All or (StmSezBanca.Checked <> (StmSezBanca.Tag = 1)) then
      P.WriteBool('Sections', 'V_Banca', StmSezBanca.Checked);
    if All or (StmSezOperatore.Checked <> (StmSezOperatore.Tag = 1)) then
      P.WriteBool('Sections', 'V_Operatore', StmSezOperatore.Checked);
    if All or (StmSezScadenze.Checked <> (StmSezScadenze.Tag = 1)) then
      P.WriteBool('Sections', 'V_Scadenze', StmSezScadenze.Checked);
    if All or (StmSezFirme.Checked <> (StmSezFirme.Tag = 1)) then
    begin
      if StmSezFirme.Checked then
        P.WriteInteger('Sections', 'S_ChiusuraTipo', 2)
      else
        P.WriteInteger('Sections', 'S_ChiusuraTipo', 1);
    end;
    // ------------------- PREZZI E TOTALI IVA COMPRESA/ESCLUSA
    P.WriteBool('IVA', 'PrezziIvaCompresa', StmPrzIvaComp.Checked);
    P.WriteBool('IVA', 'TotaliIvaEsclusa', StmTotIvaEscl.Checked);
    // ------------------- SALVATAGGIO LARGHEZZA COLONNE
    // NB: IL salvataggio delle colonne viene eseguito solo in modalità di salvataggio
    // totale.
    // Hp dovuto fare così perchè per fare il salvataggio della larghezza delle sole colonne
    // divrese dal default dovrei avere da qualche parte il valore di default per ogni colonna
    // e non c'è, almeno per il momento.
    if fStmPref_SaveMode = STMPREF_SAVEMODE_ALL then
    begin
      // Cicla per tutte le colonne del corpo documento
      for i := 0 to tvCorpo.ColumnCount - 1 do
      begin
        Sez := 'COLUMN_' + tvCorpo.Columns[i].Name;
        P.WriteInteger(Sez, 'Width', tvCorpo.Columns[i].Width);
      end;
    end;
    // Salvataggio sul file
    P.UpdateFile;
    // Flag che indica se il file appena creato è vuoto oppure contiene almeno un parametro
    IniFileEmpty := (not P.SectionExists('Columns')) and (not P.SectionExists('Sections')) and (not P.SectionExists('IVA'));
  finally
    P.Free;
  end;
  // ===========================================================================

  // ===========================================================================
  // COMPRESSIONE DEL FILE INI E SALVATAGGIO SUL DOCUMENTO
  // ---------------------------------------------------------------------------
  // Se il file risulta vuoto non salva nulla
  if IniFileEmpty then
    Exit;
  // Creazione dell'archivio compresso
  ZLB1.CreateArchive(StmPref_FullPathCompressedFileName);
  // Aggiunge il file da comprimere con le preferenze di stampa
  ZLB1.AddFile(StmPref_FullPathIniFileName);
  // Chiude l'archivio
  ZLB1.CloseArchive;
  // Salva il file compresso nel campo blob apposito
  QryDocumentoSTMPREF.LoadFromFile(StmPref_FullPathCompressedFileName);
  // ===========================================================================
end;

// Procedura che preleva il file ini con le preferenze di stampa del documento e
// ne carica i parametri sui campi della form.
procedure TPreventiviOrdiniForm.StmPref_LoadPreferences;
var
  P: TMemIniFile;
  CurrVal: Integer;
  CurrIniFileName, Sez: String;
  i, CurrValue: Integer;
begin
  // Se il sistema delle preferenze di stampa è disabilitato esce subito
  if not fStmPref_Enabled then
    Exit;
  // Ovviamente solo se il campo non è vuoto
  if not QryDocumentoSTMPREF.IsNull then
  begin
    // Salva il file compresso delle preferenze di stampa nella cartella temporanea
    QryDocumentoSTMPREF.SaveToFile(StmPref_FullPathCompressedFileName);
    // Apre il file compresso
    ZLB1.OpenArchive(StmPref_FullPathCompressedFileName);
    // Salva nell'apposita variabile il nome dell'unico file contenuto
    // nell'archivio compresso
    CurrIniFileName := ZLB1.Files[0].Name;
    // Estrae il file
    ZLB1.ExtractFileByIndex(DM1.CartellaTmp, 0);
    // Chiude l'archivio compresso
    ZLB1.CloseArchive;
    // Carica le preferenze di stampa nell'apposito pannello
    P := TMemIniFile.Create(DM1.CartellaTmp + CurrIniFileName);
    try
      // =======================================================================
      // COLONNE
      // -----------------------------------------------------------------------
      // Codice articolo
      CurrVal := P.ReadInteger('Columns', 'Col_CodiceArticolo', -1);
      if CurrVal <> -1 then
        StmColCodiceArticolo.Checked := (CurrVal > 0);
      // Descrizione
      CurrVal := P.ReadInteger('Columns', 'Col_Descrizione', -1);
      if CurrVal <> -1 then
        StmColDescrizione.Checked := (CurrVal > 0);
      // Prezzo unitario
      CurrVal := P.ReadInteger('Columns', 'Col_PrezzoUnitario', -1);
      if CurrVal <> -1 then
        StmColPrezzoUnitario.Checked := (CurrVal > 0);
      // Unita di misura
      CurrVal := P.ReadInteger('Columns', 'Col_UnitaDiMisura', -1);
      if CurrVal <> -1 then
        StmColUM.Checked := (CurrVal > 0);
      // Quantità
      CurrVal := P.ReadInteger('Columns', 'Col_QTA', -1);
      if CurrVal <> -1 then
        StmColQta.Checked := (CurrVal > 0);
      // Quantità evasa
      CurrVal := P.ReadInteger('Columns', 'Col_QTAEvasa', -1);
      if CurrVal <> -1 then
        StmColQtaEvasa.Checked := (CurrVal > 0);
      // Quantità da evadere
      CurrVal := P.ReadInteger('Columns', 'Col_QTADaEvadere', -1);
      if CurrVal <> -1 then
        StmColQtaDaEvadere.Checked := (CurrVal > 0);
      // Sconto 1
      CurrVal := P.ReadInteger('Columns', 'Col_ScontoRigo1', -1);
      if CurrVal <> -1 then
        StmColSconto1.Checked := (CurrVal > 0);
      // Sconto 2
      CurrVal := P.ReadInteger('Columns', 'Col_ScontoRigo2', -1);
      if CurrVal <> -1 then
        StmColSconto2.Checked := (CurrVal > 0);
      // Sconto 3
      CurrVal := P.ReadInteger('Columns', 'Col_ScontoRigo3', -1);
      if CurrVal <> -1 then
        StmColSconto3.Checked := (CurrVal > 0);
      // Importo rigo
      CurrVal := P.ReadInteger('Columns', 'Col_ImportoRigo', -1);
      if CurrVal <> -1 then
        StmColImporto.Checked := (CurrVal > 0);
      // Codice IVA
      CurrVal := P.ReadInteger('Columns', 'Col_CodiceIVA', -1);
      if CurrVal <> -1 then
        StmColCodiceIVA.Checked := (CurrVal > 0);
      // Descrizione IVA
      CurrVal := P.ReadInteger('Columns', 'Col_DescrizioneIVA', -1);
      if CurrVal <> -1 then
        StmColDescrizioneIVA.Checked := (CurrVal > 0);
      // Note rigo
      CurrVal := P.ReadInteger('Columns', 'Col_NoteRigo', -1);
      if CurrVal <> -1 then
        StmColNote.Checked := (CurrVal > 0);
      // Costo unitario
      CurrVal := P.ReadInteger('Columns', 'Col_PrezzoAcquistoArticolo', -1);
      if CurrVal <> -1 then
        StmColCostoUnitario.Checked := (CurrVal > 0);
      // Ricarico %
      CurrVal := P.ReadInteger('Columns', 'Col_Margine', -1);
      if CurrVal <> -1 then
        StmColRicarico.Checked := (CurrVal > 0);
      // Ricarico importo
      CurrVal := P.ReadInteger('Columns', 'Col_ImportoMargine', -1);
      if CurrVal <> -1 then
        StmColRicaricoImporto.Checked := (CurrVal > 0);
      // =======================================================================
      // =======================================================================
      // SEZIONI
      // -----------------------------------------------------------------------
      // Loghi
      CurrVal := P.ReadInteger('Sections', 'V_Logo', -1);
      if CurrVal <> -1 then
        StmSezLogo.Checked := (CurrVal > 0);
      // Luogo di destinazione della merce
      CurrVal := P.ReadInteger('Sections', 'V_LuogoDestinazione', -1);
      if CurrVal <> -1 then
        StmSezDestinazioneMerce.Checked := (CurrVal > 0);
      // Cantiere
      CurrVal := P.ReadInteger('Sections', 'V_Cantiere', -1);
      if CurrVal <> -1 then
        StmSezCantiere.Checked := (CurrVal > 0);
      // Totali documento
      CurrVal := P.ReadInteger('Sections', 'V_Totali', -1);
      if CurrVal <> -1 then
        StmSezTotaliDoc.Checked := (CurrVal > 0);
      // Castelletto IVA
      CurrVal := P.ReadInteger('Sections', 'CastellettoIVA', -1);
      if CurrVal <> -1 then
        StmSezCastellettoIVA.Checked := (CurrVal > 0);
      // Riferimenti ad altri soggetti
      CurrVal := P.ReadInteger('Sections', 'V_AltriSoggetti', -1);
      if CurrVal <> -1 then
        StmSezRifAltriSogg.Checked := (CurrVal > 0);
      // Note
      CurrVal := P.ReadInteger('Sections', 'V_Note', -1);
      if CurrVal <> -1 then
        StmSezNote.Checked := (CurrVal > 0);
      // Messaggi
      CurrVal := P.ReadInteger('Sections', 'V_Messaggi', -1);
      if CurrVal <> -1 then
        StmSezMessaggi.Checked := (CurrVal > 0);
      // Trasporto
      CurrVal := P.ReadInteger('Sections', 'V_Trasporto', -1);
      if CurrVal <> -1 then
        StmSezTrasporto.Checked := (CurrVal > 0);
      // Modalita di pagamento
      CurrVal := P.ReadInteger('Sections', 'V_Pagamento', -1);
      if CurrVal <> -1 then
        StmSezPagamento.Checked := (CurrVal > 0);
      // Banca
      CurrVal := P.ReadInteger('Sections', 'V_Banca', -1);
      if CurrVal <> -1 then
        StmSezBanca.Checked := (CurrVal > 0);
      // Operatore
      CurrVal := P.ReadInteger('Sections', 'V_Operatore', -1);
      if CurrVal <> -1 then
        StmSezOperatore.Checked := (CurrVal > 0);
      // Scadenze
      CurrVal := P.ReadInteger('Sections', 'V_Scadenze', -1);
      if CurrVal <> -1 then
        StmSezScadenze.Checked := (CurrVal > 0);
      // Firme
      CurrVal := P.ReadInteger('Sections', 'S_ChiusuraTipo', -1);
      if CurrVal <> -1 then
        StmSezFirme.Checked := (CurrVal > 1);
      // =======================================================================
      // =======================================================================
      // IVA
      // -----------------------------------------------------------------------
      // Prezzi IVA compresa
      CurrVal := P.ReadInteger('IVA', 'PrezziIvaCompresa', -1);
      if CurrVal <> -1 then
      begin
        StmPrzIvaComp.Checked := (CurrVal > 0);
        StmPrzIvaEscl.Checked := not StmPrzIvaComp.Checked;
      end;
      // Totali IVA compresa
      CurrVal := P.ReadInteger('IVA', 'TotaliIvaEsclusa', -1);
      if CurrVal <> -1 then
      begin
        StmTotIvaEscl.Checked := (CurrVal > 0);
        StmTotIvaComp.Checked := not StmTotIvaEscl.Checked;
      end;
      // =======================================================================
      // =======================================================================
      // COLONNE
      // -----------------------------------------------------------------------
      // Carica le eventuali impostazioni delle colonne personalizzate per il documento
      for i := 0 to tvCorpo.ColumnCount - 1 do
      begin
        Sez := 'COLUMN_' + tvCorpo.Columns[i].Name;
        if P.SectionExists(Sez) then
        begin
          CurrValue := P.ReadInteger(Sez, 'Width', -1);
          if CurrValue <> -1 then
            tvCorpo.Columns[i].Width := CurrValue;
        end;
        P.WriteInteger(Sez, 'Width', tvCorpo.Columns[i].Width);
      end;
      // =======================================================================
    finally
      P.Free;
    end;
  end;
end;

// Procedura che imposta quali colonne e sezioni della parte di impostazione della stampa del docuemnto
// devono essere abilitate e quali no in base a quelle visibili o meno a video
procedure TPreventiviOrdiniForm.StmPref_Initialize;
begin
  // ===========================================================================
  // IMPOSTA LE VOCI ABILITATE O DISABILITATE
  // ---------------------------------------------------------------------------
  // Enable/Disable colonne corpo documento
  StmColCodiceArticolo.Enabled := tvCorpoCODICEARTICOLOSTM.Tag > 0;
  StmColDescrizione.Enabled := tvCorpoDESCRIZIONE.Tag > 0;
  StmColPrezzoUnitario.Enabled := (tvCorpoPREZZOUNITARIO.Tag > 0) or (tvCorpoPREZZOUNITARIOIVACOMPRESA.Tag > 0);
  StmColUM.Enabled := tvCorpoUNITADIMISURA.Tag > 0;
  StmColQta.Enabled := tvCorpoQTA.Tag > 0;
  StmColQtaEvasa.Enabled := tvCorpoQTAEVASA.Tag > 0;
  StmColQtaDaEvadere.Enabled := tvCorpoQTADAEVADERE.Tag > 0;
  StmColSconto1.Enabled := tvCorpoSCONTORIGO.Tag > 0;
  StmColSconto2.Enabled := tvCorpoSCONTORIGO2.Tag > 0;
  StmColSconto3.Enabled := tvCorpoSCONTORIGO3.Tag > 0;
  StmColImporto.Enabled := (tvCorpoIMPORTORIGO.Tag > 0) or (tvCorpoIMPORTORIGOIVACOMPRESA.Tag > 0);
  StmColCodiceIVA.Enabled := tvCorpoCODICEIVA.Tag > 0;
  StmColDescrizioneIVA.Enabled := tvCorpoDESCRIZIONEIVA.Tag > 0;
  StmColNote.Enabled := tvCorpoNOTERIGO.Tag > 0;
  StmColCostoUnitario.Enabled := tvCorpoPREZZOACQUISTOARTICOLO.Tag > 0;
  StmColRicarico.Enabled := tvCorpoMARGINE.Tag > 0;
  StmColRicaricoImporto.Enabled := tvCorpoIMPORTOMARGINE.Tag > 0;
  // Enable/Disable sezioni testa e piede documento
  StmSezLogo.Enabled := True;
  StmSezDestinazioneMerce.Enabled := PanelLuogoDestinazione.Tag > 0;
  StmSezCantiere.Enabled := PanelCantiere.Tag > 0;
  StmSezTotaliDoc.Enabled := PanelPiede1.Visible or PanelPiede2.Visible or PanelPiede3.Visible;
  StmSezCastellettoIVA.Enabled := StmSezTotaliDoc.Enabled;
  StmSezRifAltriSogg.Enabled := PanelAltriSoggetti.Tag > 0;
  StmSezNote.Enabled := PanelNote.Tag > 0;
  StmSezMessaggi.Enabled := PanelMessaggi.Tag > 0;
  StmSezTrasporto.Enabled := PanelTrasporto.Tag > 0;
  StmSezPagamento.Enabled := PanelPagamento.Tag > 0;
  StmSezBanca.Enabled := PanelBanca.Tag > 0;
  StmSezOperatore.Enabled := PanelOperatore.Tag > 0;
  StmSezScadenze.Enabled := PanelScadenze.Tag > 0;
  StmSezFirme.Enabled := True;
  // Enable/Disable seleziona se prezzi IVA compresa o esclusa
  StmPrzIvaComp.Enabled := StmColPrezzoUnitario.Enabled or StmColImporto.Enabled;
  StmPrzIvaEscl.Enabled := StmColPrezzoUnitario.Enabled or StmColImporto.Enabled;
  StmTotIvaComp.Enabled := True;
  StmTotIvaEscl.Enabled := True;
  // ===========================================================================

  // ===========================================================================
  // CARICA I VALORI DI DEFAULT
  // ---------------------------------------------------------------------------
  // Carica i valori di default delle colonne
  StmColCodiceArticolo.Checked := tvCorpoCODICEARTICOLOSTM.Tag > 1;
  StmColDescrizione.Checked := tvCorpoDESCRIZIONE.Tag > 1;
  StmColPrezzoUnitario.Checked := (tvCorpoPREZZOUNITARIO.Tag > 1) or (tvCorpoPREZZOUNITARIOIVACOMPRESA.Tag > 1);
  StmColUM.Checked := tvCorpoUNITADIMISURA.Tag > 1;
  StmColQta.Checked := tvCorpoQTA.Tag > 1;
  StmColQtaEvasa.Checked := tvCorpoQTAEVASA.Tag > 1;
  StmColQtaDaEvadere.Checked := tvCorpoQTADAEVADERE.Tag > 1;
  StmColSconto1.Checked := tvCorpoSCONTORIGO.Tag > 1;
  StmColSconto2.Checked := tvCorpoSCONTORIGO2.Tag > 1;
  StmColSconto3.Checked := tvCorpoSCONTORIGO3.Tag > 1;
  StmColImporto.Checked := (tvCorpoIMPORTORIGO.Tag > 1) or (tvCorpoIMPORTORIGOIVACOMPRESA.Tag > 1);
  StmColCodiceIVA.Checked := tvCorpoCODICEIVA.Tag > 1;
  StmColDescrizioneIVA.Checked := tvCorpoDESCRIZIONEIVA.Tag > 1;
  StmColNote.Checked := tvCorpoNOTERIGO.Tag > 1;
  StmColCostoUnitario.Checked := tvCorpoPREZZOACQUISTOARTICOLO.Tag > 1;
  StmColRicarico.Checked := tvCorpoMARGINE.Tag > 1;
  StmColRicaricoImporto.Checked := tvCorpoIMPORTOMARGINE.Tag > 1;
  // Enable/Disable sezioni testa e piede documento
  StmSezLogo.Checked := fDefaultStampaLogoIntestazione;
  StmSezDestinazioneMerce.Checked := PanelLuogoDestinazione.Tag > 1;
  StmSezCantiere.Checked := PanelCantiere.Tag > 1;
  // NB: Spostato nel CaricaLayouts perchè ho messo un apposito parametro nel layouts.ini per
  // determinare lo stato di default di questo parametro
  // StmSezTotaliDoc.Checked := PanelPiede1.Visible or PanelPiede2.Visible or PanelPiede3.Visible;
  StmSezCastellettoIVA.Checked := fStampaCastellettoIVA;
  StmSezRifAltriSogg.Checked := PanelAltriSoggetti.Tag > 1;
  StmSezNote.Checked := PanelNote.Tag > 1;
  StmSezMessaggi.Checked := PanelMessaggi.Tag > 1;
  StmSezTrasporto.Checked := PanelTrasporto.Tag > 1;
  StmSezPagamento.Checked := PanelPagamento.Tag > 1;
  StmSezBanca.Checked := PanelBanca.Tag > 1;
  StmSezOperatore.Checked := PanelOperatore.Tag > 1;
  StmSezScadenze.Checked := PanelScadenze.Tag > 1;
  StmSezFirme.Checked := fChiusuraTipo > 1;
  // Enable/Disable seleziona se prezzi IVA compresa o esclusa
  StmPrzIvaComp.Checked := (tvCorpoPREZZOUNITARIOIVACOMPRESA.Tag > 0) or (tvCorpoIMPORTORIGOIVACOMPRESA.Tag > 0);
  StmPrzIvaEscl.Checked := not StmPrzIvaComp.Checked;
  // Impostazione valore iniziale dei totali se IVA compresa o esclusa
  StmTotIvaEscl.Checked := fStmPref_TotaliIvaEsclusa;
  StmTotIvaComp.Checked := not fStmPref_TotaliIvaEsclusa;
  // ===========================================================================

  // ===========================================================================
  // Memorizza i valori iniziali per verificare poi se sono cambiati
  // ---------------------------------------------------------------------------
  // Carica i valori di default delle colonne
  if StmColCodiceArticolo.Checked then
    StmColCodiceArticolo.Tag := 1;
  if StmColDescrizione.Checked then
    StmColDescrizione.Tag := 1;
  if StmColPrezzoUnitario.Checked then
    StmColPrezzoUnitario.Tag := 1;
  if StmColUM.Checked then
    StmColUM.Tag := 1;
  if StmColQta.Checked then
    StmColQta.Tag := 1;
  if StmColQtaEvasa.Checked then
    StmColQtaEvasa.Tag := 1;
  if StmColQtaDaEvadere.Checked then
    StmColQtaDaEvadere.Tag := 1;
  if StmColSconto1.Checked then
    StmColSconto1.Tag := 1;
  if StmColSconto2.Checked then
    StmColSconto2.Tag := 1;
  if StmColSconto3.Checked then
    StmColSconto3.Tag := 1;
  if StmColImporto.Checked then
    StmColImporto.Tag := 1;
  if StmColCodiceIVA.Checked then
    StmColCodiceIVA.Tag := 1;
  if StmColDescrizioneIVA.Checked then
    StmColDescrizioneIVA.Tag := 1;
  if StmColNote.Checked then
    StmColNote.Tag := 1;
  if StmColCostoUnitario.Checked then
    StmColCostoUnitario.Tag := 1;
  if StmColRicarico.Checked then
    StmColRicarico.Tag := 1;
  if StmColRicaricoImporto.Checked then
    StmColRicaricoImporto.Tag := 1;
  // Enable/Disable sezioni testa e piede documento
  if StmSezLogo.Checked then
    StmSezLogo.Tag := 1;
  if StmSezDestinazioneMerce.Checked then
    StmSezDestinazioneMerce.Tag := 1;
  if StmSezCantiere.Checked then
    StmSezCantiere.Tag := 1;
  if StmSezTotaliDoc.Checked then
    StmSezTotaliDoc.Tag := 1;
  if StmSezCastellettoIVA.Checked then
    StmSezCastellettoIVA.Tag := 1;
  if StmSezRifAltriSogg.Checked then
    StmSezRifAltriSogg.Tag := 1;
  if StmSezNote.Checked then
    StmSezNote.Tag := 1;
  if StmSezMessaggi.Checked then
    StmSezMessaggi.Tag := 1;
  if StmSezTrasporto.Checked then
    StmSezTrasporto.Tag := 1;
  if StmSezPagamento.Checked then
    StmSezPagamento.Tag := 1;
  if StmSezBanca.Checked then
    StmSezBanca.Tag := 1;
  if StmSezOperatore.Checked then
    StmSezOperatore.Tag := 1;
  if StmSezScadenze.Checked then
    StmSezScadenze.Tag := 1;
  if StmSezFirme.Checked then
    StmSezFirme.Tag := 1;
  // Enable/Disable seleziona se prezzi IVA compresa o esclusa
  if StmPrzIvaComp.Checked then
    StmPrzIvaComp.Tag := 1;
  if StmPrzIvaEscl.Checked then
    StmPrzIvaEscl.Tag := 1;
  // Enable/Disable seleziona se totali IVA compresa o esclusa
  if StmTotIvaComp.Checked then
    StmTotIvaComp.Tag := 1;
  if StmTotIvaEscl.Checked then
    StmTotIvaEscl.Tag := 1;
  // ===========================================================================
end;

// Procedura che dimensiona la ClientArea delle form
procedure TPreventiviOrdiniForm.CalcolaDimensioniClientAreaChildForm(FixedWidth: Boolean);
var
  NewValue: Integer;
begin
  // Calcola il nuovo valore da assegnare alla proprietà Left del pannello
  NewValue := Trunc((DocClientArea.ClientWidth - PanelUpper.Width) / 2);
  if NewValue < 0 then
    NewValue := 0;
  // Imposta la proprietà Left dei pannelli  Upper e Lower in modo che siano sempre centrati
  PanelUpper.Left := NewValue;
  PanelLower.Left := NewValue;
  StampaClientArea.Left := NewValue;
  DocCorrClientArea.Left := NewValue;
  DocCorrClientArea.Height := TabDocumentiCorrelati.Height - 5; // Altrimenti mi scazza la dimensione verticale
  NotificheFEClientArea.Left := NewValue;
  // Per quanto riguarda il corpo del documento in  base al paramtro FixedWidth lo imposta
  // in modo che si adatti alla dimensione dello schermo all'argandosi per sfruttare tutto lo
  // spazio disponibile oppure lo imposta come i panneli superiore e inferiore a larghezza fissa
  // e centrata orizzontalmente.
  if FixedWidth then
  begin
    // Larghezza fissa e centrato
    PanelCorpoDoc.Left := NewValue;
    PanelCorpoDoc.Width := PanelUpper.Width;
  end
  else
  begin
    // Larghezza variabile
    PanelCorpoDoc.Left := 0;
    PanelCorpoDoc.Width := DocClientArea.ClientWidth;
  end;
end;

// Procedura che riceve un GUID da ricercare e poi se lo trova si posiziona sul rigo relativo
function TPreventiviOrdiniForm.LocateGUID(DC: TcxCustomDataController; GUIDToSearch: String): Boolean;
var
  PrecUpdateLocked: Boolean;
  RI: Integer;
begin
  // Inizializzazione
  Result := False;
  RI := 0;
  GridCorpo.SetFocus;
  // Ferma il tracciamento della griglia (se non è già bloccato)
  PrecUpdateLocked := GridCorpo.UpdateLocked;
  if not PrecUpdateLocked then
    GridCorpo.BeginUpdate;
  try
    // Cicla per tutti i righi del documento
    for RI := 0 to DC.RecordCount - 1 do
    begin
      // Se il GUID_REF del rigo attuale è quello che cerchiamo pone il focus su questo record ed esce
      if (not VarIsNull(DC.Values[RI, tvCorpoGUID_REF.Index])) and (DC.DisplayTexts[RI, tvCorpoGUID_REF.Index] = GUIDToSearch) then
      begin
        DC.FocusedRecordIndex := RI;
        DC.SelectRows(RI, RI);
        Result := True;
        Exit;
      end;
      // Se il rigo attuale ha dei sottorighi lo cerca anche nei sottorighi
      if DC.IsDetailDataControllerExist(RI, RELATION_IDX_SOTTORIGHI_NORMALI) and LocateGUID(DC.GetDetailDataController(RI, RELATION_IDX_SOTTORIGHI_NORMALI),
        GUIDToSearch) then
      begin
        tvCorpo.ViewData.Records[RI].Expand(False);
        Result := True;
        Exit;
      end;
    end;
  finally
    // Ripristina il tracciamento de deve
    if not PrecUpdateLocked then
      GridCorpo.EndUpdate;
  end;
end;

// Procedura che assegna il GUID al rigo  ricevuto come parametro
// NB: Ovviamente solo se il rigo non ha già un GUID
procedure TPreventiviOrdiniForm.SetRowGUID(DC: TcxCustomDataController; Row: Integer);
begin
  // Solo se  il rigo non ha già il GUID
  // Assegna un nuovo GUID al rigo
  if VarIsNull(DC.Values[Row, tvCorpoGUID.Index]) then
    DC.Values[Row, tvCorpoGUID.Index] := DM1.GUIDAsString;
  // Se il GUID_REF è nullo gli assegna lo stesso GUID
  if VarIsNull(DC.Values[Row, tvCorpoGUID_REF.Index]) then
    DC.Values[Row, tvCorpoGUID_REF.Index] := DC.Values[Row, tvCorpoGUID.Index];
end;

procedure TPreventiviOrdiniForm.SetBodyView(const Value: TBodyView);
var
  LvacNormalTag, LvacExt1Tag, LvacExt2Tag, LvacExt3Tag, LvacExt4Tag, LvacExt5Tag, LvacFullTag, LvacDebugTag: Byte;
  tvi: Integer;
begin
  FBodyView := Value;

  GridCorpo.BeginUpdate;
  try
    // Set Footers visibility
    tvCorpo.OptionsView.Footer := (FBodyView > TBodyView.vacNormale);
    tvCorpo.OptionsView.GroupFooters := TcxGridGroupFootersMode(IfThen(FBodyView > TBodyView.vacNormale, 2, 0));

    // Set tag values
    tvCorpoQTAOPERA.Tag := IfThen(FBodyView < TBodyView.vacExt1, 0, 1);
    tvCorpoMINUTIPREVISTI.Tag := IfThen(FBodyView < TBodyView.vacExt1, 0, 1);

    tvCorpoIMPORTOCOSTO.Tag := IfThen(FBodyView < TBodyView.vacExt2, 0, 1);
    tvCorpoIMPORTOCOSTOCOMPONENTI.Tag := IfThen(FBodyView < TBodyView.vacExt2, 0, 1);
    tvCorpoIMPORTOCOSTOOPERA.Tag := IfThen(FBodyView < TBodyView.vacExt2, 0, 1);

    tvCorpoIMPORTOMARGINECOMPONENTI.Tag := IfThen(FBodyView < TBodyView.vacExt3, 0, 1);
    tvCorpoIMPORTOMARGINEOPERA.Tag := IfThen(FBodyView < TBodyView.vacExt3, 0, 1);

    tvCorpoIMPORTOCOMPONENTI.Tag := IfThen(FBodyView < TBodyView.vacExt4, 0, 1);
    tvCorpoIMPORTOOPERA.Tag := IfThen(FBodyView < TBodyView.vacExt4, 0, 1);

    tvCorpoPERCMARGINECOMPONENTI.Tag := IfThen(FBodyView < TBodyView.vacExt5, 0, 1);
    tvCorpoPERCMARGINEOPERA.Tag := IfThen(FBodyView < TBodyView.vacExt5, 0, 1);

    tvCorpoCOSTOCOMPONENTIUNIT.Tag := IfThen(FBodyView < TBodyView.vacFull, 0, 1);
    tvCorpoCOSTOOPERAUNIT.Tag := IfThen(FBodyView < TBodyView.vacFull, 0, 1);
    tvCorpoCOMPONENTIUNIT.Tag := IfThen(FBodyView < TBodyView.vacFull, 0, 1);
    tvCorpoOPERAUNIT.Tag := IfThen(FBodyView < TBodyView.vacFull, 0, 1);
    tvCorpoQTAOPERAUNIT.Tag := IfThen(FBodyView < TBodyView.vacFull, 0, 1);
    tvCorpoORDER.Tag := IfThen(FBodyView < TBodyView.vacFull, 0, 1);

    // Force the repaint of the view
    CaricaLayoutDocumento_NotLoadColumnSettingsNextTime := False;
    CaricaLayoutDocumento;

    // Reimposta alcuni colori/posizione di alcune colonne in base alla situazione
    if FBodyView < TBodyView.vacExt1 then
    begin
      // Sposta alcune colonne
      tvCorpoDESCRIZIONEIVA.Index := 26;
      for tvi := 0 to tvDiBa.CloneCount - 1 do
        TcxGridTableView(tvDiBa.Clones[tvi]).Columns[tvDiBaDESCRIZIONEIVA.Index].Index := 26;
      tvDiBaDESCRIZIONEIVA.Index := 26;
      // Imposta lo stile di alcune colonne
      // TBodyView.vacExt1
      tvCorpoQTA.Styles.Content := nil;
      tvCorpoQTA.Styles.Footer := nil;
      tvCorpoMINUTIPREVISTI.Styles.Content := nil;
      tvCorpoMINUTIPREVISTI.Styles.Footer := nil;
      // TBodyView.vacExt2
      tvCorpoIMPORTOCOSTO.Styles.Content := nil;
      tvCorpoIMPORTOCOSTO.Styles.Footer := nil;
      // TBodyView.vacExt2
      tvCorpoIMPORTOMARGINE.Styles.Content := nil;
      tvCorpoIMPORTOMARGINE.Styles.Footer := nil;
      // TBodyView.vacExt3
      tvCorpoIMPORTORIGO.Styles.Content := nil;
      tvCorpoIMPORTORIGO.Styles.Footer := nil;
      // TBodyView.vacExt4
      tvCorpoIMPORTORIGOIVACOMPRESA.Styles.Content := nil;
      tvCorpoIMPORTORIGOIVACOMPRESA.Styles.Footer := nil;
      // TBodyView.vacExt5
      tvCorpoMARGINE.Styles.Content := nil;
      tvCorpoMARGINE.Styles.Footer := nil;
    end
    else
    begin
      // Sposta alcune colonne
      tvCorpoDESCRIZIONEIVA.Index := 42;
      for tvi := 0 to tvDiBa.CloneCount - 1 do
        TcxGridTableView(tvDiBa.Clones[tvi]).Columns[tvDiBaDESCRIZIONEIVA.Index].Index := 42;
      tvDiBaDESCRIZIONEIVA.Index := 42;
      // Imposta lo stile di alcune colonne
      // TBodyView.vacExt1
      tvCorpoQTA.Styles.Content := DM1.tvGCDetailContent_Qta_Bold;
      tvCorpoQTA.Styles.Footer := DM1.tvGCDetailContent_Qta_Bold;
      tvCorpoMINUTIPREVISTI.Styles.Content := DM1.tvGCDetailContent_Qta;
      tvCorpoMINUTIPREVISTI.Styles.Footer := DM1.tvGCDetailContent_Qta;
      // TBodyView.vacExt1
      tvCorpoIMPORTOCOSTO.Styles.Content := DM1.tvGCDetailContent_Costo_Bold;
      tvCorpoIMPORTOCOSTO.Styles.Footer := DM1.tvGCDetailContent_Costo_Bold;
      // TBodyView.vacExt2
      tvCorpoIMPORTOMARGINE.Styles.Content := DM1.tvGCDetailContent_Ricarico_Bold;
      tvCorpoIMPORTOMARGINE.Styles.Footer := DM1.tvGCDetailContent_Ricarico_Bold;
      // TBodyView.vacExt3
      tvCorpoIMPORTORIGO.Styles.Content := DM1.tvGCDetailContent_Vendita_Bold;
      tvCorpoIMPORTORIGO.Styles.Footer := DM1.tvGCDetailContent_Vendita_Bold;
      // TBodyView.vacExt4
      tvCorpoIMPORTORIGOIVACOMPRESA.Styles.Content := DM1.tvGCDetailContent_Vendita_Bold;
      tvCorpoIMPORTORIGOIVACOMPRESA.Styles.Footer := DM1.tvGCDetailContent_Vendita_Bold;
      // TBodyView.vacExt5
      tvCorpoMARGINE.Styles.Content := DM1.tvGCDetailContent_Ricarico_Bold;
      tvCorpoMARGINE.Styles.Footer := DM1.tvGCDetailContent_Ricarico_Bold;
    end;

    if FBodyView < TBodyView.vacFull then
    begin
      tvCorpoPREZZOUNITARIO.Styles.Content := nil;
      // tvCorpoPREZZOUNITARIO.Styles.Footer := nil;
      tvCorpoPREZZOUNITARIOIVACOMPRESA.Styles.Content := nil;
      tvCorpoPREZZOUNITARIOIVACOMPRESA.Styles.Footer := nil;
      tvCorpoPRZUNITNETTO.Styles.Content := nil;
      tvCorpoPRZUNITNETTO.Styles.Footer := nil;
      tvCorpoPREZZOACQUISTOARTICOLO.Styles.Content := nil;
      tvCorpoPREZZOACQUISTOARTICOLO.Styles.Footer := nil;
    end
    else
    begin
      tvCorpoPREZZOUNITARIO.Styles.Content := DM1.tvGCDetailContent_Vendita_Bold;
      // tvCorpoPREZZOUNITARIO.Styles.Footer := DM1.tvGCDetailContent_Vendita_Bold;
      tvCorpoPREZZOUNITARIOIVACOMPRESA.Styles.Content := DM1.tvGCDetailContent_Vendita_Bold;
      tvCorpoPREZZOUNITARIOIVACOMPRESA.Styles.Footer := DM1.tvGCDetailContent_Vendita_Bold;
      tvCorpoPRZUNITNETTO.Styles.Content := DM1.tvGCDetailContent_Vendita_Bold;
      tvCorpoPRZUNITNETTO.Styles.Footer := DM1.tvGCDetailContent_Vendita_Bold;
      tvCorpoPREZZOACQUISTOARTICOLO.Styles.Content := DM1.tvGCDetailContent_Costo_Bold;
      tvCorpoPREZZOACQUISTOARTICOLO.Styles.Footer := DM1.tvGCDetailContent_Costo_Bold;
    end;

  finally
    GridCorpo.EndUpdate;
  end;
end;

// Procedura che assegna il GUID al rigo di manodopera ricevuto come parametro
// NB: Ovviamente solo se il rigo non ha già un GUID
procedure TPreventiviOrdiniForm.SetOperaRowGUID(DC: TcxCustomDataController; Row: Integer);
begin
  // Solo se  il rigo non ha già il GUID
  // Assegna un nuovo GUID al rigo
  if VarIsNull(DC.Values[Row, tvOreGUID.Index]) then
    DC.Values[Row, tvOreGUID.Index] := DM1.GUIDAsString;
  // Se il GUID_REF è nullo gli assegna lo stesso GUID
  if VarIsNull(DC.Values[Row, tvOreGUID_REF.Index]) then
    DC.Values[Row, tvOreGUID_REF.Index] := DC.Values[Row, tvOreGUID.Index];
end;

procedure TPreventiviOrdiniForm.AbilitaPanelloVariazioneMargine(Abilita: Boolean);
begin
  // Abilita o disabilita (in base al parametro il pannello
  ButtonApplicaVariazioni.Enabled := Abilita;
  EditVariazioneMargine.Properties.ReadOnly := not Abilita;
  EditVariazioneOpera1.Properties.ReadOnly := not Abilita;
  EditVariazioneOpera2.Properties.ReadOnly := not Abilita;
  EditVariazioneOpera3.Properties.ReadOnly := not Abilita;
  EditVariazioneOpera4.Properties.ReadOnly := not Abilita;
  EditVariazioneOpera5.Properties.ReadOnly := not Abilita;
  // Abilita /Disabilita gli Slider
  if Abilita then
    TBVariazioneMargine.Style.LookAndFeel.Kind := lfUltraFlat
  else
    TBVariazioneMargine.Style.LookAndFeel.Kind := lfFlat;
  // Azzera i valori dei campi
  EditVariazioneMargine.Text := '';
  TBVariazioneMargine.Position := 0;
end;

procedure TPreventiviOrdiniForm.ProcessBarcode(Barcode: String);
var
  TipoCodice, TipoDocumento, DocTipo, DocReg: String;
  TmpInt, DocNum: Integer;
  DocData: TDateTime;
begin
  // NB: HO tolto ShowWait perchè altrimenti su Vista quando si leggeva
  // un codice a barre l'applicazione perdeva il focus e mi causava problemi
  // DM1.ShowWait('Levante', 'Elaborazione codice a barre...');
  DM1.Attendere;
  try
    // Ricava il tipo di codice letto
    TipoCodice := LeftStr(Barcode, 1);
    // In base al tipo di codice letto...
    if (TipoCodice = BARCODE_TIPOCODICE_DOCUMENTO) then
    begin
      // =========================================================================
      // DOCUMENTI
      // -------------------------------------------------------------------------
      // Ricava il tipo di documento letto
      TipoDocumento := Barcode[2];
      // Se è stato letto un INTERVENTO/CHIAMATA/APPUNTAMENTO
      // if (TipoDocumento = BARCODE_DOC_INTERVENTO) then begin

      // #########

      // Se invece è un altro tipo di documento...
      // end else begin

      // Se non siamo in modalità di modifica esce subito
      if not RxSpeedModifica.Down then
      begin
        DM1.Messaggi('Levante', 'Il documento non è in modalità di modifica.', '', [mbOk], 0, nil);
        Exit;
      end;
      // Carica il alcune variabili locali i dati di identificazione del documento
      DM1.DocBarCodeToDocData(Barcode, DocTipo, DocNum, DocReg, DocData);
      if DocTipo = '' then
        raise Exception.Create('Documento non trovato!');
      // Esporta in bacheca il documento
      DM1.EsportaDocFisc(DocTipo, DocReg, DocNum, DocData);
      // Importa il documento appena importato
      ImportaDocFisc(DocTipo, DocReg, DocNum, DocData, RifEnabled, False);

      // end;
      // =========================================================================
    end;
  finally
    // DM1.CloseWait;
    DM1.ChiudiAttendere;
  end;
end;

// Visualizza la scheramata iniziale che richiede esplicitamente alcuni dati del
// documento
procedure TPreventiviOrdiniForm.VisualizzaRichiestaDatiInizialiDocumento;
begin
  Application.CreateForm(TBeforeNewDocForm, BeforeNewDocForm);
  BeforeNewDocForm.Show;
end;

// Carica nell'apposita variabile lo sconto presente nell'anagrafica del soggetto
// intestatario del documento
procedure TPreventiviOrdiniForm.CaricaScontoSoggetto;
var
  QryCli: TIB_Cursor;
begin
  // Inizializzazione
  ScontoSoggetto := 0;
  // Carica i dati del cliente
  QryCli := TIB_Cursor.Create(Self);
  try
    if (not QryDocumentoCODICECLIENTE.IsNull) and (QryDocumentoCODICECLIENTE.AsString <> '') then
    begin
      QryCli.DatabaseName := DM1.ArcDBFile;
      QryCli.IB_Connection := DM1.DBAzienda;
      QryCli.SQL.Add('SELECT Sconto FROM Clienti WHERE Codice = ' + QryDocumentoCODICECLIENTE.AsString);
      QryCli.Open;
      // Carica i dati l'indirizzo del cliente come destinazione merci del documento attuale
      if not QryCli.Eof then
      begin
        ScontoSoggetto := QryCli.Fields[0].AsFloat;
      end;
    end;
  finally
    QryCli.Close;
    QryCli.Free;
  end;
end;

// Carica le items delle combo box dei sottocantieri
// Carica le items delle combo box dei sottocantieri
procedure TPreventiviOrdiniForm.CaricaItemsSottocantieriDatiRigo;
begin
  if not Assigned(DatiRigoForm) then
    Exit;
  // Carica le Item s dei combobox dei sottocantieri
  DatiRigoForm.eSottocant1.Properties.Items := (tvCorpoSOTTOCANTIERE1.Properties as TcxComboBoxProperties).Items;
  DatiRigoForm.eSottocant2.Properties.Items := (tvCorpoSOTTOCANTIERE2.Properties as TcxComboBoxProperties).Items;
  DatiRigoForm.eSottocant3.Properties.Items := (tvCorpoSOTTOCANTIERE3.Properties as TcxComboBoxProperties).Items;
  DatiRigoForm.eSottocant4.Properties.Items := (tvCorpoSOTTOCANTIERE4.Properties as TcxComboBoxProperties).Items;
  DatiRigoForm.eSottocant5.Properties.Items := (tvCorpoSOTTOCANTIERE5.Properties as TcxComboBoxProperties).Items;
  DatiRigoForm.eSottocant6.Properties.Items := (tvCorpoSOTTOCANTIERE6.Properties as TcxComboBoxProperties).Items;
end;

// Carica le items delle combo box dei Tipi di Righi
procedure TPreventiviOrdiniForm.CaricaItemsTipiRighiDatiRigo;
begin
  if not Assigned(DatiRigoForm) then
    Exit;
  // Carica le Item s dei combobox dei sottocantieri
  DatiRigoForm.eTipo1.Properties.Items := (tvCorpoTIPO1.Properties as TcxComboBoxProperties).Items;
  DatiRigoForm.eTipo2.Properties.Items := (tvCorpoTIPO2.Properties as TcxComboBoxProperties).Items;
  DatiRigoForm.eTipo3.Properties.Items := (tvCorpoTIPO3.Properties as TcxComboBoxProperties).Items;
  DatiRigoForm.eTipo4.Properties.Items := (tvCorpoTIPO4.Properties as TcxComboBoxProperties).Items;
  DatiRigoForm.eTipo5.Properties.Items := (tvCorpoTIPO5.Properties as TcxComboBoxProperties).Items;
  DatiRigoForm.eTipo6.Properties.Items := (tvCorpoTIPO6.Properties as TcxComboBoxProperties).Items;
end;

// Aggiorna i dati relativi ai righi del documento nella form laterale
procedure TPreventiviOrdiniForm.AggiornaDatiRigoForm(DS: TDataSet);
const
  EMPTY_VALUE = '- - -';
var
  i, RI: Integer;
  GW: TcxGridTableView;
begin
  // Prima di tutto verifica se la form da aggiornare esiste oppure no
  if DatiRigoForm = nil then
    Exit;

  // Inizializzazione variabili locali per comodità
  GW := (GridCorpo.FocusedView as TcxGridTableView);
  if DatiRigoForm.cbDatiRigoOff.Checked or not Assigned(GW.Controller.FocusedRecord) then
  begin
    DatiRigoForm.dxLayoutControl1.Visible := False;
    Exit;
  end;

  RI := GW.Controller.FocusedRecord.RecordIndex;

  // Prosegue solo se la vista attiva è quella principale
  // Se non c'è alcun rigo con il focus azzera i campi dei dati e li disabilita.
  // Anche se siamo su un rigo di riferimento
  // if (not(GridCorpo.FocusedView = tvCorpo))
  if (GW.Controller.FocusedRecordIndex = -1) or ((DM1.NoNullIntValue(GW.DataController, RI, tvCorpoCODICEIVA.Index) = -9) and
    (DM1.StrLeft(DM1.NoNullStringValue(GW.DataController, RI, tvCorpoDESCRIZIONE.Index), 4) = '--->') and (GW.Controller.SelectedRecordCount < 2)) then
  begin
    DatiRigoForm.dxLayoutControl1.Visible := False;
    Exit;
  end
  else
    DatiRigoForm.dxLayoutControl1.Visible := True;

  // Disabilita gli eventi OnChange nella form
  DatiRigoForm.OnChangeEventEnabled := False;
  // Inizia ad impostare i valori dei campi
  try
    // Abilita i controlli se il dataset è in modalità di editing
    DatiRigoForm.dxLayoutControl1.Enabled := (DS.State <> dsBrowse);
    // Cicla per tutti i righi selezionati
    for i := 0 to GW.Controller.SelectedRecordCount - 1 do
    begin
      with GW.Controller.SelectedRecords[i] do
      begin
        if not GW.Controller.SelectedRecords[i].IsData then
          Continue;
        // Caricamento dati
        DatiRigoForm.eCodiceArticolo.Text := DisplayTexts[tvCorpoCODICEARTICOLOSTM.Index];
        DatiRigoForm.eDescrizione.Text := DisplayTexts[tvCorpoDESCRIZIONE.Index];
        DatiRigoForm.ePrezzoUnitario.Text := DisplayTexts[tvCorpoPREZZOUNITARIO.Index];
        DatiRigoForm.ePrzUnitIvaComp.Text := DisplayTexts[tvCorpoPREZZOUNITARIOIVACOMPRESA.Index];
        DatiRigoForm.eSconto1.Text := DisplayTexts[tvCorpoSCONTORIGO.Index];
        DatiRigoForm.eSconto2.Text := DisplayTexts[tvCorpoSCONTORIGO2.Index];
        DatiRigoForm.eSconto3.Text := DisplayTexts[tvCorpoSCONTORIGO3.Index];
        DatiRigoForm.eUM.Text := DisplayTexts[tvCorpoUNITADIMISURA.Index];
        DatiRigoForm.eQta.Text := DisplayTexts[tvCorpoQTA.Index];
        DatiRigoForm.eImportoRigo.Text := DisplayTexts[tvCorpoIMPORTORIGO.Index];
        DatiRigoForm.eImportoRigoIvaComp.Text := DisplayTexts[tvCorpoIMPORTORIGOIVACOMPRESA.Index];
        DatiRigoForm.eDescrizioneIVA.Text := DisplayTexts[tvCorpoDESCRIZIONEIVA.Index];
        DatiRigoForm.eCostoUNitario.Text := DisplayTexts[tvCorpoPREZZOACQUISTOARTICOLO.Index];
        DatiRigoForm.eRicarico.Text := DisplayTexts[tvCorpoMARGINE.Index];
        DatiRigoForm.eRicaricoImporto.Text := DisplayTexts[tvCorpoIMPORTOMARGINE.Index];

        DatiRigoForm.eIDApparecchio.EditValue := Values[tvCorpoIDAPPARECCHIO.Index];

        DatiRigoForm.eSottocant1.Text := DisplayTexts[tvCorpoSOTTOCANTIERE1.Index];
        DatiRigoForm.eSottocant2.Text := DisplayTexts[tvCorpoSOTTOCANTIERE2.Index];
        DatiRigoForm.eSottocant3.Text := DisplayTexts[tvCorpoSOTTOCANTIERE3.Index];
        DatiRigoForm.eSottocant4.Text := DisplayTexts[tvCorpoSOTTOCANTIERE4.Index];
        DatiRigoForm.eSottocant5.Text := DisplayTexts[tvCorpoSOTTOCANTIERE5.Index];
        DatiRigoForm.eSottocant6.Text := DisplayTexts[tvCorpoSOTTOCANTIERE6.Index];

        DatiRigoForm.eTipo1.Text := DisplayTexts[tvCorpoTIPO1.Index];
        DatiRigoForm.eTipo2.Text := DisplayTexts[tvCorpoTIPO2.Index];
        DatiRigoForm.eTipo3.Text := DisplayTexts[tvCorpoTIPO3.Index];
        DatiRigoForm.eTipo4.Text := DisplayTexts[tvCorpoTIPO4.Index];
        DatiRigoForm.eTipo5.Text := DisplayTexts[tvCorpoTIPO5.Index];
        DatiRigoForm.eTipo6.Text := DisplayTexts[tvCorpoTIPO6.Index];

        DatiRigoForm.eNoteRigo.Text := DisplayTexts[tvCorpoNOTERIGO.Index];

        DatiRigoForm.eRowSection.Text := DisplayTexts[tvCorpoROWSECTION.Index];
        DatiRigoForm.eRowType.Text := DisplayTexts[tvCorpoROWTYPE.Index];
        DatiRigoForm.ePrezzoUnitarioAutocalc.Checked := (DisplayTexts[tvCorpoPREZZOUNITARIOAUTOCALC.Index] = 'True');
        DatiRigoForm.eRowPrintPrices.Checked := (DisplayTexts[tvCorpoROWPRINTPRICES.Index] = 'True');

        DatiRigoForm.eADG_TipoDato.Text := DisplayTexts[tvCorpoADG1_TIPODATO.Index];
        DatiRigoForm.eADG_RiferimentoTesto.Text := DisplayTexts[tvCorpoADG1_RIFERIMENTOTESTO.Index];
        DatiRigoForm.eADG_RiferimentoNumero.Text := DisplayTexts[tvCorpoADG1_RIFERIMENTONUMERO.Index];
        DatiRigoForm.eADG_RiferimentoData.Text := DisplayTexts[tvCorpoADG1_RIFERIMENTODATA.Index];
      end;
    end;
    // Se gli sconti sono a 0 (zero) li visualizza vuoti
    // if DatiRigoForm.eSconto1.Text = '0' then DatiRigoForm.eSconto1.Text := '';
    // if DatiRigoForm.eSconto2.Text = '0' then DatiRigoForm.eSconto2.Text := '';
    // if DatiRigoForm.eSconto3.Text = '0' then DatiRigoForm.eSconto3.Text := '';
  finally
    // Ripristina gli eventi OnChange nella form
    DatiRigoForm.OnChangeEventEnabled := True;
  end;
end;

procedure TPreventiviOrdiniForm.ControllaSeTuttiRighiImportExport;
var
  TuttiImportati, TuttiEsportati: Boolean;
  i: Integer;
  DC: TcxCustomDataController;
  PV: String;
begin
  // Questa procedura effettua la verifica se il documento è aggiornato  con la situazione dei righi
  // praticamente se l'utente ha, ad esempio, se l'utente ha esportato tutti i righi da dentro il documento
  // (non dall'elenco dei documenti) tutti i righi verrebbero marcati come Exported ma la testata del documento
  // no, questa procedura rimedia proprio a questo problema.
  // -----------------------------------------------------------------------------------------------------------
  // Se il documento è già marcato come Importato + Exportato ovviamente non fà nulla ed esce subito
  // NB: Disabilitato perchè se uno ad esempio aggiunge una articolo non ancora importato o esportato
  // altrimenti il documento rimarrebbe come tutto Importato o esportato e questo non mi sembra corretto.
  // if QryDocumentoSELEZIONATO.AsString = FLAG_VALUE_IMPORTED_EXPORTED then Exit;
  // Inizializzazione
  TuttiImportati := True;
  TuttiEsportati := True;
  DC := tvCorpo.DataController;
  PV := QryDocumentoSELEZIONATO.AsString;
  i := 0;
  // Cicla per tutti i righi per effettuare il controllo
  while (i < DC.RecordCount) and (TuttiImportati or TuttiEsportati) do
  begin
    TuttiImportati := TuttiImportati and ((DC.DisplayTexts[i, tvCorpoSELEZIONATO.Index] = FLAG_VALUE_IMPORTED) or
      (DC.DisplayTexts[i, tvCorpoSELEZIONATO.Index] = FLAG_VALUE_IMPORTED_EXPORTED));
    TuttiEsportati := TuttiEsportati and ((DC.DisplayTexts[i, tvCorpoSELEZIONATO.Index] = FLAG_VALUE_EXPORTED) or
      (DC.DisplayTexts[i, tvCorpoSELEZIONATO.Index] = FLAG_VALUE_IMPORTED_EXPORTED));
    Inc(i, 1);
  end;
  // Se il caso marca il documento come importato o esportato
  if TuttiImportati and TuttiEsportati then
  begin
    // Se tutti i righi sono sia importati che esportati marca and il documento come tale
    PV := FLAG_VALUE_IMPORTED_EXPORTED;
  end
  else if TuttiImportati then
  begin
    // Se tutti i righi sono importati marca and il documento come tale
    if PV = FLAG_VALUE_EXPORTED then
      PV := FLAG_VALUE_IMPORTED_EXPORTED
    else
      PV := FLAG_VALUE_IMPORTED;
  end
  else if TuttiEsportati then
  begin
    // Se tutti i righi sono importati marca and il documento come tale
    if PV = FLAG_VALUE_IMPORTED then
      PV := FLAG_VALUE_IMPORTED_EXPORTED
    else
      PV := FLAG_VALUE_EXPORTED;
  end
  else
  begin
    // Se c'è almeno un rigo senza essere ne importato ne esportato smarca il documento
    PV := '';
  end;
  // Aggiorna il campo
  QryDocumentoSELEZIONATO.Value := PV;
end;

procedure TPreventiviOrdiniForm.MarcaImportExport(DC: TcxCustomDataController; RI, CI: Integer; V: String);
var
  T: String;
  Qry: TIB_Cursor;
begin
  Qry := TIB_Cursor.Create(Self);
  try
    // Se il campo è nullo lo crea come stringa vuota di 3 caratteri
    // T contiene il valroe del campo
    if VarIsNull(DC.Values[RI, CI]) then
      T := ' '
    else
      T := DC.Values[RI, CI];
    // Se la stringa ha una lunghezza inferiore la adegua
    if T = '' then
      T := ' ';
    // Ovviamente se il rigo/documento è già Imported+Exported non occorre fare nulla ed esce subito
    if T = FLAG_VALUE_IMPORTED_EXPORTED then
      Exit;
    // Aggiorna il valore del Flag
    if V = FLAG_VALUE_IMPORTED then
    begin
      // Se era già anche Exported lo marca come Imported_Exported altrimenti solo come Imported
      if T = FLAG_VALUE_EXPORTED then
        T := FLAG_VALUE_IMPORTED_EXPORTED
      else
        T := FLAG_VALUE_IMPORTED;
    end
    else if V = FLAG_VALUE_EXPORTED then
    begin
      // Se era già anche Imported lo marca come Imported_Exported altrimenti solo come Exported
      if T = FLAG_VALUE_IMPORTED then
        T := FLAG_VALUE_IMPORTED_EXPORTED
      else
        T := FLAG_VALUE_EXPORTED;
    end
    else if V = FLAG_VALUE_IMPORTED_EXPORTED then
    begin
      // IMposta il rigo Imported+Exported
      T := FLAG_VALUE_IMPORTED_EXPORTED;
    end;
    // Aggiorna il campo
    DC.Values[RI, CI] := T;
    // IMpostazione della query che aggiornerà lo stato di importazione/esportazione del rigo.
    // NB: Solo se il documento non è in modifica perchè prima di tutto è inutile, poi in questo modo
    // se l'operatore non conferma le modifiche il programma ripristina lo stato precedente del
    // documento in modo corretto, se invece aggiorno qui sotto direttamente il database, il rigo
    // non verrebbe ripristinato allo stato di prima delle modifiche.
    if not RxSpeedModifica.Down then
    begin
      Qry.DatabaseName := DM1.ArcDBFile;
      Qry.IB_Connection := DM1.DBAzienda;
      Qry.SQL.Add('UPDATE RIGHIPRV SET SELEZIONATO = ''' + T + '''');
      Qry.SQL.Add('WHERE TIPODOCUMENTO = ''' + TipoDoc + '''');
      Qry.SQL.Add('  AND REGISTRO = ''' + Registro + '''');
      Qry.SQL.Add('  AND NUMORDPREV = ' + IntToStr(NumeroDoc));
      Qry.SQL.Add('  AND DATADOCUMENTO = ''' + FormatDateTime('mm/dd/yyyy', DataDoc) + '''');
      Qry.SQL.Add('  AND PROGRIGO = ' + IntToStr(RI));
      Qry.ExecSQL;
    end;
  finally
    Qry.Free;
  end;
end;

procedure TPreventiviOrdiniForm.EsplodiArticoloComposto(MDC: TcxCustomDataController; MRI: Integer);
var
  DDC: TcxCustomDataController;
  NRI: Integer; // NRI = NewRecordIndex
begin
  // Questa procedura si occupa di esplodere un articolo composto in modo che tutti i sottorighi
  // di un articolo composto diventino righi principali (compresa la manodopera) e il rigo
  // principale sparisce. Per fare questo prima copia tutti i sottorighi e la manodopera
  // nel DataController principale inserendoli (Insert) subito dopo il rigo principale e poi
  // provvede ad eliminare il rigo principale stesso.
  // NB: I righi composti generano sempre righi di manodopera del primo tipo
  // -------------------------------------------------------------------------------------------
  // Se non è un rigo con sottorighi esce subito
  if not DM1.CheckIfExpandable(MDC, MRI, False) then
    Exit;
  // DDC Punta al DataController dei sottorighi del rigo corrente
  DDC := MDC.GetDetailDataController(MRI, RELATION_IDX_SOTTORIGHI_NORMALI);
  // Prima controlla che i rigo contenga dei sottirighi, se non li contiene non fà nulla
  if DDC.RecordCount > 0 then
  begin
    // Copia tutti i sottorighi nel DataController principale
    DM1.CopyAllRowsDevExpress(DDC, MDC, MRI + 1, DM1.NoNullFloatValue(MDC, MRI, tvCorpoQTA.Index), tvCorpoQTA.Index);
    // Elimina il rigo principale
    MDC.DeleteRecord(MRI);
  end;
end;

procedure TPreventiviOrdiniForm.RefreshImpostazioniColonne;
var
  tvi: Integer;
  procedure InternalRefreshImpostazioniColonne(const TV: TcxGridTableView);
  var
    i, X: Integer;
    cc: TcxGridColumn;
  begin
    TV.BeginUpdate;
    // Azzera la variabile che conterrà l'occupazione di tutte le colonne tranne l'ultima
    X := 0;
    try
      // Cicla per tutte le colonne tranne l'ultima
      for i := 0 to tvDiBa.ColumnCount - 1 do
      begin
        // cc è la colonna corrente
        cc := TV.Columns[i];
        // IMposta le colonne della Distinta base con le stesse dimensioni dalla Masterview
        cc.RepositoryItem := tvCorpo.Columns[cc.Index].RepositoryItem;
        cc.Caption := tvCorpo.Columns[cc.Index].Caption;
        cc.AlternateCaption := tvCorpo.Columns[cc.Index].AlternateCaption;
        cc.MinWidth := tvCorpo.Columns[cc.Index].MinWidth;
        cc.Width := tvCorpo.Columns[cc.Index].Width;
        cc.HeaderAlignmentHorz := tvCorpo.Columns[cc.Index].HeaderAlignmentHorz;
        cc.OnCustomDrawCell := tvCorpo.Columns[cc.Index].OnCustomDrawCell;
        // Se la colonna attuale non è editabile rende non editabile anche la stessa
        // colonna di dettaglio
        if not tvCorpo.Columns[i].Options.Editing then
          cc.Options.Editing := False;
        // if assigned(tvCorpo.Columns[cc.Index].RepositoryItem) then
        // cc.RepositoryItem := tvCorpo.Columns[cc.Index].RepositoryItem;
        // Siccome c'era un piccolo discostamento orizzontale tra le colonne dei dettagli
        // e la master row riduco leggermente la larghezza della prima colonna visibile
        // per correggere
        // if i = 0 then
        // cc.Width := cc.Width - 1;
        // Aggiorna l'occupazione totale delle colonne
        Inc(X, cc.Width);
      end;
      // L'ultima colonna visibile devve occupare tutta l'area libera restante
      // cc.Width := cc.Width + (GridCorpo.Width - X - 36);
    finally
      TV.EndUpdate;
    end;
  end;

begin
  // Questa procedura fà in modo che la sottogriglia della DistintaBase abbia le colonne
  // delle stesse dimnsioni della griglia principale
  // -------------------------------------------------------------------------------------
  // Cicla per tutti i Cloni della View della DistintaBase
  // tv Punta alla CloneView corrente
  InternalRefreshImpostazioniColonne(tvDiBa);
  for tvi := 0 to tvDiBa.CloneCount - 1 do
    InternalRefreshImpostazioniColonne(tvDiBa.Clones[tvi] as TcxGridTableView);
end;

procedure TPreventiviOrdiniForm.ImpostaNomiTabelle;
begin
  // Questa funzione imposta i nomi delle tabelle in base al Flag DistintaBase
  if DistintaBase then
  begin
    // IMposta i nome delle tabelle per la modalità normale
    TestateTable := 'DIBATESTATE';
    RighiTable := 'DIBARIGHI';
  end
  else
  begin
    // IMposta i nome delle tabelle per la modalità normale
    TestateTable := 'PRVORDCL';
    RighiTable := 'RIGHIPRV';
  end;
  // Modifica le prime righe delle query del componente Update
  QryDocumento.DeleteSQL[0] := 'DELETE FROM ' + TestateTable;
  QryDocumento.InsertSQL[0] := 'INSERT INTO ' + TestateTable;
  QryDocumento.EditSQL[0] := 'UPDATE ' + TestateTable + ' SET';
end;

procedure TPreventiviOrdiniForm.ControllaVisualizzazioneCastellettoIVA;
begin
  // Questa procedura fà in modo che siano visibili solo i righi del castelletto IVA
  // che non sono vuoti
  // --------------------------------------------------------------------------
  // Rigo IVA 1
  if QryDocumentoTOTALEIMPONIBILE1.AsFloat <> 0 then
  begin
    TotaleMerce11.Visible := True;
    TotaleMerce12.Visible := True;
    TotaleMerce13.Visible := True;
    Sconto11.Visible := True;
    Sconto12.Visible := True;
    Sconto13.Visible := True;
    Imponibile11.Visible := True;
    Imponibile12.Visible := True;
    Imponibile13.Visible := True;
    DescIVA11.Visible := True;
    DescIVA12.Visible := True;
    DescIVA13.Visible := True;
    ImportoIVA11.Visible := True;
    ImportoIVA12.Visible := True;
    ImportoIVA13.Visible := True;
  end
  else
  begin
    TotaleMerce11.Visible := False;
    TotaleMerce12.Visible := False;
    TotaleMerce13.Visible := False;
    Sconto11.Visible := False;
    Sconto12.Visible := False;
    Sconto13.Visible := False;
    Imponibile11.Visible := False;
    Imponibile12.Visible := False;
    Imponibile13.Visible := False;
    DescIVA11.Visible := False;
    DescIVA12.Visible := False;
    DescIVA13.Visible := False;
    ImportoIVA11.Visible := False;
    ImportoIVA12.Visible := False;
    ImportoIVA13.Visible := False;
  end;
  // Rigo IVA 2
  if QryDocumentoTOTALEIMPONIBILE2.AsFloat <> 0 then
  begin
    TotaleMerce21.Visible := True;
    TotaleMerce22.Visible := True;
    TotaleMerce23.Visible := True;
    Sconto21.Visible := True;
    Sconto22.Visible := True;
    Sconto23.Visible := True;
    Imponibile21.Visible := True;
    Imponibile22.Visible := True;
    Imponibile23.Visible := True;
    DescIVA21.Visible := True;
    DescIVA22.Visible := True;
    DescIVA23.Visible := True;
    ImportoIVA21.Visible := True;
    ImportoIVA22.Visible := True;
    ImportoIVA23.Visible := True;
  end
  else
  begin
    TotaleMerce21.Visible := False;
    TotaleMerce22.Visible := False;
    TotaleMerce23.Visible := False;
    Sconto21.Visible := False;
    Sconto22.Visible := False;
    Sconto23.Visible := False;
    Imponibile21.Visible := False;
    Imponibile22.Visible := False;
    Imponibile23.Visible := False;
    DescIVA21.Visible := False;
    DescIVA22.Visible := False;
    DescIVA23.Visible := False;
    ImportoIVA21.Visible := False;
    ImportoIVA22.Visible := False;
    ImportoIVA23.Visible := False;
  end;
  // Rigo IVA 3
  if QryDocumentoTOTALEIMPONIBILE3.AsFloat <> 0 then
  begin
    TotaleMerce31.Visible := True;
    TotaleMerce32.Visible := True;
    TotaleMerce33.Visible := True;
    Sconto31.Visible := True;
    Sconto32.Visible := True;
    Sconto33.Visible := True;
    Imponibile31.Visible := True;
    Imponibile32.Visible := True;
    Imponibile33.Visible := True;
    DescIVA31.Visible := True;
    DescIVA32.Visible := True;
    DescIVA33.Visible := True;
    ImportoIVA31.Visible := True;
    ImportoIVA32.Visible := True;
    ImportoIVA33.Visible := True;
  end
  else
  begin
    TotaleMerce31.Visible := False;
    TotaleMerce32.Visible := False;
    TotaleMerce33.Visible := False;
    Sconto31.Visible := False;
    Sconto32.Visible := False;
    Sconto33.Visible := False;
    Imponibile31.Visible := False;
    Imponibile32.Visible := False;
    Imponibile33.Visible := False;
    DescIVA31.Visible := False;
    DescIVA32.Visible := False;
    DescIVA33.Visible := False;
    ImportoIVA31.Visible := False;
    ImportoIVA32.Visible := False;
    ImportoIVA33.Visible := False;
  end;
  // Rigo IVA 4
  if QryDocumentoTOTALEIMPONIBILE4.AsFloat <> 0 then
  begin
    TotaleMerce41.Visible := True;
    TotaleMerce42.Visible := True;
    TotaleMerce43.Visible := True;
    Sconto41.Visible := True;
    Sconto42.Visible := True;
    Sconto43.Visible := True;
    Imponibile41.Visible := True;
    Imponibile42.Visible := True;
    Imponibile43.Visible := True;
    DescIVA41.Visible := True;
    DescIVA42.Visible := True;
    DescIVA43.Visible := True;
    ImportoIVA41.Visible := True;
    ImportoIVA42.Visible := True;
    ImportoIVA43.Visible := True;
  end
  else
  begin
    TotaleMerce41.Visible := False;
    TotaleMerce42.Visible := False;
    TotaleMerce43.Visible := False;
    Sconto41.Visible := False;
    Sconto42.Visible := False;
    Sconto43.Visible := False;
    Imponibile41.Visible := False;
    Imponibile42.Visible := False;
    Imponibile43.Visible := False;
    DescIVA41.Visible := False;
    DescIVA42.Visible := False;
    DescIVA43.Visible := False;
    ImportoIVA41.Visible := False;
    ImportoIVA42.Visible := False;
    ImportoIVA43.Visible := False;
  end;
end;

procedure TPreventiviOrdiniForm.ControllaVisualizzazioneSplitPayment(const ARicalcola: Boolean);
begin
  // Se abilitato e necessario ricalcola i totali del documento
  if ARicalcola then
    CalcolaTotali(False);

  if IsSplitPayment then
  begin
    LabelSplitPayment.Visible := True;
    dbeSplitPayment.Visible := True;
    ShapeSplitPayment.Visible := True;
  end
  else
  begin
    LabelSplitPayment.Visible := False;
    dbeSplitPayment.Visible := False;
    ShapeSplitPayment.Visible := False;
  end;
end;

procedure TPreventiviOrdiniForm.AggiornaLabelTipoDocumento;
begin
  MainForm.LabelTipoDocumento.Caption := TipoDoc;
  MainForm.LabelTipoDocumento.Visible := True;
  MainForm.SBTipoDocumento.Visible := True;
end;

procedure TPreventiviOrdiniForm.Aggiornaledescrizionidallelencoarticoli1Click(Sender: TObject);
begin
  if DM1.Messaggi('Aggiorna descrizioni articoli', 'Confermi di voler aggiornare le descrizione articoli di tutto il documento?', '', [mbYes, mbNo], 0, nil) <> mrYes
  then
    Exit;
  DM1.ShowWait('Aggiorna descrizioni articoli', 'Operazione in corso...');
  try
    tvCorpo.Controller.SelectAllRecords;
    AggiornaDescrizioniArticoliRighiSelezionati(tvCorpo);
    tvCorpo.Controller.ClearSelection;
  finally
    DM1.CloseWait;
  end;
end;

procedure TPreventiviOrdiniForm.DisableLabelTipoDocumento;
begin
  MainForm.LabelTipoDocumento.Caption := '';
  MainForm.LabelTipoDocumento.Visible := False;
  MainForm.SBTipoDocumento.Visible := False;
end;

procedure TPreventiviOrdiniForm.CaricaAliquotaIVADefaultDocumento;
var
  Qry: TIB_Cursor;
  CodIvaCli: Integer;
begin
  // Inizializzazioner
  CodIvaCli := DM1.GetCodiceIvaCli(QryDocumentoCODICECLIENTE.AsInteger);
  // Se l'aliquota IVA forzata del documento è specificata, usa questa aliquota IVA per qualunque articolo
  // fregandosene di altre impostazioni
  if (not QryDocumentoCODICEIVAFORZATA.IsNull) and (QryDocumentoCODICEIVAFORZATA.AsInteger <> 0) then
  begin
    DocIvaDefault.Codice := QryDocumentoCODICEIVAFORZATA.AsInteger;
    DocIvaDefault.Descrizione := QryDocumentoDESCRIZIONEIVAFORZATA.AsString;
    DocIvaDefault.AliquotaIVA := QryDocumentoALIQUOTAIVAFORZATA.AsFloat;
    DocIvaDefault.IsDefault := False;
    // Se l'aliquota IVA di default del cliente <> 0 carica nella struttura che contiene i valori dell'aliquota IVA di default
    // tali valori, altrimenti carica i valori dell'aliquota IVA di default del programma in generale.
  end
  else if CodIvaCli <> 0 then
  begin
    // Crea la query per prelevare i valori della tabella delle aliquote IVA
    Qry := TIB_Cursor.Create(Self);
    try
      Qry.DatabaseName := DM1.ArcDBFile;
      Qry.IB_Connection := DM1.DBAzienda;
      Qry.SQL.Add('SELECT CODICEIVA, DESCRIZIONEIVA, ALIQUOTAIVA FROM ALIQIVA WHERE CODICEIVA = ' + IntToStr(CodIvaCli));
      Qry.Open;
      if not Qry.Eof then
      begin
        DocIvaDefault.Codice := Qry.FieldByName('CODICEIVA').Value;
        DocIvaDefault.Descrizione := Qry.FieldByName('DESCRIZIONEIVA').Value;
        DocIvaDefault.AliquotaIVA := Qry.FieldByName('ALIQUOTAIVA').AsFloat;
        DocIvaDefault.IsDefault := False;
      end
      else
      begin
        MessageBeep(0);
        DM1.Messaggi('Informazione', 'A L I Q U O T A   I V A   N O N   T R O V A T A !!!', '', [mbOk], 0, nil);
      end;
    finally
      Qry.Free;
    end;
  end
  else
  begin
    DocIvaDefault.Codice := DEFAULT_CODICE_IVA;
    DocIvaDefault.Descrizione := DEFAULT_DESCRIZIONE_IVA;
    DocIvaDefault.AliquotaIVA := DEFAULT_ALIQUOTA_IVA;
    DocIvaDefault.IsDefault := True;
  end;
end;

procedure TPreventiviOrdiniForm.Caricaarticolidafile1Click(Sender: TObject);
begin
  ImportaArticoliDaFileTxt;
end;

procedure TPreventiviOrdiniForm.AggiornaCondVendArticolo(CodiceArticolo: String; CodiceSoggetto: Longint; TipoDocum: String; Riga: Integer);
var
  i: Integer;
  TotQta, Sc1, Sc2, Sc3, Importo: Real;
  TipoCondVend: String;
begin
  // Inizializzazione
  Sc1 := 0;
  Sc2 := 0;
  Sc3 := 0;
  Importo := -1;
  TotQta := 0;
  // Controlla che le condizioni di vendita siano abilitate e se non lo sono esce subito così
  // non rompe le balle a chi non le usa (alcune volte hanno causato problemi)
  if (DM1.ModCtrl(MOD_CONDIZIONI_VENDITA) > 0) then
  begin
    // Se si tratta di un documento di acquisto imposta la ricerca delle condizioni di acquisto, altrimenti di quelle di vendita.
    if (TipoDoc = 'Bolla_entr') or (TipoDoc = 'Ord.fornit') or (TipoDoc = 'Fatt.acqui') then
    begin
      TipoCondVend := 'Cond.Acqui';
    end
    else
    begin
      TipoCondVend := 'Cond.Vend.';
    end;
    // Depura il codice da eventuali spazi inutili all'inizio e alla fine
    CodiceArticolo := Trim(CodiceArticolo);

    // Disabilita la visualizzazione del controllo per velocizzare le operazioni
    tvCorpo.DataController.BeginUpdate;

    try

      // Cicla per tutti i righi del documento per fare la somma delle Qtà dello stesso articolo
      for i := 0 to tvCorpo.DataController.RecordCount - 1 do
      begin
        // Se il rigo attuale contiene l'articolo cercato provvede ad aggiornare la somma delle Qta
        if Trim(DM1.NoNullStringValue(tvCorpo.DataController, i, tvCorpoCODICEARTICOLO.Index)) = CodiceArticolo then
          TotQta := TotQta + DM1.NoNullFloatValue(tvCorpo.DataController, i, tvCorpoQTA.Index);
      end;

      // Trova le condizioni di vendita dell'articolo del rigo attuale
      DM1.TrovaCondVend(CodiceArticolo, TotQta, CodiceSoggetto, Sc1, Sc2, Sc3, Importo, TipoCondVend);

      // Cicla per tutti i righi del documento per inserire l'importo o gli sconti della condizione di vendita
      // nei righi con lo stesso codicearticolo.
      for i := 0 to tvCorpo.DataController.RecordCount - 1 do
      begin
        // Se il rigo attuale contiene lo stesso codice articolo...
        if Trim(DM1.NoNullStringValue(tvCorpo.DataController, i, tvCorpoCODICEARTICOLO.Index)) = CodiceArticolo then
        begin
          // Se l'importo secco della condizione di vendita è <> -1 (nullo) significa che la
          // condizione di vendita contiene un prezzo secco per l'articolo e quindi importa tale prezzo
          // come prezzo unitario e imposta gli sconti a 0, altrimenti lascia  il prezzo unitario invariato
          // e importa gli sconti.
          if Importo = -1 then
          begin
            // Importa gli sconti se <> da 0
            tvCorpo.DataController.Values[i, tvCorpoSCONTORIGO.Index] := Sc1;
            tvCorpo.DataController.Values[i, tvCorpoSCONTORIGO2.Index] := Sc2;
            tvCorpo.DataController.Values[i, tvCorpoSCONTORIGO3.Index] := Sc3;
          end
          else
          begin
            // IMporta il prezzo unitario secco
            tvCorpo.DataController.Values[i, tvCorpoPREZZOUNITARIO.Index] := DM1.Arrotonda(Importo, DM1.DecMicroPrz);
          end;
          // Esegue alcuni calcoli per calcolare anche i campi dei totali, margine ecc.
          if DM1.ScorporoIVA then
            CalcolaPerModificaPrezzoUnitarioIVACompresa(i, tvCorpo.DataController)
          else
            CalcolaPerModificaPrezzoUnitario(i, tvCorpo.DataController);
          CalcolaImportoRigo(tvCorpo.DataController, i);
        end;
      end;

    finally
      tvCorpo.DataController.EndUpdate;
    end;
    // Se le CV non sono abilitate esegue il solo calcolo dell'importo del rigo
  end
  else
  begin
    CalcolaImportoRigo(tvCorpo.DataController, Riga);
  end;
end;

procedure TPreventiviOrdiniForm.EliminaDocImportato(DocTipo, DocReg: String; DocNum: Longint; DocData: TDate);
var
  Qry: TIB_Cursor;
begin
  Qry := TIB_Cursor.Create(Self);
  try
    Qry.DatabaseName := DM1.GenDBFile;
    Qry.IB_Connection := DM1.DBGenerale;
    Qry.SQL.Add('DELETE FROM TMPRIGHI WHERE');
    Qry.SQL.Add('    TipoDocumento = ''' + DocTipo + '''');
    Qry.SQL.Add('AND Registro = ''' + DocReg + '''');
    Qry.SQL.Add('AND NumOrdPrev = ' + IntToStr(DocNum));
    Qry.SQL.Add('AND DataDocumento = ''' + FormatDateTime('mm/dd/yyyy', DocData) + '''');
    Qry.ExecSQL;
  finally
    Qry.Free;
  end;
end;

procedure TPreventiviOrdiniForm.AggiornaMeseDiCompetenzaFatturazione(DocDate: TDate);
var
  Year, Month, Day: Word;
begin
  // Decodifica la data scomponendola nei suoi elementi
  DecodeDate(DocDate, Year, Month, Day);
  // Ovviamente se il mese è valido
  if (Month > 0) and (Month < 13) then
    QryDocumentoMESECOMPETENZA.Value := Month;
end;

function TPreventiviOrdiniForm.CaricaDocumento(LocTipoDoc, LocRegistro: String; LocNumDoc: Longint; LocDataDoc: TDate): Boolean;
begin
  // Questa funzione imposta la query che apre il documento corrente
  QryDocumento.Close;
  QryDocumento.SQL.Clear;
  QryDocumento.SQL.Add('SELECT T.*, C.TIPOPERSONA, C.NAZIONESIGLA FROM ' + TestateTable + ' T');
  QryDocumento.SQL.Add('LEFT OUTER JOIN CLIENTI C ON (C.CODICE=T.CODICECLIENTE)');
  QryDocumento.SQL.Add('WHERE T.TipoDocumento = ''' + LocTipoDoc + '''');
  QryDocumento.SQL.Add('AND T.Registro = ''' + LocRegistro + '''');
  QryDocumento.SQL.Add('AND T.NumOrdPrev = ' + IntToStr(LocNumDoc));
  QryDocumento.SQL.Add('AND T.DataDocumento = ''' + FormatDateTime('mm/dd/yyyy', LocDataDoc) + '''');
  QryDocumento.Open;
  // Controlla di aver trovato il documento, altrimenti ritorna False
  Result := not QryDocumento.Eof;
  // Se si tratta di una distinta base oppure di un impegno e non la trova la crea al volo
  if (DistintaBase or Self.IsImpegno) and (not Result) then
  begin
    QryDocumento.Append;
    QryDocumentoTIPODOCUMENTO.Value := LocTipoDoc;
    QryDocumentoNUMORDPREV.Value := LocNumDoc;
    QryDocumentoREGISTRO.Value := LocRegistro;
    QryDocumentoDATADOCUMENTO.Value := LocDataDoc;
    QryDocumentoCODICEMAGAZZINO.Value := StrToInt(DM1.MagazzinoDefault);
    // Forza il risultato a True
    Result := True;
  end;
end;

procedure TPreventiviOrdiniForm.CreaScadenzeDocumento; // Personale
type
  TImportiScadenze = array [0 .. 12] of Real;
  TDateScadenze = array [0 .. 12] of TDate;
var
  ImportiScadenze: TImportiScadenze;
  DateScadenze: TDateScadenze;
  TotImponibile, TotIVA, TotDocumento, Rimanente: Real;
  Contatore, Rate, InizioScadGG, IntervalloScadGG, TipoPagIVA: Integer;
  RicevutaBancaria, FineMese: String;
  QryPag, QrySogg, QryScad: TIB_Cursor;
begin
  Rimanente := 0;
  QryPag := TIB_Cursor.Create(Self);
  QrySogg := TIB_Cursor.Create(Self);
  QryScad := TIB_Cursor.Create(Self);
  try
    // Controlla che il documento non abbia già delle scadenze e se non le ha le crea
    // altrimenti si rifiuta.
    if DM1.NumScadenzeDOcumento(QryDocumentoTIPODOCUMENTO.Value, QryDocumentoREGISTRO.Value, QryDocumentoNUMORDPREV.Value, QryDocumentoDATADOCUMENTO.Value) = 0
    then
    begin

      // Verifica che il codice della modalità di pagamento del documento contenga un valore valido altrimenti esce
      if (QryDocumentoPAGAMENTO.IsNull) or (Trim(QryDocumentoPAGAMENTO.AsString) = '') then
      begin
        DM1.Messaggi('Generazione scadenze documento', 'Modalità di pagamento non specificata!'#13#13'NB: Le scadenze non saranno generate.', '',
          [mbOk], 0, nil);
        Exit;
      end;

      // ******** SPOSTAMENTO NELL'ARCHIVIO PAGAMENTI ALLA MODALITA' DEL DOCUMENTO ATTUALE ***********
      QryPag.DatabaseName := DM1.ArcDBFile;
      QryPag.IB_Connection := DM1.DBAzienda;
      QryPag.SQL.Add
        ('SELECT CODICE,RATE,RICEVUTABANCARIA,INIZIOSCADGG,INIZIOSCADFM,INTERVALLOSCADGG,TIPOPAGIVA,PA_CONDIZIONIPAGAMENTOSIGLA,PA_MODALITAPAGAMENTOSICLA FROM PAGAM WHERE CODICE = '
        + QryDocumentoPAGAMENTO.AsString);
      QryPag.Open;
      if not QryPag.Eof then
      begin

        // Carica i dati della modalità di pagamento in alcune variabili locali per comodità ed efficienza
        Rate := QryPag.FieldByName('Rate').AsInteger;
        InizioScadGG := QryPag.FieldByName('InizioScadGG').AsInteger;
        FineMese := QryPag.FieldByName('InizioScadFM').AsString;
        IntervalloScadGG := QryPag.FieldByName('IntervalloScadGG').AsInteger;
        TipoPagIVA := QryPag.FieldByName('TipoPagIVA').AsInteger;

        if QryPag.FieldByName('RicevutaBancaria').IsNull or (QryPag.FieldByName('RicevutaBancaria').AsString <> 'T') then
          RicevutaBancaria := 'F'
        else
          RicevutaBancaria := QryPag.FieldByName('RicevutaBancaria').AsString;

        // IMpostazione della query che preleva alcuni dati del destinatario del documento
        QrySogg.DatabaseName := DM1.ArcDBFile;
        QrySogg.IB_Connection := DM1.DBAzienda;
        QrySogg.SQL.Add
          ('SELECT SALTAMESE1, SALTAMESE2, SALTAMESE3, SALTAMESE4, SALTAMESE5, SALTAMESE6, SALTAMESE7, SALTAMESE8, SALTAMESE9, SALTAMESE10, SALTAMESE11, SALTAMESE12,');
        QrySogg.SQL.Add('       SALTAMESESPOSTAALGIORNO, SPOSTASCADALGIORNO, ADDEBITASPESE');
        QrySogg.SQL.Add('FROM CLIENTI WHERE CODICE = ''' + QryDocumentoCODICECLIENTE.AsString + '''');
        QrySogg.Open;

        // Se il numero delle rate è = 0 esce senza fare nulla
        if Rate = 0 then
          Exit;

        // Calcolo di alcuni totali del documento per comodità successiva.
        // NB: Se il cliente ha la scissione dei pagamenti (split payment)
        // if QrySogg.FieldByName('ESIGIBILITAIVA').AsString = 'S' then
        if IsSplitPayment then
        begin
          TotImponibile := QryDocumentoTOTALEDAPAGARE.Value;
          TotIVA := 0;
          TotDocumento := TotImponibile;
        end
        else
        begin
          TotImponibile := QryDocumentoTOTALEIMPONIBILE.Value;
          TotIVA := QryDocumentoTOTALEIVA.Value;
          TotDocumento := QryDocumentoTOTALEDAPAGARE.Value;
        end;

        // ******** DETERMINAZIONE IMPORTI RATE ***********
        // ---Determinazione importo 1° rata
        case TipoPagIVA of
          // IVA Suddivisa tra le rate
          1:
            begin
              ImportiScadenze[0] := DM1.Arrotonda(TotDocumento / Rate, FormatSettings.CurrencyDecimals);
              Rimanente := TotDocumento - ImportiScadenze[0];
            end;
          // IVA tutta sulla 1° rata
          2:
            begin
              ImportiScadenze[0] := DM1.Arrotonda(((TotDocumento - TotIVA) / Rate) + TotIVA, FormatSettings.CurrencyDecimals);
              Rimanente := TotDocumento - ImportiScadenze[0];
            end;
          // La prima rata è l'IVA
          3:
            begin
              ImportiScadenze[0] := TotIVA;
              Rimanente := TotDocumento - ImportiScadenze[0];
            end;
        end;
        // ---Determinazione importo rate successive
        // Cicla tante volte quante sono le rate ancora da creare
        for Contatore := 1 to (Rate - 1) do
        begin
          // calcola l'importo della rata
          ImportiScadenze[Contatore] := DM1.Arrotonda(Rimanente / (Rate - Contatore), FormatSettings.CurrencyDecimals);
          Rimanente := Rimanente - ImportiScadenze[Contatore];
        end;

        // ******** DETERMINAZIONE DATE RATE ***********
        // ---Determinazione data 1° rata
        DateScadenze[0] := DM1.CalcolaDataScadenza(QryDocumentoDATADOCUMENTO.Value, InizioScadGG, FineMese, QrySogg);
        // ---Determinazione date rate successive
        // Cicla tante volte quante sono le rate ancora da creare
        for Contatore := 1 to (Rate - 1) do
        begin
          // calcola la data della rata
          DateScadenze[Contatore] := DM1.CalcolaDataScadenza(DateScadenze[Contatore - 1], IntervalloScadGG, FineMese, QrySogg);
        end;
        // Controlla che le date delle scadenze non cada nel mese di sospensione
        // dei pagamenti, altrimenti sposta la relativa scadenza al mese successivo.
        for Contatore := 0 to (Rate - 1) do
        begin
          DateScadenze[Contatore] := DM1.ControlloMeseSospensione(DateScadenze[Contatore], QrySogg);
        end;

        // ******** INSERIMENTO DELLE RATE NELL'ARCHIVIO SCADENZE ***********
        QryScad.DatabaseName := DM1.ArcDBFile;
        QryScad.IB_Connection := DM1.DBAzienda;
        for Contatore := 0 to (Rate - 1) do
        begin

          if not fScadenzeCreazioneAutomaticaSoloDocumento then
          begin
            // Inserisce la nuova scadenza
            QryScad.SQL.Clear;
            QryScad.SQL.Add('INSERT INTO SCADENZ');
            QryScad.SQL.Add
              ('(TIPO,CODICE,CLIENTE,TIPODOC,NUMDOC,REGISTRO,DATADOC,DATASCADENZA,IMPORTO,IMPORTOPAGATO,RICEVUTABANCARIA,ABI,CAB,IBAN,PA_CONDIZIONIPAGAMENTOSIGLA,PA_MODALITAPAGAMENTOSICLA,PRESENTATA,INSOLUTO,NOTE,AGENTE,AGENTE2,AGENTE3,AGENTE4,ID');
            if QryDocumentoPRATICA.AsInteger > 0 then
              QryScad.SQL.Add(',PRATICA,DATAPRATICA1) VALUES (')
            else
              QryScad.SQL.Add(') VALUES (');
            if (QryDocumentoTIPODOCUMENTO.Value = 'Bolla_entr') or (QryDocumentoTIPODOCUMENTO.Value = 'Fatt.acqui') or
              (QryDocumentoTIPODOCUMENTO.Value = 'Nota_accre') then
              QryScad.SQL.Add('''Scad.passi''')
            else
              QryScad.SQL.Add('''Scad.attiv''');
            QryScad.SQL.Add(',' + IntToStr(DM1.NextCodice('SCADENZ', 'CODICE')));
            QryScad.SQL.Add(',' + QryDocumentoCODICECLIENTE.AsString);
            QryScad.SQL.Add(',''' + QryDocumentoTIPODOCUMENTO.AsString + '''');
            QryScad.SQL.Add(',' + QryDocumentoNUMORDPREV.AsString);
            QryScad.SQL.Add(',''' + QryDocumentoREGISTRO.AsString + '''');
            QryScad.SQL.Add(',''' + FormatDateTime('mm/dd/yyyy', QryDocumentoDATADOCUMENTO.AsDateTime) + '''');
            QryScad.SQL.Add(',''' + FormatDateTime('mm/dd/yyyy', DateScadenze[Contatore]) + '''');
            QryScad.SQL.Add(',' + DM1.VirgolaPunto(ImportiScadenze[Contatore]));
            QryScad.SQL.Add(',0');
            QryScad.SQL.Add(',''' + RicevutaBancaria + '''');
            QryScad.SQL.Add(',''' + QryDocumentoABI.AsString + '''');
            QryScad.SQL.Add(',''' + QryDocumentoCAB.AsString + '''');
            QryScad.SQL.Add(',''' + QryDocumentoIBAN.AsString + '''');
            QryScad.SQL.Add(',''' + QryPag.FieldByName('PA_CONDIZIONIPAGAMENTOSIGLA').AsString + '''');
            QryScad.SQL.Add(',''' + QryPag.FieldByName('PA_MODALITAPAGAMENTOSICLA').AsString + '''');
            // Se si tratta di una ricevuta bancaria pone il campo 'Presentata' = '/' che quando si chiederà
            // l'elenco delle scadenze comparirà nella prima colonnina piccola a sinistra e indicherà
            // appunto che si tratta di una RI.BA non ancora presentata.
            QryScad.SQL.Add(',''/''');
            QryScad.SQL.Add(',''F''');
            // Se abiliato dal relativo flag copia le note del documento nelle scadenze
            if DM1.CopiaNoteDocumentoSulleScadenze then
              QryScad.SQL.Add(',' + AnsiQuotedStr(QryDocumentoNOTE.AsString, ''''))
            else
              QryScad.SQL.Add(',''''');
            // Inserisce l'agente del documento
            QryScad.SQL.Add(',''' + QryDocumentoAGENTE.AsString + '''');
            QryScad.SQL.Add(',''' + QryDocumentoAGENTE2.AsString + '''');
            QryScad.SQL.Add(',''' + QryDocumentoAGENTE3.AsString + '''');
            QryScad.SQL.Add(',''' + QryDocumentoAGENTE4.AsString + '''');

            // Inserisce un nuovo ID per la scadenza
            QryScad.SQL.Add(', ' + IntToStr(DM1.Generators_NextGenID('GEN_ID_SCADENZE')));

            // Se il documento di cui si stanno generando le scadenze fà parte di una pratica
            // allora anche la scadenza attuale farà parte della stessa pratica.
            if QryDocumentoPRATICA.AsInteger > 0 then
            begin
              QryScad.SQL.Add(',' + QryDocumentoPRATICA.AsString);
              QryScad.SQL.Add(',''' + FormatDateTime('mm/dd/yyyy', QryDocumentoDATAPRATICA1.AsDateTime) + '''');
            end;
            // Chiusura
            QryScad.SQL.Add(')');
            // Esegue la query
            QryScad.ExecSQL;
          end;

          // Imposta i campi delle scadenze nel documento
          // Ovviamente se si è oltre  la quinta scadenza non fà nulla perchè mancano i campi
          if Contatore < 5 then
          begin
            QryDocumento.Edit;
            QryDocumento.FieldByName('DataScad' + IntToStr(Contatore + 1)).Value := DateScadenze[Contatore];
            QryDocumento.FieldByName('ImportoScad' + IntToStr(Contatore + 1)).Value := ImportiScadenze[Contatore];
            QryDocumento.Post;
          end;
        end;

      end
      else
      begin
        DM1.Messaggi('Informazione', 'A T T E N Z I O N E !!!'#13#13'Tipo di pagamento non trovato.'#13#13'Non verrà generata alcuna scadenza!', '',
          [mbOk], 0, nil);
      end;

    end
    else
    begin

      DM1.Messaggi('Informazione', 'A T T E N Z I O N E !!!'#13#13'Il documento ha già delle scadenze.'#13#13'NON VERRA'' GENERATA ALCUNA ALTRA SCADENZA!', '',
        [mbOk], 0, nil);

    end;

  finally
    QryPag.Free;
    QrySogg.Free;
    QryScad.Free;
  end;
end;

// ---------------------------------------------------------------------------------------------------
// FUNZIONI PER LA STAMPA CON STAMPANTI AD AGHI
// ===================================================================================================
procedure TPreventiviOrdiniForm.EseguiStampaTxt(NomeFile: String);
var
  Source, Dest: TStrings;
  Contatore, RigoAttuale, RighiCorpo, Contatore2, i: Integer;
  Rigo, Linea, Comando: String;
begin
  // Inizializza le StringList
  Source := TStringList.Create;
  Dest := TStringList.Create;
  // Carica il contenuto del file di descrizione della stampa da effettuare
  Source.LoadFromFile(NomeFile);
  // Cicla per tutte le righe del file di descrizione della stampa e le converte
  // nell'appropriato formato di stampa.
  for Contatore := 0 to Source.Count - 1 do
  begin
    // Se la riga corrente non è il corpo del documento esegue la normale conversione
    // altrimenti stampa il corpo con tutto quello che ne consegue.
    // NB: Il corpo documento è indicato dalla lettera 'B' all'inizio della stringa seguita
    // da '_' e dalla TIBOTable di riferimento e da '_' e dal n° righe del corpo.
    // Es: B_TableRighiPreventiviOrdini_025+[TablePreventiviOrdiniCodiceArticolo_015] ecc.
    // Carica su 'Linea' la stringa da elaborare
    Linea := Source[Contatore];
    if DM1.StrLeft(Linea, 2) <> 'B_' then
    begin
      // Esegue la normale conversione della linea
      Dest.Add(ConvertiLineaTxt(Linea, -1));
    end
    else
    begin
      // Estrae dalla linea la definizione del DataSet di riferimento e della lunghezza del rigo
      Comando := DM1.RitornaTestoPrimaDi('+', Linea, True);
      // Purifica il comando dei caratteri 'B_' iniziali che indentificano il rigo
      // come descrittoe di un corpo documento.
      Comando := DM1.StrRight(Comando, Length(Comando) - 2);
      // Estrae dal comando la lunghezza in righi del corpo del documento
      RighiCorpo := StrToInt(Comando);
      // Cicla per tutti i records del DataSet fino alla fine
      RigoAttuale := 0;
      for i := 0 to PreventiviOrdiniForm.tvCorpo.DataController.RecordCount - 1 do
      begin
        Inc(RigoAttuale);
        // Prima di tutto controlla se si è arrivati alla fine del corpo documento
        // nel qual caso deve saltare alla pagina successiva.
        if RigoAttuale = RighiCorpo then
        begin
          // Se si è arrivati alla fine del corpo aggiunge la riga 'Segue...', salta il piede,
          // ristampa l'intestazione.
          Dest.Add('Segue...');
          // Salta il piede
          for Contatore2 := 1 to Source.Count - Contatore - 1 do
            Dest.Add(' ');
          // Ristampa l'intestazione
          for Contatore2 := 0 to Contatore - 1 do
            Dest.Add(ConvertiLineaTxt(Source[Contatore2], i));
          // Azzera il contatore dei righi
          RigoAttuale := 1;
        end;
        // Esegue la normale conversione della linea purificata dal comando che identifica il corpo
        // Elabora la variabile Rigo e non Linea per non perdere quest'ultima con l'impossibilità di
        // stampare i righi successivi al primo perchè durante la sua elaborazione sarebbe modificata.
        Rigo := Linea;
        Dest.Add(ConvertiLineaTxt(Rigo, i));
      end;
      // Salta la parte rimanente del corpo documento agiungendo delle righe vuote per
      // arrivare al piede del documento
      while RigoAttuale < RighiCorpo do
      begin
        Dest.Add(' ');
        RigoAttuale := RigoAttuale + 1;
      end;
    end;
  end;
  // Adesso salva il file convertito da stampare e lo stampa.
  Dest.SaveToFile(DM1.CartellaTmp + 'ToPrint.txt');
  DM1.CopiaFile(DM1.CartellaTmp + 'ToPrint.txt', 'LPT1:');
end;

function TPreventiviOrdiniForm.ConvertiLineaTxt(Linea: String; RowIdx: Integer): String;
var
  S: String;
begin
  Result := '';
  // Cicla per tutte le ricorrenze del carattere '+' che separa i vari comandi che
  // compongono la linea da stampare in maniera da scomporre la linea nei singoli comandi
  // per poi farli elaborare dalle funzioni appropriate e infine ricostruire la linea da
  // ritornare alla funzione chiamante per la stampa.
  S := DM1.RitornaTestoPrimaDi('+', Linea, True);
  while S <> '' do
  begin
    Result := Result + ElaboraComandoTxt(S, RowIdx);
    S := DM1.RitornaTestoPrimaDi('+', Linea, True);
  end;
  Result := Result + ElaboraComandoTxt(Linea, RowIdx);
end;

function TPreventiviOrdiniForm.ElaboraComandoTxt(Comando: String; RowIdx: Integer): String;
begin
  Result := '';
  // Controlla il primo carattere della stringa/comando ricevuta per
  // vedere di che tipo di carattere si tratta e in base a questo
  // ritorna una stringa appropriata.
  // comando 'S' che ritorna un certo numero di spazi
  if DM1.StrLeft(Comando, 1) = 'S' then
  begin
    while Length(Result) < StrToInt(DM1.StrRight(Comando, Length(Comando) - 1)) do
    begin
      Result := Result + ' ';
    end;
    // Testo libero racchiuso tra due "
  end
  else if DM1.StrLeft(Comando, 1) = '"' then
  begin
    Comando := DM1.StrLeft(Comando, Length(Comando) - 1);
    Result := DM1.StrRight(Comando, Length(Comando) - 1);
    // Comando 'C' carattere ASCII
  end
  else if DM1.StrLeft(Comando, 1) = 'C' then
  begin
    Comando := DM1.StrRight(Comando, Length(Comando) - 1);
    Result := Chr(StrToInt(Comando));
    // Comando '[EDT_' per il testo dei componenti TEdit
  end
  else if DM1.StrLeft(Comando, 5) = '[EDT_' then
  begin
    Result := RitornaEditText(Comando);
    // Comando '[IDX_' per le colonne del CorpoDoc
  end
  else if DM1.StrLeft(Comando, 5) = '[IDX_' then
  begin
    Result := RitornaCorpoDoc(Comando, RowIdx);
    // Comando '[]' per i campi di database
  end
  else if DM1.StrLeft(Comando, 1) = '[' then
  begin
    Result := RitornaCampoTxt(Comando);
  end;
end;

function TPreventiviOrdiniForm.RitornaEditText(Comando: String): String;
var
  Lunghezza: Integer;
  NomeCampo: String;
begin
  // Questa funzione elabora il comando ricevuto e ritorna il valore del TEdit
  // richiesto e della lunghezza specificata secondo il formato:
  // [EDT_DescrBanca_25] ritorna il Text del TEdit 'DescrBanca' presente nella PreventiviOrdiniForm
  // di lunghezza fissa di 25 caratteri.
  Comando := DM1.StrLeft(Comando, Length(Comando) - 1);
  Comando := DM1.StrRight(Comando, Length(Comando) - 1);
  // Estrae il nome del componente TEdit di cui ritornare il valore
  // (Siccome ci sono sempre 2 _ (es: [IDX_CodiceArticolo_21]) compone
  // il nome completo del campo  in due passate)
  NomeCampo := DM1.RitornaTestoPrimaDi('_', Comando, True);
  // Elimina il prefisso EDT_
  NomeCampo := DM1.RitornaTestoPrimaDi('_', Comando, True);
  // Estrae la lunghezza della stringa da ritornare
  Lunghezza := StrToInt(Comando);
  // Estrae il valore da ritornare
  Result := TEdit(PreventiviOrdiniForm.FindComponent(NomeCampo)).Text;
  // Allineamento a SX
  Result := DM1.StrLeft(Result, Lunghezza);
end;

function TPreventiviOrdiniForm.RitornaCampoTxt(Comando: String): String;
var
  Lunghezza, Contatore: Integer;
  Campo: TField;
  NomeCampo, Formattazione, Temp: String;
  BlankIfZero: Boolean;
  Valore: Real;
begin
  BlankIfZero := False;
  // Questa funzione elabora il comandi ricevuto e ritorna il valore del campo
  // richiesto e della lunghezza specificata secondo il formato:
  // [TableClienti_RagioneSociale_025] ritorna il campo 'RagioneSociale' della TIBOTable 'TableCLienti'
  // di lunghezza fissa di 25 caratteri.
  // NB: La lunghezza del campo deve essere sempre indicata con 3 cifre (es: 005, 010, 120)
  // Purifica il comando dalle parantesi quadre
  Comando := DM1.StrLeft(Comando, Length(Comando) - 1);
  Comando := DM1.StrRight(Comando, Length(Comando) - 1);
  // Estra il nome del componente TField di cui ritornare il valore
  NomeCampo := DM1.RitornaTestoPrimaDi('_', Comando, True);
  // Estrae la lunghezza della stringa da ritornare
  Temp := DM1.RitornaTestoPrimaDi('_', Comando, True);
  if Temp = '' then
  begin
    // Se non è specificata la stringa di formattazione, la lunghezza da stampare sarà
    // l'ultimo argomento e imposta la formattazione di default.
    Lunghezza := StrToInt(Comando);
    Formattazione := '%n';
  end
  else
  begin
    // In questo caso la stringa di formattazione è esplicitamente indicata
    // e quindi la carica dal comando ricevuto.
    Lunghezza := StrToInt(Temp);
    // Se il primo carattere della stringa di formattazione è = 'B' (Blank) significa che
    // se il valore del campo è = '0' non ritorna una stringa con '0' ma ritorna una stringa
    // completamente vuota (per evitare che scriva '0')
    if DM1.StrLeft(Comando, 1) = 'B' then
    begin
      // Pone il flag che indica la situazione e purifica la stringa di formattazione
      BlankIfZero := True;
      Comando := DM1.StrRight(Comando, Length(Comando) - 1);
    end;
    // Estrae la stringa di formattazione
    Formattazione := Comando;
  end;
  // Cicla per tutti i componenti contenuto del DataModule alla ricerca del componente
  // TField con il nome ricercato.
  for Contatore := 0 to PreventiviOrdiniForm.ComponentCount - 1 do
  begin
    // Se il componente è quello che cerchiamo...
    if Uppercase(PreventiviOrdiniForm.Components[Contatore].Name) = Uppercase(NomeCampo) then
    begin
      Campo := (PreventiviOrdiniForm.Components[Contatore] as TField);
      // IN base al tipo di campo esegue l'allineamento a destra o a sinistra.
      if (Campo.DataType = ftString) or (Campo.DataType = ftDate) or (Campo.DataType = ftTime) or (Campo.DataType = ftDateTime) then
      begin
        Result := Campo.AsString;
        Result := DM1.StrLeft(Result, Lunghezza);
      end
      else
      begin
        // Se il campo è numerico e il suo valore = 0 e se il flag 'BlankIfZero' = True
        // ritorna una stringa completamente vuota.
        Valore := Campo.AsFloat;
        Result := '';
        if (Valore <> 0) or (not BlankIfZero) then
        begin
          Result := Format(Formattazione, [Valore]);
        end;
        Result := DM1.StrRight(Result, Lunghezza);
      end;
    end;
  end;
end;

function TPreventiviOrdiniForm.RitornaCorpoDoc(Comando: String; RowIdx: Integer): String;
var
  Lunghezza, ColIdx: Integer;
  NomeCampo: String;
  V, HH, MM: Integer;
begin
  // Inizializzazione
  ColIdx := -1;
  // Questa funzione elabora il comandi ricevuto e ritorna il valore del campo
  // richiesto e della lunghezza specificata secondo il formato:
  // [IDX_CodiceArticolo_25] ritorna il campo 'CodiceArticolo' del COrpo documento
  // di lunghezza fissa di 25 caratteri.
  Comando := DM1.StrLeft(Comando, Length(Comando) - 1);
  Comando := DM1.StrRight(Comando, Length(Comando) - 1);
  // Estra il nome del componente TField di cui ritornare il valore
  // (Siccome ci sono sempre 2 _ (es: [IDX_CodiceArticolo_21]) compone
  // il nome completo del campo  in due passate)
  NomeCampo := DM1.RitornaTestoPrimaDi('_', Comando, True);
  NomeCampo := NomeCampo + '_' + DM1.RitornaTestoPrimaDi('_', Comando, True);
  // Estrae la lunghezza della stringa da ritornare
  Lunghezza := StrToInt(Comando);
  // Converte il nome del campo nell'indice da usare per accedere alla colonna
  if NomeCampo = 'IDX_CodiceMagazzino' then
    ColIdx := tvCorpoCODICEMAGAZZINO.Index
  else if NomeCampo = 'IDX_MovMag' then
    ColIdx := tvCorpoMOVMAG.Index
  else if NomeCampo = 'IDX_CodiceArticolo' then
    ColIdx := tvCorpoCODICEARTICOLO.Index
  else if NomeCampo = 'IDX_Descrizione' then
    ColIdx := tvCorpoDESCRIZIONE.Index
  else if NomeCampo = 'IDX_PrezzoUnitario' then
    ColIdx := tvCorpoPREZZOUNITARIO.Index
  else if NomeCampo = 'IDX_PrezzoUnitarioIVACompresa' then
    ColIdx := tvCorpoPREZZOUNITARIOIVACOMPRESA.Index
  else if NomeCampo = 'IDX_UnitaDiMisura' then
    ColIdx := tvCorpoUNITADIMISURA.Index
  else if NomeCampo = 'IDX_ScontoRigo' then
    ColIdx := tvCorpoSCONTORIGO.Index
  else if NomeCampo = 'IDX_ScontoRigo2' then
    ColIdx := tvCorpoSCONTORIGO2.Index
  else if NomeCampo = 'IDX_ScontoRigo3' then
    ColIdx := tvCorpoSCONTORIGO3.Index
  else if NomeCampo = 'IDX_ImportoRigo' then
    ColIdx := tvCorpoIMPORTORIGO.Index
  else if NomeCampo = 'IDX_ImportoRigoIVACompresa' then
    ColIdx := tvCorpoIMPORTORIGOIVACOMPRESA.Index
  else if NomeCampo = 'IDX_CodiceIVA' then
    ColIdx := tvCorpoCODICEIVA.Index
  else if NomeCampo = 'IDX_DescrizioneIVA' then
    ColIdx := tvCorpoDESCRIZIONEIVA.Index
  else if NomeCampo = 'IDX_NoteRigo' then
    ColIdx := tvCorpoNOTERIGO.Index
  else if NomeCampo = 'IDX_PrezzoAcquistoArticolo' then
    ColIdx := tvCorpoPREZZOACQUISTOARTICOLO.Index
  else if NomeCampo = 'IDX_Margine' then
    ColIdx := tvCorpoMARGINE.Index
  else if NomeCampo = 'IDX_ImportoMargine' then
    ColIdx := tvCorpoIMPORTOMARGINE.Index
  else if NomeCampo = 'IDX_AliquotaIVA' then
    ColIdx := tvCorpoALIQUOTAIVA.Index
  else if NomeCampo = 'IDX_QTA' then
    ColIdx := tvCorpoQTA.Index;
  // Se è un valore numerico lo allinea a DX, altrimenti a SX
  if (tvCorpo.Items[ColIdx].DataBinding.ValueTypeClass = TcxIntegerValueType) or (tvCorpo.Items[ColIdx].DataBinding.ValueTypeClass = TcxFloatValueType) or
    (tvCorpo.Items[ColIdx].DataBinding.ValueTypeClass = TcxCurrencyValueType) then
  begin
    // Allineamento a DX
    Result := DM1.StrRight(tvCorpo.DataController.DisplayTexts[RowIdx, ColIdx], Lunghezza);
  end
  else
  begin
    // Allineamento a SX
    Result := DM1.StrLeft(tvCorpo.DataController.DisplayTexts[RowIdx, ColIdx], Lunghezza);
  end;
end;

function TPreventiviOrdiniForm.RitornaComponente(Stringa: String): TComponent;
var
  Contatore: Integer;
begin
  // Questa funzione elabora la stringa ricevuta e ritorna il DataSet
  // richiesto:
  // Es: 'TableClienti' ritorna un oggetti TDataSet che punta alla tabella
  // Cicla per tutti i componenti contenuto del DataModule alla ricerca del componente
  // TField con il nome ricercato.
  Result := nil;
  for Contatore := 0 to DM1.ComponentCount - 1 do
  begin
    // Se il componente è quello che cerchiamo...
    if DM1.Components[Contatore].Name = Stringa then
    begin
      Result := DM1.Components[Contatore];
      break;
    end;
  end;
end;
// ===================================================================================================

{
  procedure TPreventiviOrdiniForm.StampaDocFisc(TipoDoc, Registro:String; NumDoc:Longint; DataDoc:TDate; StmPrevFax, Copie:Shortint; Esploso:Boolean);
  var
  LO : TMemIniFile;
  Layout,RowAdded, EmailDelay: Integer;
  DC:TcxCustomDataController;
  i: Integer;
  begin
  // Agounge un record finto alla fine altrimenti non so perchè non stampa l'ultima riga
  //  allora ne aggiungo una finta almeno non stampa quella ma mi stampa le altre
  RowAdded := -1;
  DC := tvCorpo.DataController;
  DC.BeginUpdate;
  RowAdded := DC.AppendRecord;
  // ----------------------------------------------------------------------------------------
  // NB: *** Parametro: StmPrevfax: 0 = Anteprima
  //                                1 = Stampa
  //                                2 = Fax
  //                                3 = E-mail
  // ----------------------------------------------------------------------------------------
  // IN base al tipo di documento apre il file 'layouts.ini' e verifica con
  //  che modulo deve essere stampato e lo stampa.
  LO := TMemIniFile.Create(DM1.Repository_Layouts.FullLocalFileName);
  try
  // Controlla che il documento contenga almeno una riga
  if tvCorpo.DataController.RecordCount > 0 then begin
  // La variabile Layout contiene il tipo di layout di stampa da utilizzare (vedi specchietto sopra)
  Layout := LO.ReadInteger(TipoDoc, 'LayoutDocumento', 1);

  // =================================================================================
  // Esegue il prepare della stampa per  memorizzare nell'apposito array l'eventuale
  //  espansione delle bande dei righi del documento per poter poi adeguare gli shape
  //  della lettura facilitata e le linee verticali del documento stesso.
  // ---------------------------------------------------------------------------------
  if (Layout = 1) then begin
  Application.CreateForm(TQReportPreventiviOrdini, QReportPreventiviOrdini);
  try
  // Imposta il flag che specifica se stampare un documento con l'esploso di tutti
  //  gli articoli composti oppure no
  QReportPreventiviOrdini.FlagAbilitaStampaSottorighi := Esploso;
  // Per default pone il flag 'Fax' a False
  QReportPreventiviOrdini.FaxPrinting := False;
  // Azzera le variabili che conterranno i valori ricavati da questa operazione
  //  di preparazione alla stampa.
  SetLength(RowsExpanded, 0);
  QReportPreventiviOrdini.Preparing := True;
  try
  QReportPreventiviOrdini.QuickReport1.Prepare;
  // Aggiorna la proprietà che contiene il numero di pagine presenti nel prepare
  //  dell'ultimo documento stampato
  LastPrintedPageCount := QReportPreventiviOrdini.QuickReport1.QRPrinter.PageCount;
  finally
  QReportPreventiviOrdini.Preparing := False;
  QReportPreventiviOrdini.QuickReport1.QRPrinter.Free;
  QReportPreventiviOrdini.QuickReport1.QRPrinter := nil;
  QReportPreventiviOrdini.Free;
  QReportPreventiviOrdini := nil;
  end;
  finally
  QReportPreventiviOrdini.Free;
  QReportPreventiviOrdini := nil;
  end;
  end;
  // =================================================================================

  // In base al tipo di modulo da utilizzare, sceglie il tipo di stampa corretto
  case Layout of
  // ----- MODULO DI STAMPA SU FILE E STAMPA IN MODALITA' TESTO
  0: begin
  // Non visualizza la preview di stampa
  if StmPrevFax = 1 then begin
  // Esegue la stampa in modalità testo caricando il file di descrizione stampa
  //  specificato dalla voce 'File' nel layouts.ini
  EseguiStampaTxt(LO.ReadString(TipoDoc, 'File', ''));
  end;
  end;
  // ----- MODULO A LINEE BLU GRANDE (FORMATO A4)
  1: begin
  Application.CreateForm(TQReportPreventiviOrdini, QReportPreventiviOrdini);
  try
  // Imposta il flag che specifica se stampare un documento con l'esploso di tutti
  //  gli articoli composti oppure no
  QReportPreventiviOrdini.FlagAbilitaStampaSottorighi := Esploso;
  // Per default pone il flag 'Fax' a False
  QReportPreventiviOrdini.FaxPrinting := False;
  // Preview
  if StmPrevFax = 0 then begin
  QReportPreventiviOrdini.QuickReport1.Preview;
  // Stampa
  end else if StmPrevFax = 1 then begin
  if DM1.SettaStampante(QReportPreventiviOrdini.QuickReport1, Copie) then begin
  // Distrugge e ricrea il report, altrimento non si ripristinano alcune impostazioni
  //  dopo aver fatto il prepare per il settaggio della stampante.
  QReportPreventiviOrdini.Free;
  QReportPreventiviOrdini := nil;
  Application.CreateForm(TQReportPreventiviOrdini, QReportPreventiviOrdini);
  // Imposta il flag che specifica se stampare un documento con l'esploso di tutti
  //  gli articoli composti oppure no
  QReportPreventiviOrdini.FlagAbilitaStampaSottorighi := Esploso;
  // Per default pone il flag 'Fax' a False
  QReportPreventiviOrdini.FaxPrinting := False;
  // Reimposta i parametri della stampa perchè siccome dopo aver richiamato la funzione
  //  DM1.SettaStampante ho dovuto distruggere e ricreare il Report stesso le impostazioni erano
  //  perdure. Ora le ripristino prendendole dalle variabili che contengono le ultime impostazioni scelte
  QReportPreventiviOrdini.QuickReport1.PrinterSettings.PrinterIndex  := DM1.IndexStampanteUltimaStampa;
  QReportPreventiviOrdini.QuickReport1.PrinterSettings.FirstPage     := DM1.PagDaUltimaStampa;
  QReportPreventiviOrdini.QuickReport1.PrinterSettings.LastPage      := DM1.PagAUltimaStampa;
  //                           QReportPreventiviOrdini.QuickReport1.PrinterSettings.Copies        := DM1.CopieUltimaStampa;
  // Stampa il report.
  QReportPreventiviOrdini.QuickReport1.Prepare;
  try
  //                             QReportPreventiviOrdini.QuickReport1.PrinterSetup;
  if QReportPreventiviOrdini.QuickReport1.QRPrinter.Master.tag = 0 then begin
  for i := 1 to DM1.CopieUltimaStampa do QReportPreventiviOrdini.QuickReport1.QRPrinter.Print;
  end;
  finally
  QReportPreventiviOrdini.QuickReport1.QRPrinter.Free;
  QReportPreventiviOrdini.QuickReport1.QRPrinter := nil;
  end;
  end;
  // Fax
  end else if StmPrevFax = 2 then begin
  QReportPreventiviOrdini.FaxPrinting := True;
  DM1.Inviafax(QReportPreventiviOrdini.QuickReport1,
  QryDocumentoCodiceCliente.Value,
  'Rif. ' + TipoDoc + ' ' + IntToStr(NumDoc) + Registro + ' del ' + DateToStr(DataDoc),
  QryDocumentoPratica.Value,
  QryDocumentoDataPratica1.Value);
  // PDF Email
  end else if StmPrevFax = 3 then begin
  DM1.ShowWait('Invio documento via E-mail', 'Preparazione del documento...');
  try
  // IMposta l'utilizzo della stampante PDF
  QReportPreventiviOrdini.QuickReport1.PrinterSettings.PrinterIndex  := DM1.GetPdfPrinterIndex;
  // Crea il file Settings.ini necessario per il funzionamento del  Bullzip PDF Printer
  DM1.BullzipCreaSettings('Documento.PDF');
  // Imposta il flag che forza la stampa anche del logo
  QReportPreventiviOrdini.FaxPrinting := True;
  // Stampa il report.
  QReportPreventiviOrdini.QuickReport1.Print;
  DM1.ShowWait('Invio documento via E-mail', 'Invio documento...');
  // Attesa per permettere di cerare l'allegato PDF
  if (DM1.TableProgressiviSECONDIATTESAEMAIL.IsNull) or (DM1.TableProgressiviSECONDIATTESAEMAIL.AsInteger < 3)
  then EmailDelay := 6000
  else EmailDelay := (DM1.TableProgressiviSECONDIATTESAEMAIL.AsInteger * 1000);
  // Per fare il ritardo di attesa per la preparazione del file PDF
  //  ciclo fino a quando ottengo il ritardo impostato
  for i := 1 to Trunc(EmailDelay / 100) do begin
  Application.ProcessMessages;
  Sleep(100);
  Application.ProcessMessages;
  end;
  finally
  DM1.CloseWait;
  Application.ProcessMessages;
  end;
  DM1.InviaEmail(QryDocumentoCODICECLIENTE.AsInteger, QryDocumentoTIPODOCUMENTO.AsString  + ' N° ' + QryDocumentoNUMORDPREV.AsString + QryDocumentoREGISTRO.AsString + ' del ' + QryDocumentoDATADOCUMENTO.AsString, 'Documento.pdf');
  end;
  finally
  DM1.CloseWait;
  QReportPreventiviOrdini.Free;
  QReportPreventiviOrdini := nil;
  end;
  end;
  // ----- MODULO A LINEE BLU PICCOLO (FORMATO A5 - 2 AFFIANCATI IN OGNI A4)
  2: begin
  Application.CreateForm(TQReportRicevuteFiscali, QReportRicevuteFiscali);
  // Per default pone il flag 'Fax' a False
  QReportRicevuteFiscali.FaxPrinting := False;
  // Preview
  if StmPrevFax = 0 then begin
  QReportRicevuteFiscali.Preview;
  // Stampa
  end else if StmPrevFax = 1 then begin
  if DM1.SettaStampante(QReportRicevuteFiscali, Copie) then begin
  QReportRicevuteFiscali.Print;
  end;
  // Fax
  end else if StmPrevFax = 2 then begin
  QReportRicevuteFiscali.FaxPrinting := True;
  DM1.Inviafax(QReportRicevuteFiscali,
  QryDocumentoCodiceCliente.Value,
  'Rif. ' + TipoDoc + ' ' + IntToStr(NumDoc) + Registro + ' del ' + DateToStr(DataDoc),
  QryDocumentoPratica.Value,
  QryDocumentoDataPratica1.Value);
  end;
  QReportRicevuteFiscali.Free;
  end;
  // ----- STAMPA SU MISURATORE FISCALE
  3: begin
  // Ovviamente effettua solo la stampa e non l'anteprima ne il fax
  if StmPrevFax = 1 then begin
  StampaScontrinoFiscale;
  end;
  end;
  end;
  // Se invece il documento è vuoto...
  end else begin
  DM1.Messaggi('Stampa Documento', 'Il documento è vuoto.', 'NB: Non è possibile stampare documenti vuoti.', [mbOK], 0, nil);
  end;
  finally
  DM1.CloseWait;
  LO.Free;
  // Elimina il rigo finto aggiunto perchè non stampa l'ultimo rigo
  if RowAdded <> -1 then DC.DeleteRecord(RowAdded);
  DC.EndUpdate;
  end;
  end;
}
procedure TPreventiviOrdiniForm.StampaDocFisc(TipoDoc, Registro: String; NumDoc: Longint; DataDoc: TDate; StmPrevFax, Copie: Shortint; Esploso: Boolean);
var
  LO: TMemIniFile;
  Layout, RowAdded, EmailDelay: Integer;
  DC: TcxCustomDataController;
  i: Integer;
begin
  // Agounge un record finto alla fine altrimenti non so perchè non stampa l'ultima riga
  // allora ne aggiungo una finta almeno non stampa quella ma mi stampa le altre
  RowAdded := -1;
  DC := tvCorpo.DataController;
  DC.BeginUpdate;
  RowAdded := DC.AppendRecord;
  // ----------------------------------------------------------------------------------------
  // NB: *** Parametro: StmPrevfax: 0 = Anteprima
  // 1 = Stampa
  // 2 = Fax
  // 3 = E-mail
  // ----------------------------------------------------------------------------------------
  // IN base al tipo di documento apre il file 'layouts.ini' e verifica con
  // che modulo deve essere stampato e lo stampa.
  LO := TMemIniFile.Create(DM1.Repository_Layouts.FullLocalFileName);
  try
    // Rende visibile RE altrimenti non funziona bene (in Delphi 7 invece funzionava bene ugulmente)
    RE.Style.Color := clWhite;
    RE.Visible := True;
    // Controlla che il documento contenga almeno una riga
    if tvCorpo.DataController.RecordCount > 0 then
    begin
      // La variabile Layout contiene il tipo di layout di stampa da utilizzare (vedi specchietto sopra)
      Layout := LO.ReadInteger(TipoDoc, 'LayoutDocumento', 1);

      // =================================================================================
      // Esegue il prepare della stampa per  memorizzare nell'apposito array l'eventuale
      // espansione delle bande dei righi del documento per poter poi adeguare gli shape
      // della lettura facilitata e le linee verticali del documento stesso.
      // ---------------------------------------------------------------------------------
      if (Layout = 1) then
      begin
        Application.CreateForm(TQReportPreventiviOrdini, QReportPreventiviOrdini);
        try
          // Imposta il flag che specifica se stampare un documento con l'esploso di tutti
          // gli articoli composti oppure no
          QReportPreventiviOrdini.FlagAbilitaStampaSottorighi := Esploso;
          // Per default pone il flag 'Fax' a False
          QReportPreventiviOrdini.FaxPrinting := False;
          // Azzera le variabili che conterranno i valori ricavati da questa operazione
          // di preparazione alla stampa.
          SetLength(RowsExpanded, 0);
          QReportPreventiviOrdini.Preparing := True;
          try
            QReportPreventiviOrdini.QuickReport1.Prepare;
            // Aggiorna la proprietà che contiene il numero di pagine presenti nel prepare
            // dell'ultimo documento stampato
            LastPrintedPageCount := QReportPreventiviOrdini.QuickReport1.QRPrinter.PageCount;
          finally
            QReportPreventiviOrdini.Preparing := False;
            QReportPreventiviOrdini.QuickReport1.QRPrinter.Free;
            QReportPreventiviOrdini.QuickReport1.QRPrinter := nil;
            QReportPreventiviOrdini.Free;
            QReportPreventiviOrdini := nil;
          end;
        finally
          QReportPreventiviOrdini.Free;
          QReportPreventiviOrdini := nil;
        end;
      end;
      // =================================================================================

      // In base al tipo di modulo da utilizzare, sceglie il tipo di stampa corretto
      case Layout of
        // ----- MODULO DI STAMPA SU FILE E STAMPA IN MODALITA' TESTO
        0:
          begin
            // Non visualizza la preview di stampa
            if StmPrevFax = 1 then
            begin
              // Esegue la stampa in modalità testo caricando il file di descrizione stampa
              // specificato dalla voce 'File' nel layouts.ini
              EseguiStampaTxt(LO.ReadString(TipoDoc, 'File', ''));
            end;
          end;
        // ----- MODULO A LINEE BLU GRANDE (FORMATO A4)
        1:
          begin
            Application.CreateForm(TQReportPreventiviOrdini, QReportPreventiviOrdini);
            try
              // Imposta il flag che specifica se stampare un documento con l'esploso di tutti
              // gli articoli composti oppure no
              QReportPreventiviOrdini.FlagAbilitaStampaSottorighi := Esploso;
              // Per default pone il flag 'Fax' a False
              QReportPreventiviOrdini.FaxPrinting := False;
              // Preview
              if StmPrevFax = 0 then
              begin
                QReportPreventiviOrdini.QuickReport1.Preview;
                // Stampa
              end
              else if StmPrevFax = 1 then
              begin
                if DM1.SettaStampante(QReportPreventiviOrdini.QuickReport1, Copie) then
                begin
                  // Cicla per il numero di copie che si vogliono
                  for i := 1 to DM1.CopieUltimaStampa do
                  begin
                    // Distrugge e ricrea il report, altrimento non si ripristinano alcune impostazioni
                    // dopo aver fatto il prepare per il settaggio della stampante.
                    QReportPreventiviOrdini.Free;
                    QReportPreventiviOrdini := nil;
                    // Crea il report lo imposta opportunamente e lo stampa
                    // NB: Ho deciso di stampare ex-novo ogni copia del documento
                    // perchè con win7 64 bit la proprietà Copies del report
                    // non funzionava.
                    Application.CreateForm(TQReportPreventiviOrdini, QReportPreventiviOrdini);
                    QReportPreventiviOrdini.FlagAbilitaStampaSottorighi := Esploso;
                    QReportPreventiviOrdini.FaxPrinting := False;
                    QReportPreventiviOrdini.QuickReport1.PrinterSettings.PrinterIndex := DM1.IndexStampanteUltimaStampa;
                    QReportPreventiviOrdini.QuickReport1.PrinterSettings.FirstPage := DM1.PagDaUltimaStampa;
                    QReportPreventiviOrdini.QuickReport1.PrinterSettings.LastPage := DM1.PagAUltimaStampa;
                    QReportPreventiviOrdini.QuickReport1.PrinterSettings.Copies := 1;
                    QReportPreventiviOrdini.QuickReport1.Print;
                  end;
                end;
                // Fax
                // end else if StmPrevFax = 2 then begin
                // PDF Email
              end
              else if StmPrevFax = 3 then
              begin
                DM1.ShowWait('Invio documento via E-mail', 'Preparazione del documento...');
                try
                  // IMposta l'utilizzo della stampante PDF
                  QReportPreventiviOrdini.QuickReport1.PrinterSettings.PrinterIndex := DM1.GetPdfPrinterIndex;
                  // Crea il file Settings.ini necessario per il funzionamento del  Bullzip PDF Printer
                  DM1.BullzipCreaSettings('Documento.PDF');
                  // Imposta il flag che forza la stampa anche del logo
                  QReportPreventiviOrdini.FaxPrinting := True;
                  // Stampa il report.
                  QReportPreventiviOrdini.QuickReport1.Print;
                  DM1.ShowWait('Invio documento via E-mail', 'Invio documento...');
                  // Attesa per permettere di cerare l'allegato PDF
                  if (DM1.TableProgressiviSECONDIATTESAEMAIL.IsNull) or (DM1.TableProgressiviSECONDIATTESAEMAIL.AsInteger < 3) then
                    EmailDelay := 6000
                  else
                    EmailDelay := (DM1.TableProgressiviSECONDIATTESAEMAIL.AsInteger * 1000);
                  // Per fare il ritardo di attesa per la preparazione del file PDF
                  // ciclo fino a quando ottengo il ritardo impostato
                  for i := 1 to Trunc(EmailDelay / 100) do
                  begin
                    Application.ProcessMessages;
                    Sleep(100);
                    Application.ProcessMessages;
                  end;
                finally
                  DM1.CloseWait;
                  Application.ProcessMessages;
                end;
                DM1.InviaEmail(QryDocumentoCODICECLIENTE.AsInteger, QryDocumentoTIPODOCUMENTO.AsString + ' N° ' + QryDocumentoNUMORDPREV.AsString +
                  QryDocumentoREGISTRO.AsString + ' del ' + QryDocumentoDATADOCUMENTO.AsString, 'Documento.pdf');
              end;
            finally
              DM1.CloseWait;
              QReportPreventiviOrdini.Free;
              QReportPreventiviOrdini := nil;
            end;
          end;
        // ----- MODULO A LINEE BLU PICCOLO (FORMATO A5 - 2 AFFIANCATI IN OGNI A4)
        2:
          begin
            Application.CreateForm(TQReportRicevuteFiscali, QReportRicevuteFiscali);
            // Per default pone il flag 'Fax' a False
            QReportRicevuteFiscali.FaxPrinting := False;
            // Preview
            if StmPrevFax = 0 then
            begin
              QReportRicevuteFiscali.Preview;
              // Stampa
            end
            else if StmPrevFax = 1 then
            begin
              if DM1.SettaStampante(QReportRicevuteFiscali, Copie) then
              begin
                QReportRicevuteFiscali.Print;
              end;
              // Fax
              // end else if StmPrevFax = 2 then begin
            end;
            QReportRicevuteFiscali.Free;
          end;
      end;
      // Se invece il documento è vuoto...
    end
    else
    begin
      DM1.Messaggi('Stampa Documento', 'Il documento è vuoto.', 'NB: Non è possibile stampare documenti vuoti.', [mbOk], 0, nil);
    end;
  finally
    DM1.CloseWait;
    LO.Free;
    // Riporta RE all'invisibilità
    RE.Visible := False;
    // Elimina il rigo finto aggiunto perchè non stampa l'ultimo rigo
    if RowAdded <> -1 then
      DC.DeleteRecord(RowAdded);
    DC.EndUpdate;
  end;
end;

procedure TPreventiviOrdiniForm.Stampaleetichettedegliarticolideldocumento1Click(Sender: TObject);
var
  R, Q: Integer;
  DC: TcxCustomDataController;
begin
  DM1.Attendere;
  // Inizializzazione
  DC := tvCorpo.DataController;
  try
    // Disattiva l'agiornamento a video della griglia
    DC.BeginUpdate;
    // Svuota la tabella delle etichette
    DM2.SvuotaTabellaEtichette(IDX_ETICHETTA_ARTICOLO);
    // -----------------------------------------------------------------------------------------------------------------------------------
    // Cicla finchè ci sono righi per di cui stampare le etichette
    for R := 0 to DC.RecordCount - 1 do
    begin
      // Controlla che la quantutà non sia nulla
      if not VarIsNull(DC.Values[R, tvCorpoQTA.Index]) then
      begin
        // Crea la query e cicla per la quantità specificata nel rigo
        for Q := 1 to Trunc(DC.Values[R, tvCorpoQTA.Index]) do
        begin
          // Controlla che il CodiceArticolo non sia nullo o vuoto
          if (not VarIsNull(DC.Values[R, tvCorpoCODICEARTICOLO.Index])) and (Trim(DC.Values[R, tvCorpoCODICEARTICOLO.Index]) <> '') then
            // Carica il dato
            DM2.LoadTabellaEtichetteArticoli(DC.Values[R, tvCorpoCODICEARTICOLO.Index]);
        end;
      end;
    end;
    // -----------------------------------------------------------------------------------------------------------------------------------
    // Crea e avvia la form per la stampa delle etichette
    DM2.StampaEtichette(IDX_ETICHETTA_ARTICOLO);
  finally
    DM1.ChiudiAttendere;
    DC.EndUpdate;
  end;
end;

procedure TPreventiviOrdiniForm.ConvertiDescArtInDescGruppo(MDC: TcxCustomDataController);
var
  i: Integer;
  NewDesc: String;
begin
  // MDC punta al DataController e inizia l'Update
  MDC.BeginUpdate;
  try
    // Cicla per tutti i righi del documento
    for i := 0 to MDC.RecordCount - 1 do
    begin
      // Se il rigo attuale è un rigo composto, converte le descrizioni dei sottorighi richiamando
      // se stessa ricorsivamente.
      if (not MDC.IsDetailMode) and DM1.CheckIfExpandable(MDC, i, False) then
      begin
        // Effettua l'aggiornamento dei prezzi dei sottorighi richiamando riscorsivamente la stessa funzione
        ConvertiDescArtInDescGruppo(MDC.GetDetailDataController(i, RELATION_IDX_SOTTORIGHI_NORMALI));
        // Se invece il rigo attuale è un rigo normale (Non composto)...
      end
      else
      begin
        // Il codice articolo del rigo  non deve essere nullo
        if Trim(DM1.NoNullStringValue(MDC, i, tvCorpoCODICEARTICOLO.Index)) <> '' then
        begin
          // NewDesc conterrà il risultato della conversione (la descrizione del gruppo)
          NewDesc := DM1.DescArtToDescGruppo(MDC.Values[i, tvCorpoCODICEARTICOLO.Index]);
          // Se il risultato della conversione è <> da ''  allora provvede a eliminare il codice
          // articolo e a memorizzare la nuova descrizione
          if NewDesc <> '' then
          begin
            MDC.Values[i, tvCorpoCODICEARTICOLO.Index] := '';
            MDC.Values[i, tvCorpoDESCRIZIONE.Index] := NewDesc;
          end;
        end;
      end;
    end;
  finally
    MDC.EndUpdate;
  end;
end;

procedure TPreventiviOrdiniForm.AggiornaRicarichiPerFasceDiCosto(const DC: TcxCustomDataController; const ASoloRighiSelezionati: Boolean);
var
  i, LPrecPos: Integer;
  LCodArt: String;
  LCosto, LRicarico: Double;
begin
  // Solo per documenti di vendita
  if DM1.IsDocumentoDiIngresso(QryDocumentoTIPODOCUMENTO.AsString) then
    raise Exception.Create('"AggiornaRicarichiPerFasceDiCosto", questa funzionalità non può essere usata in documenti di acquisto.');
  // Carica le fasce di ricarico in memoria
  DM1.CaricaFasceRicarichi;
  DC.BeginUpdate;
  try
    // Salva la posizione attuale
    LPrecPos := DC.FocusedRecordIndex;
    // Cicla per tutti i righi del documento
    for i := 0 to DC.RecordCount - 1 do
    begin
      // Sposta il focus sul record in elaborazione
      DC.FocusedRecordIndex := i;
      // Se il rigo attuale è selezionato oppure se siamo in modalità "tutti i righi"...
      if DC.IsRowSelected(i) or not ASoloRighiSelezionati then
      begin
        // Se il rigo attuale è un rigo composto, aggiorna i prezzi dei sottorighi dei rigo corrente
        // NB: Fintantoche la DIBA non è multilivello non effettua il controllo ma assume automaticamente
        // che il rigo è un rigo normale
        if (not DC.IsDetailMode) and DM1.CheckIfExpandable(DC, i, False) then
        begin
          // Effettua l'aggiornamento dei prezzi dei sottorighi richiamando riscorsivamente la stessa funzione
          AggiornaRicarichiPerFasceDiCosto(DC.GetDetailDataController(i, RELATION_IDX_SOTTORIGHI_NORMALI), False);
          // RIcalcola i totali dei rigo principale
          CalcolaTotaliSottorighi(DC, i);
        end
        // Se invece il rigo attuale è un rigo normale (Non composto)...
        else
        begin
          // Estrae il codice articolo del rigo correte che non deve essere nullo e non deve essere manodopera
          LCodArt := Trim(DM1.NoNullStringValue(DC, i, tvCorpoCODICEARTICOLO.Index));
          if (not LCodArt.IsEmpty) and DM1.CodiceIsManodopera(LCodArt) then
            Continue;
          // Estrae il costo del rigo
          //  NB: Se il costo unitario del rigo è zero lo salta
          LCosto := DM1.NoNullFloatValue(DC, i, tvCorpoPREZZOACQUISTOARTICOLO.Index);
          if LCosto = 0 then
            Continue;
          // Estrae il ricarico da assegnare al rigo in base alla fascia di costo
          LRicarico := DM1.GetRicaricoPerPrezzo(LCosto, QryDocumentoLISTINO.AsInteger, False);
          // Assegna i valori al rigo
          DC.Values[i, tvCorpoMARGINE.Index] := LRicarico;
          DC.Values[i, tvCorpoSCONTORIGO.Index] := 0;
          DC.Values[i, tvCorpoSCONTORIGO2.Index] := 0;
          DC.Values[i, tvCorpoSCONTORIGO3.Index] := 0;
          CalcolaPerModificaMargine(i, DC);
          CalcolaImportoRigo(DC, i);
        end;
      end;
    end;
  finally
    DC.EndUpdate;
    CalcolaTotali(True);
  end;
end;

procedure TPreventiviOrdiniForm.AggiornaPrezziDocumento(MDC: TcxCustomDataController; SoloRighiSelezionati: Boolean = False);
var
  Qry: TIB_Cursor;
  i, ManIndex, PrecRec: Integer;
  CodArt: String;
begin
  // Creazione e impostazione della query
  Qry := TIB_Cursor.Create(Self);
  Qry.DatabaseName := DM1.ArcDBFile;
  Qry.IB_Connection := DM1.DBAzienda;
  // MDC punta al DataController e inizia l'Update
  MDC.BeginUpdate;
  try
    // Salva la posizione attuale
    PrecRec := MDC.FocusedRecordIndex;
    // Cicla per tutti i righi del documento
    for i := 0 to MDC.RecordCount - 1 do
    begin
      // Sposta il focus sul record in elaborazione
      MDC.FocusedRecordIndex := i;
      // Se il rigo attuale è selezionato oppure se siamo in modalità "tutti i righi"...
      if TcxGridDataController(MDC).GridView.Controller.FocusedRecord.Selected or not SoloRighiSelezionati then
      begin
        // Se il rigo attuale è un rigo composto, aggiorna i prezzi dei sottorighi dei rigo corrente
        // NB: Fintantoche la DIBA non è multilivello non effettua il controllo ma assume automaticamente
        // che il rigo è un rigo normale
        if (not MDC.IsDetailMode) and DM1.CheckIfExpandable(MDC, i, False) then
        begin
          // Effettua l'aggiornamento dei prezzi dei sottorighi richiamando riscorsivamente la stessa funzione
          AggiornaPrezziDocumento(MDC.GetDetailDataController(i, RELATION_IDX_SOTTORIGHI_NORMALI), False);
          // RIcalcola i totali dei rigo principale
          CalcolaTotaliSottorighi(MDC, i);
          // Se invece il rigo attuale è un rigo normale (Non composto)...
        end
        else
        begin
          CodArt := Trim(DM1.NoNullStringValue(MDC, i, tvCorpoCODICEARTICOLO.Index));
          // Il codice articolo del rigo  non deve essere nullo
          if CodArt <> '' then
          begin
            // Cerca l'articolo da aggiornare nell'archivio articoli
            Qry.SQL.Clear;
            Qry.SQL.Add
              ('SELECT PrezzoDiListino, CostoReale, ScontoDiAcquisto, ScontoDiAcquisto2, ScontoDiAcquisto3, PrezzoDiVendita, PrezzoDiVendita2, PrezzoDiVendita3, PrezzoDiVendita4');
            Qry.SQL.Add('FROM Articoli');
            Qry.SQL.Add('WHERE CodiceArticolo = ''' + CodArt + '''');
            Qry.Open;
            if (not Qry.Eof) or (DM1.CodiceIsManodopera(CodArt)) then
            begin
              // Nel caso si tratti di un documento di acquisto carica il costo reale sia come costo che come
              // prezzo unitario e imposta ovviamente i ricarici a zero. Poi in base al fatto che sia attivato
              // o meno il flag che indica che i prezzi di costo devono essere caricati netti oppure lordi + sconti
              // provvede a farlo come richiesto.
              if DM1.IsDocumentoDiIngresso(QryDocumentoTIPODOCUMENTO.AsString) then
              begin
                if DM1.PrezziAcquistoNetti then
                begin
                  MDC.Values[i, tvCorpoPREZZOACQUISTOARTICOLO.Index] := Qry.FieldByName('CostoReale').AsFloat;
                  MDC.Values[i, tvCorpoMARGINE.Index] := 0;
                  MDC.Values[i, tvCorpoSCONTORIGO.Index] := 0;
                  MDC.Values[i, tvCorpoSCONTORIGO2.Index] := 0;
                  MDC.Values[i, tvCorpoSCONTORIGO3.Index] := 0;
                  CalcolaPerModificaPrezzoAcquistoArticolo(i, MDC);
                end
                else
                begin
                  MDC.Values[i, tvCorpoPREZZOUNITARIO.Index] := Qry.FieldByName('PrezzoDiListino').AsFloat;
                  MDC.Values[i, tvCorpoSCONTORIGO.Index] := Qry.FieldByName('ScontoDiAcquisto').AsFloat;
                  MDC.Values[i, tvCorpoSCONTORIGO2.Index] := Qry.FieldByName('ScontoDiAcquisto2').AsFloat;
                  MDC.Values[i, tvCorpoSCONTORIGO3.Index] := Qry.FieldByName('ScontoDiAcquisto3').AsFloat;
                  MDC.Values[i, tvCorpoMARGINE.Index] := 0;
                  CalcolaPerModificaPrezzoUnitario(i, MDC);
                end;
              end
              // Se invece si tratta di un documento di vendita provvede a caricare il costo reale come costo del rigo
              // e poi il prezzo di vendita del listino di vendita selezionato come prezzo unitario e poi ricalcola il
              // margine.
              else
              begin
                // Se un rigo di manodopera carica il prezzo dalla manodopera
                if DM1.CodiceIsManodopera(CodArt) then
                begin
                  // Ricava l'indice del tipo di manodopera a cui il rigo fa riferimento
                  ManIndex := DM1.CodiceToIndexManodopera(CodArt);
                  // Assegna il prezzo della manodopera appropriata
                  MDC.Values[i, tvCorpoPREZZOUNITARIO.Index] := DM1.Manodopera[ManIndex].PrezzoUnitario1;
                  MDC.Values[i, tvCorpoPREZZOACQUISTOARTICOLO.Index] := DM1.Manodopera[ManIndex].CostoUnitario;
                end
                // Altrimenti se è un articolo normale lo prende dall'anagrafica articolo
                else
                begin
                  case QryDocumentoLISTINO.AsInteger of
                    // NB: Ho notato che negli articoli composti il listino rimane impostato a 0
                    // in questo caso carica il listino 1.
                    1:
                      MDC.Values[i, tvCorpoPREZZOUNITARIO.Index] := Qry.FieldByName('PrezzoDiVendita').AsFloat;
                    2:
                      MDC.Values[i, tvCorpoPREZZOUNITARIO.Index] := Qry.FieldByName('PrezzoDiVendita2').AsFloat;
                    3:
                      MDC.Values[i, tvCorpoPREZZOUNITARIO.Index] := Qry.FieldByName('PrezzoDiVendita3').AsFloat;
                    4:
                      MDC.Values[i, tvCorpoPREZZOUNITARIO.Index] := Qry.FieldByName('PrezzoDiVendita4').AsFloat;
                  else
                    MDC.Values[i, tvCorpoPREZZOUNITARIO.Index] := Qry.FieldByName('PrezzoDiListino').AsFloat;
                  end;
                  MDC.Values[i, tvCorpoPREZZOACQUISTOARTICOLO.Index] := Qry.FieldByName('CostoReale').AsFloat;
                end;
                // Parte comune sia per articoli normali che per manodopera
                MDC.Values[i, tvCorpoSCONTORIGO.Index] := 0;
                MDC.Values[i, tvCorpoSCONTORIGO2.Index] := 0;
                MDC.Values[i, tvCorpoSCONTORIGO3.Index] := 0;
                CalcolaPerModificaPrezzoUnitario(i, MDC);
              end;
              Qry.Close;
              CalcolaImportoRigo(MDC, i);
            end
            else
              DM1.Messaggi('Informazione', 'Articolo "' + MDC.Values[i, tvCorpoDESCRIZIONE.Index] +
                '" non trovato.'#13#13'Questo articolo non sarà aggiornato !!!', '', [mbOk], 0, nil);
          end;
        end;
      end;
    end;
  finally
    MDC.FocusedRecordIndex := PrecRec;
    MDC.EndUpdate;
    Qry.Free;
  end;
end;

procedure TPreventiviOrdiniForm.Aggiungidiciturapercessionecreditodimpostaecobonus1Click(Sender: TObject);
var
  DC: TcxCustomDataController;
  RowIdx: Integer;
  LDicitura: String;
begin
  LDicitura := 'Sconto praticato in base all''art 121 del D.L. 34/2020';
  // Chiede prima conferma
  if DM1.Messaggi('Dicitura sconto per cessione credito d''imposta', Format('Aggiungere la dicitura per lo sconto in fattura con cessione del credito?'#13#13'%s', [LDicitura]),
    'NB: La dicitura sarà inserita come rigo aggiuntivo di annotazione e nel blocco <AltriDatiGestionali>, campo 2.2.1.16.2 <RiferimentoTesto> come da indicazioni Assosoftware',
    [mbYes, mbNo], 0, nil) <> mrYes then
    Exit;
  // Inizializzazione
  DC := tvCorpo.DataController;
  DC.BeginUpdate;
  try
  // Aggiunge il rigo con la dicitura
  RowIdx := DC.AppendRecord;
  DC.Values[RowIdx, tvCorpoDESCRIZIONE.Index] := 'NB: ' + LDicitura;
  AssegnaAliquotaIVA(DocIvaDefault.Codice, RowIdx, DC);
  DC.Values[RowIdx, tvCorpoORDER.Index] := 99999999;
  RefreshOrderValues(tvCorpo);
  // Aggiunge la dicitura agli "AltriDatiGestionali" di tutte le righe
  for RowIdx := 0 to DC.RecordCount-1 do
  begin
    DC.Values[RowIdx, tvCorpoADG1_TIPODATO.Index] := 'sc';
    DC.Values[RowIdx, tvCorpoADG1_RIFERIMENTOTESTO.Index] := LDicitura;
  end;
  finally
    DC.EndUpdate;
  end;
end;

procedure TPreventiviOrdiniForm.AggiungiRigoRiferimentoSemplice(TipoDoc, Registro: String; NumDoc: Longint; DataDoc: TDate);
var
  DC: TcxCustomDataController;
  RowIdx: Integer;
begin
  DC := tvCorpo.DataController;
  RowIdx := DC.AppendRecord;
  // NB: Se è un rif. a una Bolla_entr scrive DDT
  if TipoDoc = 'Bolla_entr' then
    TipoDoc := 'D.D.T.';
  DC.Values[RowIdx, tvCorpoDESCRIZIONE.Index] := '---> Rif. ' + TipoDoc + ' n. ' + IntToStr(NumDoc) + Registro + ' del ' + DateToStr(DataDoc);
end;

procedure TPreventiviOrdiniForm.ImportaDocFisc(TipoDoc, Registro: String; NumDoc: Longint; DataDoc: TDate; AbilitaRiferimento: Integer; Inserisci: Boolean);
var
  Qry: TIB_Cursor;
  Y, yy, FocusedRecIdx: Integer;
  DC: TcxCustomDataController;
  LastOrder: Double;
  MantieniIvaDeiRighi: Boolean;
  TipoDocRif, TmpStr: String;
  RifDoc_CorrispNoPag: String;
  CurrView: TcxGridTableView;
  function LocNextOrder(RI: Integer): Double;
  begin
    if LastOrder = -1 then
      LastOrder := RI + 0.0001
    else
      LastOrder := LastOrder + 0.0001;
    Result := LastOrder;
  end;
// Function che richiede se mantere l'IVA originale del documento di origine oppure usare quella predefinita del documento
// destinazione nel caso fossero diverse
  function MantieniIvaInRigheConIvaDiversa: Boolean;
  begin
    try
      Result := False;
      // Cicla per tutti i righi da importare e verifica se ce ne sono con iva diversa da quella di
      // default del documento.
      Qry.First;
      while (not Qry.Eof) and (not Result) do
      begin
        // Segnala se c'è un rigo con aliquota iva non nulla, <> 0 e diversa dall'aliquota di default del documento
        Result := (not Qry.FieldByName('CODICEIVA').IsNull) and (Qry.FieldByName('CODICEIVA').AsInteger <> 0) and
          (Qry.FieldByName('CODICEIVA').AsInteger <> DocIvaDefault.Codice);
        // Avanti il prossimo
        Qry.Next;
      end;
      // Se c'è qualche rigo segnalato chiede all'utente se vuole mantenere l'IVA del rigo oppure forzarla a quella
      // de default del documento.
      // NB: Solo se l'IVA di default del documento è <> da quella di default dell'intero programma
      // cioè praticamente se l'IVa di default del documento è l'IVA forzata oppure è quella ereditata
      // dall'anagrafica del cliente (quindi forzata a questa).
      if Result and (not DocIvaDefault.IsDefault) then
      begin
        Result := DM1.Messaggi('A T T E N Z I O N E !!!',
          'Ci sono righi con IVA diversa da quella selezionata per il documento.'#13#13'Mantenere l''IVA dei righi originaria?',
          'NB: Se si seleziona ''SI'' verrà mantenuta l''IVA originaria del rigo; se invece si clicca su ''NO'' verrà impostata l''IVA del documento.',
          [mbYes, mbNo], 0, nil) = mrYes;
      end;
    finally
      Qry.First;
    end;
  end;
// Function che ritorna True se il documento di provenienza dei righi
// fa riferimento ad un altro documento (es: l'intervento che a sua volta
// fa riferiento a una Ricevuta Fiscale fatta a mano dal tecnico)
  function isRifDoc: Boolean;
  begin
    // Result := (Qry.FieldByName('RifDoc_Num').AsInteger <> 0) or
    // ((Qry.FieldByName('RifDoc_CorrispNoPag').AsString <> 'F') and
    // (Qry.FieldByName('RifDoc_CorrispNoPag').AsString <> ''));
    Result := (Qry.FieldByName('RifDoc_Num').AsInteger <> 0);
  end;
// Function che ritorna True se il documento dal quale i righi che si stanno importando
// e il documento attuale (sul quale stiamo incollando i righi stessi) sono lo stesso documento
  function IsSameDoc: Boolean;
  begin
    Result := (NumDoc = 0) or ((TipoDoc = QryDocumentoTIPODOCUMENTO.AsString) and (Registro = QryDocumentoREGISTRO.AsString) and
      (NumDoc = QryDocumentoNUMORDPREV.AsInteger) and (DataDoc = QryDocumentoDATADOCUMENTO.AsDateTime));
  end;

begin
  // Inizializzazione
  LastOrder := -1;
  CurrView := GridCorpo.FocusedView as TcxGridTableView;
  // DC Punta al MasterDataController
  DC := CurrView.DataController;
  // Questa variabile contiene l'indice del rocord con il focus
  // poi controlla, se il FocusedRecordIndex non è valido (-1)
  // (NessunRecord ha il focus) forza l'append
  FocusedRecIdx := DC.FocusedRecordIndex;
  if FocusedRecIdx = -1 then
    Inserisci := False;
  // Crea Qry
  Qry := TIB_Cursor.Create(Self);
  Qry.DatabaseName := DM1.GenDBFile;
  Qry.IB_Connection := DM1.DBGenerale;
  // Disabilita l'aggiornamento a video della griglia
  GridCorpo.BeginUpdate;
  // Effettua l'importazione dei righi selezionati per l'importazione
  // nel nuovo documento.
  // ------------------------------------------------------------------------
  try
    // Trova il primo record del documento da importare (mi serve per poi avere il codice cliente)
    Qry.SQL.Add('SELECT * FROM tmprighi');
    Qry.SQL.Add('WHERE TipoDocumento = ''' + TipoDoc + '''');
    Qry.SQL.Add('  AND Registro = ''' + Registro + '''');
    Qry.SQL.Add('  AND NumOrdPrev = ' + IntToStr(NumDoc));
    Qry.SQL.Add('  AND DataDocumento = ''' + FormatDateTime('mm/dd/yyyy', DataDoc) + '''');
    Qry.SQL.Add('  AND STATION_ID = ' + DM1.CodiceUtente);
    Qry.SQL.Add('ORDER BY PROGRIGO, PROGRIGO2');
    Qry.Open;
    if not Qry.Eof then
    begin
      // Imposta il flag che indica al programma se mantenere l'IVA del rigo che si sta importando nel
      // caso il rigo stesso ne abbia una diversa da quella predefinita per il documanto oppure no
      MantieniIvaDeiRighi := MantieniIvaInRigheConIvaDiversa;

      // ====================================================================
      // INIZIO: RIGO DI RIFERIMENTO
      // --------------------------------------------------------------------
      // Inserisce il rigo del riferimento se abilitato.
      // NB: 0 = Riferimento disabilitato
      // 1 = Riferimento abilitato e importazione dei righi
      // NB: IL riferimento viene cmq inserito se CTRL è premuto
      // NB: Se si sta importando un rigo principale VARIE proveniente dal
      // giornale di cantiere non inserisce mai il riferimento.
      // NB: Se c'è un riferimento ad altro documento (Ric.Fisc per gli interventi)
      // non crea il riferimento all'intervento
      if (AbilitaRiferimento > 0) and (TipoDoc <> 'CANTIERE') and ((AbilitaRiferimento > 1) or not isRifDoc) and not IsSameDoc then
      begin
        with DC do
        begin
          // Se il flag Insert = True fà un insert altrimenti un append
          if Inserisci then
          begin
            Y := DC.InsertRecord(FocusedRecIdx);
            Inc(FocusedRecIdx, 1);
          end
          else
            Y := DC.AppendRecord;
          // Imposta la RowSection
          DC.Values[Y, tvCorpoROWSECTION.Index] := Qry.FieldByName('RowSection').AsString;
          // Determina il tipo documento da usare nel riferimento
          // NB: Se è specificato il TipoDocumentoEsteso lo usa, altrimenti usa il TipoDocumento
          // NB: Se è un rif. a una Bolla_entr scrive DDT
          if Qry.FieldByName('TIPODOCUMENTO').AsString = 'Bolla_entr' then
            TipoDocRif := 'D.D.T.'
          else
          if Qry.FieldByName('TIPODOCUMENTOESTESO').AsString <> '' then
            TipoDocRif := Qry.FieldByName('TIPODOCUMENTOESTESO').AsString
          else
            TipoDocRif := Qry.FieldByName('TIPODOCUMENTO').AsString;
          // Costruisce il testo del rigo di riferimento
          // NB: Se il documento a cui si fa riferimento (quelo importato) è un intervento allora mette o meno
          //      il numero e/o la data dell'intervento stesso nel riferimento in base agli appositi parametri
//          TmpStr := '--- Rif. ' + TipoDocRif + ' n. ' + IntToStr(NumDoc) + Registro + ' del ' + DateToStr(DataDoc);
          TmpStr := '--- Rif. ' + TipoDocRif;
          if (TipoDocRif <> 'Intervento') or FAbilitaNumInterventoRiferimento then
            TmpStr := TmpStr + ' n. ' + IntToStr(NumDoc) + Registro;
          if (TipoDocRif <> 'Intervento') or FAbilitaDataInterventoRiferimento then
            TmpStr := TmpStr + ' del ' + DateToStr(DataDoc);
          // Se abilitato aggiunge anche la ragione sociale del documento origine
          if fAbilitaRagSocRiferimento and (DM1.IsDocumentoDiIngresso(Qry.FieldByName('TIPODOCUMENTO').AsString) or not fRagSocRIferimentoSoloDocAcq) then
            TmpStr := TmpStr + ' ' + Trim(Qry.FieldByName('RAGSOCCLI').AsString);
          // Se abilitato aggiunge anche la DESCRIZIONE PRATICA
          if fAbilitaPraticaRiferimento and (Trim(Qry.FieldByName('DESCPRATICA').AsString) <> '') then
            TmpStr := TmpStr + ' (' + Trim(Qry.FieldByName('DESCPRATICA').AsString) + ')';
          // Aggiunge anche l'eventuale extra-riferimento
          if Qry.FieldByName('EXTRA_RIFERIMENTO').AsString <> '' then
            TmpStr := TmpStr + ' ' + Trim(Qry.FieldByName('EXTRA_RIFERIMENTO').AsString);
          // Continua con l'inserimento del rigo del riferimento
          Values[Y, tvCorpoDESCRIZIONE.Index] := TmpStr;
          Values[Y, tvCorpoNOTERIGO.Index] := IntToStr(Qry.FieldByName('CodiceCliente').AsInteger);
          Values[Y, tvCorpoCODICEIVA.Index] := -9;
        end;
        // Marca il rigo come Importato.
        MarcaImportExport(DC, Y, tvCorpoSELEZIONATO.Index, FLAG_VALUE_IMPORTED);
        // Dopo aver inserito un nuovo record imposta il valore di ORDER per fargli mantenere la posizione
        // e rigenera i valori di ORDER in modo da avere solo numeri interi
        DC.Values[Y, tvCorpoORDER.Index] := LocNextOrder(Y);
      end;
      // --------------------------------------------------------------------
      // FINE: RIGO DI RIFERIMENTO
      // ====================================================================

      // ====================================================================
      // INIZIO: SECONDO RIGO DI RIFERIMENTO (RIF_DOC)
      // NB: Fatto per il discorso del rif. a ricevuta fiscale negli
      // interventi
      // --------------------------------------------------------------------
      // Verifica se ci sono i dati nei campi RIF_DOC
      // NB: IL tipo documento e il corrispNoPag non li controllo perchè sono sempre valorizzati
      if isRifDoc then
      begin
        with DC do
        begin
          // Se il flag Insert = True fà un insert altrimenti un append
          if Inserisci then
          begin
            Y := DC.InsertRecord(FocusedRecIdx);
            Inc(FocusedRecIdx, 1);
          end
          else
            Y := DC.AppendRecord;
          // Imposta la RowSectiin
          DC.Values[Y, tvCorpoROWSECTION.Index] := Qry.FieldByName('RowSection').AsString;
          // Costruisce il testo del rigo di riferimento
          TmpStr := '---> Rif. ' + Qry.FieldByName('RifDoc_Tipo').AsString + ' n. ' + Qry.FieldByName('RifDoc_Num').AsString + Qry.FieldByName('RifDoc_Reg')
            .AsString + ' del ' + Qry.FieldByName('RifDoc_Data').AsString;
          // ==============================================================================================================
          // Aggiunta la possiblità di inserire anche nel rigo di riferimento basato sui campi RifDoc i dati relativi
          // al nome del soggetto e/o della pratica. Fatto per TECNOALI.
          // --------------------------------------------------------------------------------------------------------------
          // Se abilitato aggiunge anche la ragione sociale del documento origine
          if fAbilitaRagSocRiferimento and (DM1.IsDocumentoDiIngresso(Qry.FieldByName('TIPODOCUMENTO').AsString) or not fRagSocRIferimentoSoloDocAcq) then
            TmpStr := TmpStr + ' ' + Trim(Qry.FieldByName('RAGSOCCLI').AsString);
          // Se abilitato aggiunge anche la DESCRIZIONE PRATICA
          if fAbilitaPraticaRiferimento and (Trim(Qry.FieldByName('DESCPRATICA').AsString) <> '') then
            TmpStr := TmpStr + ' (' + Trim(Qry.FieldByName('DESCPRATICA').AsString) + ')';
          // ==============================================================================================================
          // Continua con l'inserimento del rigo del riferimento
          Values[Y, tvCorpoDESCRIZIONE.Index] := TmpStr;
          Values[Y, tvCorpoNOTERIGO.Index] := IntToStr(Qry.FieldByName('CodiceCliente').AsInteger);
          Values[Y, tvCorpoCODICEIVA.Index] := -9;
        end;
        // Dopo aver inserito un nuovo record imposta il valore di ORDER per fargli mantenere la posizione
        // e rigenera i valori di ORDER in modo da avere solo numeri interi
        DC.Values[Y, tvCorpoORDER.Index] := LocNextOrder(Y);
      end;
      // --------------------------------------------------------------------
      // FINE: SECONDO RIGO DI RIFERIMENTO (RIF_DOC)
      // NB: Fatto per il discorso del rif. a ricevuta fiscale negli
      // interventi
      // ====================================================================

      // Carica il flag sullo stato del RifDoc_CorrispNoPag;
      RifDoc_CorrispNoPag := Qry.FieldByName('RIFDOC_CORRISPNOPAG').AsString;

      // Cicla fino alla fine dei righi trovati e li importa nella grid
      while not Qry.Eof do
      begin
        // Se, durante l'esportazione, il documento non aveva righi allora è stato
        // esportato un rigo vuoto in cui PROGRIGO è NULL e questo rigo non deve
        // essere importato
        if (not Qry.FieldByName('PROGRIGO').IsNull) then
        begin
          // Se il flag Insert = True fà un insert altrimenti un append
          if Inserisci then
          begin
            Y := DC.InsertRecord(FocusedRecIdx);
            Inc(FocusedRecIdx, 1);
          end
          else
            Y := DC.AppendRecord;
          // Se c'è un rigo precedente e se la sezione corrente è vuota il nuovo rigo ne eredita la RowSection
          CheckForDefaulRowSection(DC, Y);

          // Continua con l'inserimento dei dati
          DC.Values[Y, tvCorpoCODICEARTICOLO.Index] := Qry.FieldByName('CodiceArticolo').Value;
          DC.Values[Y, tvCorpoCODICEARTICOLOSTM.Index] := Qry.FieldByName('CodiceArticoloStm').Value;
          DC.Values[Y, tvCorpoDESCRIZIONE.Index] := Qry.FieldByName('Descrizione').Value;

          // Se stiamo spostando un rigo da un documento di vendita a uno di acquisto allora
          // mette come prezzo unitario il costo del rigo originale
          if DM1.IsDocumentoDiIngresso(QryDocumentoTIPODOCUMENTO.AsString) and not DM1.IsDocumentoDiIngresso(TipoDoc) then
          begin
            DC.Values[Y, tvCorpoPREZZOUNITARIO.Index] := Qry.FieldByName('PrezzoAcquistoArticolo').Value;
            DC.Values[Y, tvCorpoPREZZOUNITARIOIVACOMPRESA.Index] := 0; // Lo ricalcola nelle righe più sotto
          end
          else
          begin
            DC.Values[Y, tvCorpoPREZZOUNITARIO.Index] := Qry.FieldByName('PrezzoUnitario').Value;
            DC.Values[Y, tvCorpoPREZZOUNITARIOIVACOMPRESA.Index] := Qry.FieldByName('PrezzoUnitarioIVACompresa').Value;
          end;

          DC.Values[Y, tvCorpoUNITADIMISURA.Index] := Qry.FieldByName('UnitaDiMisura').Value;
          DC.Values[Y, tvCorpoQTA.Index] := Qry.FieldByName('QTA').Value;
          DC.Values[Y, tvCorpoSCONTORIGO.Index] := Qry.FieldByName('ScontoRigo').Value;
          DC.Values[Y, tvCorpoSCONTORIGO2.Index] := Qry.FieldByName('ScontoRigo2').Value;
          DC.Values[Y, tvCorpoSCONTORIGO3.Index] := Qry.FieldByName('ScontoRigo3').Value;

          // Schema in ordine di precedenza nell'assegnazione dell'aliquota IVA al rigo.
          // 1) Quella del rigo che si sta importando se è valida e se si è scelto di mantenere l'aliquota iva dei righi
          // 2) Quella di DocIvaDefault se DocIvaDefault.IsDefault = False
          // 3) Quella dell'anagrafica articolo se il rigo attuale è un articolo di magazzino
          // 4) Quella di default (20%)
          if (not Qry.FieldByName('CODICEIVA').IsNull) and (Qry.FieldByName('CODICEIVA').AsInteger <> 0) and MantieniIvaDeiRighi then
            AssegnaAliquotaIVA(Qry.FieldByName('CODICEIVA').AsInteger, Y, DC)
          else if (not DocIvaDefault.IsDefault) and (DocIvaDefault.Codice <> 0) then
            AssegnaAliquotaIVA(DocIvaDefault.Codice, Y, DC)
          else if (Qry.FieldByName('CodiceArticolo').IsNotNull) and (Qry.FieldByName('CodiceArticolo').AsString <> '') and
            (DM1.GetCodiceIvaArticolo(Qry.FieldByName('CodiceArticolo').AsString) <> 0) then
            AssegnaAliquotaIVA(DM1.GetCodiceIvaArticolo(Qry.FieldByName('CodiceArticolo').AsString), Y, DC)
          else
            AssegnaAliquotaIVA(DEFAULT_CODICE_IVA, Y, DC);

          DC.Values[Y, tvCorpoNOTERIGO.Index] := Qry.FieldByName('NoteRigo').Value;
          DC.Values[Y, tvCorpoMARGINE.Index] := Qry.FieldByName('Margine').Value;
          DC.Values[Y, tvCorpoIMPORTOMARGINE.Index] := Qry.FieldByName('ImportoMargine').Value;
          DC.Values[Y, tvCorpoPREZZOACQUISTOARTICOLO.Index] := Qry.FieldByName('PrezzoAcquistoArticolo').Value;
          DC.Values[Y, tvCorpoQTAOPERA.Index] := Qry.FieldByName('QtaOpera').Value;
          DC.Values[Y, tvCorpoMINUTIPREVISTI.Index] := Qry.FieldByName('MinutiPrevisti').Value;

          DC.Values[Y, tvCorpoTIPO1.Index] := Qry.FieldByName('Tipo1').Value;
          DC.Values[Y, tvCorpoTIPO2.Index] := Qry.FieldByName('Tipo2').Value;
          DC.Values[Y, tvCorpoTIPO3.Index] := Qry.FieldByName('Tipo3').Value;
          DC.Values[Y, tvCorpoTIPO4.Index] := Qry.FieldByName('Tipo4').Value;
          DC.Values[Y, tvCorpoTIPO5.Index] := Qry.FieldByName('Tipo5').Value;
          DC.Values[Y, tvCorpoTIPO6.Index] := Qry.FieldByName('Tipo6').Value;

          DC.Values[Y, tvCorpoSOTTOCANTIERE1.Index] := Qry.FieldByName('SOTTOCANTIERE1').Value;
          DC.Values[Y, tvCorpoSOTTOCANTIERE2.Index] := Qry.FieldByName('SOTTOCANTIERE2').Value;
          DC.Values[Y, tvCorpoSOTTOCANTIERE3.Index] := Qry.FieldByName('SOTTOCANTIERE3').Value;
          DC.Values[Y, tvCorpoSOTTOCANTIERE4.Index] := Qry.FieldByName('SOTTOCANTIERE4').Value;
          DC.Values[Y, tvCorpoSOTTOCANTIERE5.Index] := Qry.FieldByName('SOTTOCANTIERE5').Value;
          DC.Values[Y, tvCorpoSOTTOCANTIERE6.Index] := Qry.FieldByName('SOTTOCANTIERE6').Value;

          // Se il prezzo unitario <> 0 e quello IVA compresa = 0 allora ricalcola quello IVA compresa perchè evidentemente
          // nel documento originario non era stato valorizzato per qualche motivo.
          // NB: Vale anche per il contrario
          if ((not VarIsNull(DC.Values[Y, tvCorpoPREZZOUNITARIO.Index])) and (DC.Values[Y, tvCorpoPREZZOUNITARIO.Index] <> 0)) and
            (VarIsNull(DC.Values[Y, tvCorpoPREZZOUNITARIOIVACOMPRESA.Index]) or (DC.Values[Y, tvCorpoPREZZOUNITARIOIVACOMPRESA.Index] = 0)) then
            DC.Values[Y, tvCorpoPREZZOUNITARIOIVACOMPRESA.Index] :=
              DM1.Arrotonda(DC.Values[Y, tvCorpoPREZZOUNITARIO.Index] + (DC.Values[Y, tvCorpoPREZZOUNITARIO.Index] * DC.Values[Y, tvCorpoALIQUOTAIVA.Index] /
              100), DM1.DecMicroPrz)
          else if ((not VarIsNull(DC.Values[Y, tvCorpoPREZZOUNITARIOIVACOMPRESA.Index])) and (DC.Values[Y, tvCorpoPREZZOUNITARIOIVACOMPRESA.Index] <> 0)) and
            (VarIsNull(DC.Values[Y, tvCorpoPREZZOUNITARIO.Index]) or (DC.Values[Y, tvCorpoPREZZOUNITARIO.Index] = 0)) then
            DC.Values[Y, tvCorpoPREZZOUNITARIO.Index] := DM1.Arrotonda(DC.Values[Y, tvCorpoPREZZOUNITARIOIVACOMPRESA.Index] * 100 /
              (100 + DC.Values[Y, tvCorpoALIQUOTAIVA.Index]), DM1.DecMicroPrz);
          // Importa il MOVMAG
          DC.Values[Y, tvCorpoMOVMAG.Index] := '';

          // Importa il Codice magazzino
          if (Qry.FieldByName('CodiceMagazzino').IsNull) or (Qry.FieldByName('CodiceMagazzino').AsInteger = 0) then
            DC.Values[Y, tvCorpoCODICEMAGAZZINO.Index] := QryDocumentoCODICEMAGAZZINO.Value
          else
            DC.Values[Y, tvCorpoCODICEMAGAZZINO.Index] := Qry.FieldByName('CodiceMagazzino').Value;
          // Importa il Codice magazzino2
          if (Qry.FieldByName('CodiceMagazzino2').IsNull) or (Qry.FieldByName('CodiceMagazzino2').AsInteger = 0) then
            DC.Values[Y, tvCorpoCODICEMAGAZZINO2.Index] := QryDocumentoCODICEMAGAZZINO2.Value
          else
            DC.Values[Y, tvCorpoCODICEMAGAZZINO2.Index] := Qry.FieldByName('CodiceMagazzino2').Value;

          // Importa i GUID
          DC.Values[Y, tvCorpoGUID_REF.Index] := Qry.FieldByName('GUID_REF').Value;
          DC.Values[Y, tvCorpoGUID_ANCESTOR.Index] := Qry.FieldByName('GUID_ANCESTOR').Value;

          // Nel caso si stiano importando gli articoli provenienti da un cantiere, ricalcola
          // il rigo come se si fosse modificato il ricarico del rigo perchè alcuni
          // campi rimangono nulli (PREZZOUNITARIO e altri)
          if TipoDoc = 'CANTIERE' then
            CalcolaPerModificaPrezzoUnitario(Y, DC);
          // Calcola l'importo del rigo
          CalcolaImportoRigo(DC, Y);
          // Marca il rigo come Importato.
          MarcaImportExport(DC, Y, tvCorpoSELEZIONATO.Index, FLAG_VALUE_IMPORTED);

          // Dopo aver inserito un nuovo record imposta il valore di ORDER per fargli mantenere la posizione
          // e rigenera i valori di ORDER in modo da avere solo numeri interi
          DC.Values[Y, tvCorpoORDER.Index] := LocNextOrder(Y);

          DC.Values[Y, tvCorpoROWTYPE.Index] := Qry.FieldByName('RowType').AsString;
          DC.Values[Y, tvCorpoROWSECTION.Index] := Qry.FieldByName('RowSection').AsString;
          DC.Values[Y, tvCorpoROWPRINTPRICES.Index] := Qry.FieldByName('RowPrintPrices').AsString;
          DC.Values[Y, tvCorpoPREZZOUNITARIOAUTOCALC.Index] := Qry.FieldByName('PrezzoUnitarioAutocalc').AsString;
        end;
        // Si sposta sul prossimo rigo da importare
        Qry.Next;

        // Inizio importazione sottorighi
        // --------------------------------
        // Effettua l'importazione dei sottorighi solo se vi sono sottorighi
        if (Qry.FieldByName('PROGRIGO2').AsInteger > -1) and (not Qry.Eof) and not DC.IsDetailMode then
        begin
          // DC Punta al DetailDataController relativo.
          DC := DC.GetDetailDataController(Y, RELATION_IDX_SOTTORIGHI_NORMALI);
          // Cicla per tutti i righi che continuano ad avere PROGRIGO2 <> -1
          // (In questo modo cicla per tutti i sottorighi del rigo stesso)
          // Praticamente il rigo principale ha il campo ProgRigo2 = -1 e i suoi sottorighi
          // hanno valore > -1 ma ProgRigo = al Progrigo del rigo principale.
          while (Qry.FieldByName('PROGRIGO2').AsInteger > -1) and (not Qry.Eof) do
          begin
            yy := DC.AppendRecord;
            DC.Values[yy, tvCorpoCODICEARTICOLO.Index] := Qry.FieldByName('CodiceArticolo').Value;
            DC.Values[yy, tvCorpoCODICEARTICOLOSTM.Index] := Qry.FieldByName('CodiceArticoloStm').Value;
            DC.Values[yy, tvCorpoDESCRIZIONE.Index] := Qry.FieldByName('Descrizione').Value;

            // Se stiamo spostando un rigo da un documento di vendita a uno di acquisto allora
            // mette come prezzo unitario il costo del rigo originale
            if DM1.IsDocumentoDiIngresso(QryDocumentoTIPODOCUMENTO.AsString) and not DM1.IsDocumentoDiIngresso(TipoDoc) then
            begin
              DC.Values[yy, tvCorpoPREZZOUNITARIO.Index] := Qry.FieldByName('PrezzoAcquistoArticolo').Value;
              DC.Values[yy, tvCorpoPREZZOUNITARIOIVACOMPRESA.Index] := 0; // Lo ricalcola più sotto
            end
            else
            begin
              DC.Values[yy, tvCorpoPREZZOUNITARIO.Index] := Qry.FieldByName('PrezzoUnitario').Value;
              DC.Values[yy, tvCorpoPREZZOUNITARIOIVACOMPRESA.Index] := Qry.FieldByName('PrezzoUnitarioIVACompresa').Value;
            end;

            DC.Values[yy, tvCorpoUNITADIMISURA.Index] := Qry.FieldByName('UnitaDiMisura').Value;
            DC.Values[yy, tvCorpoQTA.Index] := Qry.FieldByName('QTA').Value;
            DC.Values[yy, tvCorpoSCONTORIGO.Index] := Qry.FieldByName('ScontoRigo').Value;
            DC.Values[yy, tvCorpoSCONTORIGO2.Index] := Qry.FieldByName('ScontoRigo2').Value;
            DC.Values[yy, tvCorpoSCONTORIGO3.Index] := Qry.FieldByName('ScontoRigo3').Value;

            // Schema in ordine di precedenza nell'assegnazione dell'aliquota IVA al rigo.
            // 1) Quella del rigo che si sta importando se è valida  e se si è scelto di mantenere l'aliquota iva dei righi
            // 2) Quella di DocIvaDefault se DocIvaDefault.IsDefault = False
            // 3) Quella dell'anagrafica articolo se il rigo attuale è un articolo di magazzino
            // 4) Quella di default (20%)
            if (not Qry.FieldByName('CODICEIVA').IsNull) and (Qry.FieldByName('CODICEIVA').AsInteger <> 0) and MantieniIvaDeiRighi then
              AssegnaAliquotaIVA(Qry.FieldByName('CODICEIVA').AsInteger, yy, DC)
            else if (not DocIvaDefault.IsDefault) and (DocIvaDefault.Codice <> 0) then
              AssegnaAliquotaIVA(DocIvaDefault.Codice, yy, DC)
            else if (Qry.FieldByName('CodiceArticolo').IsNotNull) and (Qry.FieldByName('CodiceArticolo').AsString <> '') and
              (DM1.GetCodiceIvaArticolo(Qry.FieldByName('CodiceArticolo').AsString) <> 0) then
              AssegnaAliquotaIVA(DM1.GetCodiceIvaArticolo(Qry.FieldByName('CodiceArticolo').AsString), yy, DC)
            else
              AssegnaAliquotaIVA(DEFAULT_CODICE_IVA, yy, DC);

            DC.Values[yy, tvCorpoNOTERIGO.Index] := Qry.FieldByName('NoteRigo').Value;
            DC.Values[yy, tvCorpoMARGINE.Index] := Qry.FieldByName('Margine').Value;
            DC.Values[yy, tvCorpoIMPORTOMARGINE.Index] := Qry.FieldByName('ImportoMargine').Value;
            DC.Values[yy, tvCorpoPREZZOACQUISTOARTICOLO.Index] := Qry.FieldByName('PrezzoAcquistoArticolo').Value;
            DC.Values[yy, tvCorpoQTAOPERA.Index] := Qry.FieldByName('QtaOpera').Value;
            DC.Values[yy, tvCorpoMINUTIPREVISTI.Index] := Qry.FieldByName('MinutiPrevisti').Value;

            DC.Values[yy, tvCorpoTIPO1.Index] := Qry.FieldByName('Tipo1').Value;
            DC.Values[yy, tvCorpoTIPO2.Index] := Qry.FieldByName('Tipo2').Value;
            DC.Values[yy, tvCorpoTIPO3.Index] := Qry.FieldByName('Tipo3').Value;
            DC.Values[yy, tvCorpoTIPO4.Index] := Qry.FieldByName('Tipo4').Value;
            DC.Values[yy, tvCorpoTIPO5.Index] := Qry.FieldByName('Tipo5').Value;
            DC.Values[yy, tvCorpoTIPO6.Index] := Qry.FieldByName('Tipo6').Value;

            DC.Values[yy, tvCorpoSOTTOCANTIERE1.Index] := Qry.FieldByName('SOTTOCANTIERE1').Value;
            DC.Values[yy, tvCorpoSOTTOCANTIERE2.Index] := Qry.FieldByName('SOTTOCANTIERE2').Value;
            DC.Values[yy, tvCorpoSOTTOCANTIERE3.Index] := Qry.FieldByName('SOTTOCANTIERE3').Value;
            DC.Values[yy, tvCorpoSOTTOCANTIERE4.Index] := Qry.FieldByName('SOTTOCANTIERE4').Value;
            DC.Values[yy, tvCorpoSOTTOCANTIERE5.Index] := Qry.FieldByName('SOTTOCANTIERE5').Value;
            DC.Values[yy, tvCorpoSOTTOCANTIERE6.Index] := Qry.FieldByName('SOTTOCANTIERE6').Value;

            // Importa il MOVMAG
            DC.Values[yy, tvCorpoMOVMAG.Index] := '';
            // Importa il Codice magazzino
            DC.Values[yy, tvCorpoCODICEMAGAZZINO.Index] := Qry.FieldByName('CodiceMagazzino').Value;

            DC.Values[yy, tvCorpoROWTYPE.Index] := Qry.FieldByName('RowType').AsString;
            DC.Values[yy, tvCorpoROWSECTION.Index] := Qry.FieldByName('RowSection').AsString;
            DC.Values[yy, tvCorpoROWPRINTPRICES.Index] := Qry.FieldByName('RowPrintPrices').AsString;
            DC.Values[yy, tvCorpoPREZZOUNITARIOAUTOCALC.Index] := Qry.FieldByName('PrezzoUnitarioAutocalc').AsString;

            // Dopo aver inserito un nuovo record imposta il valore di ORDER per fargli mantenere la posizione
            // e rigenera i valori di ORDER in modo da avere solo numeri interi
            DC.Values[yy, tvCorpoORDER.Index] := yy + 1;
            // +1 così comincia da 1 (altrimenti prima cominciava da 0)

            // Nel caso si stiano importando gli articoli provenienti da un cantiere, ricalcola
            // il rigo come se si fosse modificato il ricarico del rigo perchè alcuni
            // campi rimangono nulli (PREZZOUNITARIO e altri)
            if TipoDoc = 'CANTIERE' then
              CalcolaPerModificaMargine(yy, DC);
            // Calcola l'importo del rigo
            CalcolaImportoRigo(DC, yy);
            // Marca il rigo come Importato.
            MarcaImportExport(DC, yy, tvCorpoSELEZIONATO.Index, FLAG_VALUE_IMPORTED);
            // Avanza al prossimo rigo
            Qry.Next;
          end;
          // Se si è appena terminato di inserire dei sottorighi ripristina la variabile DC
          // facendo in modo che punti ora al suo MasterDataController
          DC := DC.GetMasterDataController;
        end;
        // --------------------------------
      end;

      // Disabilita l'aggiornamento a video della griglia
      GridCorpo.EndUpdate;
      // Se abilitato e necessario ricalcola i totali del documento
      CalcolaTotali(False);
      // Elimina il documento appena importato
      DM1.EliminaExpDoc(TipoDoc, Registro, NumDoc, DataDoc);
      // Marca il documento come fatturato
      // Imposta anche lo stato del documento al DopoFatturazione se impostato nel layouts.ini
      // NB: Solo se lo si stà importado in un documento di fatturazione o simili (Fattura, Ric.Fisc., Fatt.R.F.)
      // NB: Per spostare la marcatura del documento alla effettiva conferma del documento attuale ho creato
      // un array dove annotare temporaneamente il riferimento dei documenti importati per poi aggiornarne
      // lo stato o altro campo alla effettiva conferma da parte dell'utente
      // Aggiungi il documento importato alla lista dei documenti importati
      // NB: Se un articolo proveniente da un cantiere ovviamente salta questa fase
      if TipoDoc <> 'CANTIERE' then
        ImportedDocuments_Add(fImportedDocumentsArray, TipoDoc, NumDoc, Registro, DataDoc, RifDoc_CorrispNoPag);
    end
    else
    begin
      DM1.Messaggi('Errore', 'Documento da importare non trovato !!!', '', [mbOk], 0, nil);
    end;
  finally
    Qry.Close;
    Qry.Free;
    // Disabilita l'aggiornamento a video della griglia
    // NB: Solo se è ancora un Updating altrimenti darebbe un errore bastardissimo solo in alcuni casi, un casino.
    if GridCorpo.UpdateLocked then
      GridCorpo.EndUpdate;
    // Rigenera i valori di ORDER in modo da avere solo numeri interi
    RefreshOrderValues(CurrView);
  end;
end;

// =============================================================================
// INIZIO: GESTIONE ARRAY CON ELENCO DEI DOCUMENTI IMPORTATI
// NB: Per spostare la marcatura del documento alla effettiva conferma del documento attuale ho creato
// un array dove annotare temporaneamente il riferimento dei documenti importati per poi aggiornarne
// lo stato o altro campo alla effettiva conferma da parte dell'utente
// -----------------------------------------------------------------------------
// Procedure che azzera gli array dei documenti importati
procedure TPreventiviOrdiniForm.ImportedDocuments_Reset(var ImportedArray: TImportedDocumentsArray);
begin
  SetLength(ImportedArray, 0);
end;

// Procedura che aggiunge all'array che contiene l'elenco dei documenti importati (bacheca) nel documento attuale
// per poi aggiornarli alla conferma del documento attuale (fatturato, stato dopo fatturazione, ecc)
procedure TPreventiviOrdiniForm.ImportedDocuments_Add(var ImportedArray: TImportedDocumentsArray; TipoDoc: String; NumDoc: Longint; RegDoc: String;
  DataDoc: TDate; RifDoc_CorrispNoPag: String = 'F');
var
  Index: Integer;
begin
  // Determina l'indica del nuovo elemento
  Index := Length(ImportedArray);
  // Aggiunge un elemento all'array
  SetLength(ImportedArray, Index + 1);
  // Carica i dati nel nuovo elemento
  ImportedArray[Index].TipoDoc := TipoDoc;
  ImportedArray[Index].NumDoc := NumDoc;
  ImportedArray[Index].RegDoc := RegDoc;
  ImportedArray[Index].DataDoc := DataDoc;
  ImportedArray[Index].RifDoc_CorrispNoPag := RifDoc_CorrispNoPag;
end;

// Procedura che marca gli eventuali documenti importati presenti nell'appposito
// array come fatturati oppure e impostato lo come DopoFAtturato o similare
// ed eventualmente marca i documenti importati con corrispettivo non pagato
// come chiusi.
// Il tutto in base a come impostato il tipo documento attuale nel layouts.ini
// (in pratica adesso possiamo decidere ad esempio che anche un preventivo possa marcare
// i documneti importati come fatto)
procedure TPreventiviOrdiniForm.ImportedDocuments_SetMarkersAfterImported;
var
  i: Integer;
begin
  // Cicla per tutti gli eventuali documenti importati nel documento attuale
  for i := 0 to Length(fImportedDocumentsArray) - 1 do
  begin
    // Se impostato marca il documento importato come fatturato
    if DocImportati_SetFatturato then
    begin
      DM1.DocFatturato(fImportedDocumentsArray[i].TipoDoc, fImportedDocumentsArray[i].RegDoc, fImportedDocumentsArray[i].NumDoc,
        fImportedDocumentsArray[i].DataDoc);
    end;
    // Se impostato imposta lo stato del documento importato a come specificato
    // per il dopo Fatturato.
    if DocImportati_SetStatoDopoFattura then
    begin
      DM1.SetStatoDocumentoDopoFatturazione(fImportedDocumentsArray[i].TipoDoc, fImportedDocumentsArray[i].RegDoc, fImportedDocumentsArray[i].NumDoc,
        fImportedDocumentsArray[i].DataDoc);
    end;
    // Se impostato imposta lo stato del documento importato a come specificato
    // per il dopo EstrattoConto
    if DocImportati_SetStatoDopoEstrattoConto then
    begin
      DM1.SetStatoDocumentoDopoEstrattoConto(fImportedDocumentsArray[i].TipoDoc, fImportedDocumentsArray[i].RegDoc, fImportedDocumentsArray[i].NumDoc,
        fImportedDocumentsArray[i].DataDoc);
    end;
    // Se impostato e se il documento importato è marcato come con riferimento a documento
    // (Ric.Fisc) con corrispettivo non pagato, marca il documento importato come
    // CNP chiuso.
    if DocImportati_SetCorrispNoPagChiuso then
    begin
      DM1.Set_RifDoc_CorrispettivoNonPagato_Chiuso(fImportedDocumentsArray[i].TipoDoc, fImportedDocumentsArray[i].RegDoc, fImportedDocumentsArray[i].NumDoc,
        fImportedDocumentsArray[i].DataDoc, (Self.Tag = MODE_FATTURAZIONE_DIFFERITA), fImportedDocumentsArray[i].RifDoc_CorrispNoPag);
    end;
  end;
end;
// -----------------------------------------------------------------------------
// FINE: GESTIONE ARRAY CON ELENCO DEI DOCUMENTI IMPORTATI
// NB: Per spostare la marcatura del documento alla effettiva conferma del documento attuale ho creato
// un array dove annotare temporaneamente il riferimento dei documenti importati per poi aggiornarne
// lo stato o altro campo alla effettiva conferma da parte dell'utente
// =============================================================================

procedure TPreventiviOrdiniForm.ImportaRighiCodiceQtaDallaBacheca(TipoDoc, Registro: String; NumDoc: Longint; DataDoc: TDate; AbilitaRiferimento: Integer;
  Inserisci: Boolean);
var
  Qry: TIB_Cursor;
  DC: TcxCustomDataController;
  CodiceArticolo, Barcode: String;
  QtaArticolo: Double;
  FocusedRecIdx: Integer;
begin
  // Inizializzazion
  Barcode := '';
  // DC Punta al MasterDataController
  DC := tvCorpo.DataController;
  // Questa variabile contiene l'indice del rocord con il focus
  // poi controlla, se il FocusedRecordIndex non è valido (-1)
  // (NessunRecord ha il focus) forza l'append
  FocusedRecIdx := DC.FocusedRecordIndex;
  if FocusedRecIdx = -1 then
    Inserisci := False;
  // Crea Qry
  Qry := TIB_Cursor.Create(Self);
  Qry.DatabaseName := DM1.GenDBFile;
  Qry.IB_Connection := DM1.DBGenerale;
  // Effettua l'importazione dei righi selezionati per l'importazione
  // nel nuovo documento.
  // ------------------------------------------------------------------------
  try
    // Trova il primo record del documento da importare (mi serve per poi avere il codice cliente)
    Qry.SQL.Add('SELECT * FROM tmprighi');
    Qry.SQL.Add('WHERE TipoDocumento = ''' + TipoDoc + '''');
    Qry.SQL.Add('  AND Registro = ''' + Registro + '''');
    Qry.SQL.Add('  AND NumOrdPrev = ' + IntToStr(NumDoc));
    Qry.SQL.Add('  AND DataDocumento = ''' + FormatDateTime('mm/dd/yyyy', DataDoc) + '''');
    Qry.SQL.Add('  AND STATION_ID = ' + DM1.CodiceUtente);
    Qry.SQL.Add('ORDER BY PROGRIGO, PROGRIGO2');
    Qry.Open;
    if not Qry.Eof then
    begin
      // Cicla fino alla fine dei righi trovati e li importa nella grid
      while not Qry.Eof do
      begin
        // Rimedia i dati del rigo corrente
        CodiceArticolo := Qry.FieldByName('CodiceArticolo').Value;
        QtaArticolo := Qry.FieldByName('QTA').Value;
        // Se stiamo importando un articolo dal terminale palmare...
        if TipoDoc = 'Palmare' then
          Barcode := CodiceArticolo;
        // Inserisce l'articolo nel documento.
        // NB: In base al valore del flag BachecaInsert della MainForm effettua l'Append del nuovo record
        // (BachecaInsert = False) oppure l'Insert (BachecaInsert := True).
        if Inserisci then
        begin
          NuovoRigoDocumento('', CodiceArticolo, Barcode, '', QryDocumentoCODICEMAGAZZINO.AsString, AM_Insert, QtaArticolo);
        end
        else
        begin
          NuovoRigoDocumento('', CodiceArticolo, Barcode, '', QryDocumentoCODICEMAGAZZINO.AsString, AM_Append, QtaArticolo);
        end;
        // Avanti il prossimo
        Qry.Next;
      end;
    end
    else
    begin
      DM1.Messaggi('Errore', 'Documento da importare non trovato !!!', '', [mbOk], 0, nil);
    end;
    Qry.Close;
    // Elimina il documento appena importato
    DM1.EliminaExpDoc(TipoDoc, Registro, NumDoc, DataDoc);
  finally
    // Distrugge la query
    Qry.Free;
  end;
end;

{
  procedure TPreventiviOrdiniForm.EsportaRigoDocFisc(TV:TcxGridTableView);     // Personale
  var
  i, yy, RI, PR:Longint;
  Qry: TIB_Cursor;
  DC:TcxCustomDataController;
  QtaInEvasione: Double;
  begin
  // Inizializzazione
  Qry := TIB_Cursor.Create(Self);
  Qry.DatabaseName := DM1.GenDBFile;
  Qry.IB_Connection := DM1.DBGenerale;
  DC := TV.DataController;
  QtaInEvasione := -9999;
  try
  // Prima di tutto trova il PROGRIGO + alto all'interno della tabella TmpRighi in modo da
  //  continuare con la progressione
  Qry.SQL.Add('SELECT MAX(PROGRIGO) AS PR FROM TMPRIGHI');
  Qry.Open;
  PR := Qry.FieldByName('PR').AsInteger;
  Qry.Close;
  Inc(PR,1);
  // Copia tutti righi da esportare nel file 'TmpRighi' da dove, in seguito,
  //  potranno essere importati in nuovi documenti con il relativo riferimento.
  //  Copia solo i righi specificati dal parametro ricevuto
  //  dal chiamante (ListaDoc).
  //----------------------------------
  for i := 0 to TV.Controller.SelectedRecordCount  - 1 do begin
  // RI contiene l'indice del record da importare
  RI := TV.Controller.SelectedRecords[i].RecordIndex;
  // Se è visibile  la colonna QTAEVASA significa che si è su un ordine
  //  e quindi attiva la richiesta di QTA per le gestione della
  //  QTA evasa. Il rigo verrà messo in bacheca con la QTA selezionata dall'utente.
  if tvCorpoQTAEVASA.Visible then begin
  QtaInEvasione := DM1.ChiediQtaArticolo(DC.Values[RI,tvCorpoCODICEARTICOLO.Index]
  ,DM1.StrLeft(DC.DisplayTexts[RI,tvCorpoDESCRIZIONE.Index], 100)
  ,DC.Values[RI,tvCorpoUNITADIMISURA.Index]
  ,1);
  end;
  // Effettua l'inserimento dei righi selezionati nell'archivio
  //  temporaneo dei righi selezionati per essere importati in altri documenti.
  // ------------------------------------------------------------------------
  // Se il rigo è tra quelli selezionati, procede alla suo esportazione.
  Qry.SQL.Clear;
  Qry.SQL.Add('insert into tmprighi (STATION_ID, TipoDocumento, Registro, NumOrdPrev, DataDocumento, ProgRigo, ProgRigo2, CodiceCliente, CodiceArticolo, Pratica,');
  Qry.SQL.Add('CodiceIVA, DescrizioneIVA, AliquotaIVA, Descrizione, PrezzoUnitario, PrezzoUnitarioIVACompresa, QTA, ScontoRigo, ScontoRigo2, ScontoRigo3, UnitaDiMisura, PrezzoAcquistoArticolo,');
  Qry.SQL.Add('Margine, ImportoMargine, NoteRigo, MovMag, PrzUnitOpera, QtaOpera, CodiceMagazzino, MinutiPrevisti)');
  Qry.SQL.Add('values (');
  Qry.SQL.Add(DM1.CodiceUtente + ',');
  Qry.SQL.Add('''' + TipoDoc + ''',');
  Qry.SQL.Add('''' + Registro + ''',');
  Qry.SQL.Add(IntToStr(NumeroDoc) + ',');
  Qry.SQL.Add('''' + FormatDateTime('mm/dd/yyyy', DataDoc) + ''',');
  Qry.SQL.Add(IntToStr(PR + i) + ',');
  Qry.SQL.Add('-1,');
  Qry.SQL.Add(IntToStr(QryDocumentoCodiceCliente.AsInteger) + ',');
  Qry.SQL.Add(DM1.StrVarToSQL(DC.Values[RI,tvCorpoCODICEARTICOLO.Index]) + ',');
  Qry.SQL.Add(IntToStr(QryDocumentoPratica.AsInteger) + ',');
  Qry.SQL.Add(DM1.IntVarToSQL(DC.Values[RI,tvCorpoCODICEIVA.Index]) + ',');
  Qry.SQL.Add(DM1.StrVarToSQL(DC.Values[RI,tvCorpoDESCRIZIONEIVA.Index]) + ',');
  Qry.SQL.Add(DM1.FloatVarToSQL(DC.Values[RI,tvCorpoALIQUOTAIVA.Index]) + ',');
  Qry.SQL.Add(DM1.StrVarToSQL(DM1.StrLeft(DC.DisplayTexts[RI,tvCorpoDESCRIZIONE.Index], 5000)) + ',');
  Qry.SQL.Add(DM1.FloatVarToSQL(DC.Values[RI,tvCorpoPREZZOUNITARIO.Index]) + ',');
  Qry.SQL.Add(DM1.FloatVarToSQL(DC.Values[RI,tvCorpoPREZZOUNITARIOIVACOMPRESA.Index]) + ',');
  // Se la variabile QtaInEvasione <> -9999 significa che l'utente ha scelto la Qtà da
  //  esportare con l'apposita form e quindi mette questa come QTA, altrimenti usa quella
  //  del rigo origine.
  if QtaInEvasione <> -9999
  then Qry.SQL.Add(FloatToStr(QtaInEvasione) + ',')
  else Qry.SQL.Add(DM1.FloatVarToSQL(DC.Values[RI,tvCorpoQTA.Index]) + ',');
  // COntinua
  Qry.SQL.Add(DM1.FloatVarToSQL(DC.Values[RI,tvCorpoSCONTORIGO.Index]) + ',');
  Qry.SQL.Add(DM1.FloatVarToSQL(DC.Values[RI,tvCorpoSCONTORIGO2.Index]) + ',');
  Qry.SQL.Add(DM1.FloatVarToSQL(DC.Values[RI,tvCorpoSCONTORIGO3.Index]) + ',');
  Qry.SQL.Add(DM1.StrVarToSQL(DC.Values[RI,tvCorpoUNITADIMISURA.Index]) + ',');
  Qry.SQL.Add(DM1.FloatVarToSQL(DC.Values[RI,tvCorpoPREZZOACQUISTOARTICOLO.Index]) + ',');
  Qry.SQL.Add(DM1.FloatVarToSQL(DC.Values[RI,tvCorpoMARGINE.Index]) + ',');
  Qry.SQL.Add(DM1.FloatVarToSQL(DC.Values[RI,tvCorpoIMPORTOMARGINE.Index]) + ',');
  Qry.SQL.Add(DM1.StrVarToSQL(DC.Values[RI,tvCorpoNOTERIGO.Index]) + ',');
  Qry.SQL.Add(DM1.StrVarToSQL(DC.Values[RI,tvCorpoMOVMAG.Index]) + ',');
  Qry.SQL.Add(DM1.FloatVarToSQL(DC.Values[RI,tvCorpoPRZUNITOPERA.Index]) + ',');
  Qry.SQL.Add(DM1.FloatVarToSQL(DC.Values[RI,tvCorpoQTAOPERA.Index]) + ',');
  Qry.SQL.Add(DM1.IntVarToSQL(DC.Values[RI,tvCorpoCODICEMAGAZZINO.Index]) + ',');
  Qry.SQL.Add(DM1.IntVarToSQL(DC.Values[RI,tvCorpoMINUTIPREVISTI.Index]));
  Qry.SQL.Add(')');
  Qry.ExecSQL;
  // Aggiorna la colonna QTAEVASA aggiungendo la QTA evasa.
  if QtaInEvasione <> -9999 then begin
  if VarIsNull(DC.Values[RI,tvCorpoQTAEVASA.Index])
  then DC.Values[RI,tvCorpoQTAEVASA.Index] := QtaInEvasione
  else DC.Values[RI,tvCorpoQTAEVASA.Index] := DC.Values[RI,tvCorpoQTAEVASA.Index] + QtaInEvasione;
  end;
  // Marca il rigo come Esportato.
  MarcaImportExport(DC, RI, tvCorpoSELEZIONATO.Index, FLAG_VALUE_EXPORTED);
  // ------------------------------------------------------------------------
  // Inizio esportazione sottorighi
  // ------------------------------------------------------------------------
  // DC ora punta al DetailDataController del rigo attuale
  DC := DC.GetDetailDataController(RI,0);
  // Cicla per tutti i sottorighi
  for yy := 0 to DC.RecordCount -1 do begin
  // Effettua l'inserimento dei righi selezionati nell'archivio
  //  temporaneo dei righi selezionati per essere importati in altri documenti.
  // ------------------------------------------------------------------------
  // Se il rigo è tra quelli selezionati, procede alla suo esportazione.
  Qry.SQL.Clear;
  Qry.SQL.Add('insert into tmprighi (STATION_ID, TipoDocumento, Registro, NumOrdPrev, DataDocumento, ProgRigo, ProgRigo2, CodiceCliente, CodiceArticolo, Pratica,');
  Qry.SQL.Add('CodiceIVA, DescrizioneIVA, AliquotaIVA, Descrizione, PrezzoUnitario, PrezzoUnitarioIVACompresa, QTA, ScontoRigo, ScontoRigo2, ScontoRigo3, UnitaDiMisura, PrezzoAcquistoArticolo,');
  Qry.SQL.Add('Margine, ImportoMargine, NoteRigo, MovMag, PrzUnitOpera, QtaOpera, CodiceMagazzino, MinutiPrevisti)');
  Qry.SQL.Add('values (');
  Qry.SQL.Add(DM1.CodiceUtente + ',');
  Qry.SQL.Add('''' + TipoDoc + ''',');
  Qry.SQL.Add('''' + Registro + ''',');
  Qry.SQL.Add(IntToStr(NumeroDoc) + ',');
  Qry.SQL.Add('''' + FormatDateTime('mm/dd/yyyy', DataDoc) + ''',');
  Qry.SQL.Add(IntToStr(PR + i) + ',');
  Qry.SQL.Add(IntToStr(yy) + ',');
  Qry.SQL.Add(IntToStr(QryDocumentoCodiceCliente.AsInteger) + ',');
  Qry.SQL.Add(DM1.StrVarToSQL(DC.Values[yy,tvCorpoCODICEARTICOLO.Index]) + ',');
  Qry.SQL.Add(IntToStr(QryDocumentoPratica.AsInteger) + ',');
  Qry.SQL.Add(DM1.IntVarToSQL(DC.Values[yy,tvCorpoCODICEIVA.Index]) + ',');
  Qry.SQL.Add(DM1.StrVarToSQL(DC.Values[yy,tvCorpoDESCRIZIONEIVA.Index]) + ',');
  Qry.SQL.Add(DM1.FloatVarToSQL(DC.Values[yy,tvCorpoALIQUOTAIVA.Index]) + ',');
  Qry.SQL.Add(DM1.StrVarToSQL(DM1.StrLeft(DC.DisplayTexts[yy,tvCorpoDESCRIZIONE.Index], 5000)) + ',');
  Qry.SQL.Add(DM1.FloatVarToSQL(DC.Values[yy,tvCorpoPREZZOUNITARIO.Index]) + ',');
  Qry.SQL.Add(DM1.FloatVarToSQL(DC.Values[yy,tvCorpoPREZZOUNITARIOIVACOMPRESA.Index]) + ',');
  Qry.SQL.Add(DM1.FloatVarToSQL(DC.Values[yy,tvCorpoQTA.Index]) + ',');
  Qry.SQL.Add(DM1.FloatVarToSQL(DC.Values[yy,tvCorpoSCONTORIGO.Index]) + ',');
  Qry.SQL.Add(DM1.FloatVarToSQL(DC.Values[yy,tvCorpoSCONTORIGO2.Index]) + ',');
  Qry.SQL.Add(DM1.FloatVarToSQL(DC.Values[yy,tvCorpoSCONTORIGO3.Index]) + ',');
  Qry.SQL.Add(DM1.StrVarToSQL(DC.Values[yy,tvCorpoUNITADIMISURA.Index]) + ',');
  Qry.SQL.Add(DM1.FloatVarToSQL(DC.Values[yy,tvCorpoPREZZOACQUISTOARTICOLO.Index]) + ',');
  Qry.SQL.Add(DM1.FloatVarToSQL(DC.Values[yy,tvCorpoMARGINE.Index]) + ',');
  Qry.SQL.Add(DM1.FloatVarToSQL(DC.Values[yy,tvCorpoIMPORTOMARGINE.Index]) + ',');
  Qry.SQL.Add(DM1.StrVarToSQL(DC.Values[yy,tvCorpoNOTERIGO.Index]) + ',');
  Qry.SQL.Add(DM1.StrVarToSQL(DC.Values[yy,tvCorpoMOVMAG.Index]) + ',');
  Qry.SQL.Add(DM1.FloatVarToSQL(DC.Values[yy,tvCorpoPRZUNITOPERA.Index]) + ',');
  Qry.SQL.Add(DM1.FloatVarToSQL(DC.Values[yy,tvCorpoQTAOPERA.Index]) + ',');
  Qry.SQL.Add(DM1.IntVarToSQL(DC.Values[yy,tvCorpoCODICEMAGAZZINO.Index]) + ',');
  Qry.SQL.Add(DM1.IntVarToSQL(DC.Values[yy,tvCorpoMINUTIPREVISTI.Index]));
  Qry.SQL.Add(')');
  Qry.ExecSQL;
  // Marca il rigo come Esportato.
  MarcaImportExport(DC, yy, tvCorpoSELEZIONATO.Index, FLAG_VALUE_EXPORTED);
  end;
  // DC ora ritorna a puntare al MasterDataController
  DC := DC.GetMasterDataController;
  // ------------------------------------------------------------------------
  end;
  finally
  Qry.Free;
  end;
  end;
}

procedure TPreventiviOrdiniForm.EsportaRigoDocFisc(TV: TcxGridTableView);
// Personale
var
  i, RI: Longint;
  DC: TcxCustomDataController;
begin
  // Inizializzazione
  DC := TV.DataController;
  GridCorpo.BeginUpdate;
  // Avvia la transazione
  DM1.DBGenerale.StartTransaction;
  try
    try
      DM1.ShowWait('Levante', 'Operazione in corso...');
      // Copia tutti righi da esportare nel file 'TmpRighi' da dove, in seguito,
      // potranno essere importati in nuovi documenti con il relativo riferimento.
      // Copia solo i righi specificati dal parametro ricevuto
      // dal chiamante (ListaDoc).
      // ----------------------------------
      for i := 0 to TV.Controller.SelectedRecordCount - 1 do
      begin
        // Se il record corrente è un group header lo salta
        if not TV.Controller.SelectedRecords[i].IsData then
          Continue;
        // RI contiene l'indice del record da importare
        RI := TV.Controller.SelectedRecords[i].RecordIndex;
        // Esporta il rigo attuale
        EsportaRigoSingolo(DC, RI);
      end;
      // Se arriva qui significa che tutto è andato bene e conferma la transazione
      DM1.DBGenerale.Commit;
    except
      // Se qualcosa è andato storto annulla tutto
      DM1.DBGenerale.Rollback;
      // Re-raise dell'eccezione.
      raise;
    end;
  finally
    GridCorpo.EndUpdate;
    DM1.CloseWait;
  end;
end;

//function TPreventiviOrdiniForm.GetRDAFromImpegni: String;
//var
//  Qry: TIB_Cursor;
//begin
//  Qry := TIB_Cursor.Create(Self);
//  try
//    Qry.DatabaseName := DM1.ArcDBFile;
//    Qry.IB_Connection := DM1.DBAzienda;
//    Qry.SQL.Add('SELECT RDA FROM IMPEGNI WHERE ID=' + QryDocumentoNUMORDPREV.AsString);
//    Qry.Open;
//    Result := Trim(Qry.Fields[0].AsString);
//    Qry.Close;
//  finally
//    Qry.Free;
//  end;
//end;

procedure TPreventiviOrdiniForm.EsportaRigoSingolo(DC: TcxCustomDataController; RI: Integer; Qta: Double = -9999);
var
  i, yy, PR: Longint;
  Qry: TIB_Cursor;
  QtaInEvasione: Double;
  DescArt, ExtraRif, LRDA: String;
  DDC: TcxCustomDataController;
begin
  // Inizializzazione
  Qry := TIB_Cursor.Create(Self);
  Qry.DatabaseName := DM1.GenDBFile;
  Qry.IB_Connection := DM1.DBGenerale;
  QtaInEvasione := -9999;
  try
    // Prima di tutto trova il PROGRIGO + alto all'interno della tabella TmpRighi in modo da
    // continuare con la progressione
    Qry.SQL.Add('SELECT MAX(PROGRIGO) AS PR FROM TMPRIGHI');
    Qry.Open;
    PR := Qry.FieldByName('PR').AsInteger;
    Qry.Close;
    Inc(PR, 1);
    // Se è visibile  la colonna QTAEVASA significa che si è su un ordine
    // e quindi attiva la richiesta di QTA per le gestione della
    // QTA evasa. Il rigo verrà messo in bacheca con la QTA selezionata dall'utente.
    if tvCorpoQTAEVASA.Visible and (Qta = -9999) and (RxSpeedModifica.Down) then
    begin
      QtaInEvasione := DM1.ChiediQtaArticolo(DC.Values[RI, tvCorpoCODICEARTICOLO.Index], DM1.StrLeft(DC.DisplayTexts[RI, tvCorpoDESCRIZIONE.Index], 100),
        DC.Values[RI, tvCorpoUNITADIMISURA.Index], 1);
      // Se QtaInEvasione + QtaEvasa >= Qta blocca tutto avvertendo l'utente
      if not QtaEvasioneIsValid(DC.Values[RI, tvCorpoQTA.Index], DC.Values[RI, tvCorpoQTAINEVASIONE.Index],
        (DC.Values[RI, tvCorpoQTAEVASA.Index] + QtaInEvasione)) then
      begin
        DM1.Messaggi('ATTENZIONE !!!', 'Articolo:   ' + DC.Values[RI, tvCorpoCODICEARTICOLO.Index] + ' - ' +
          DM1.StrLeft(DC.DisplayTexts[RI, tvCorpoDESCRIZIONE.Index], 40) + #13#13'La quantità evasa è superiore alla quantità.'#13#13'MODIFICA ANNULLATA!!!',
          '', [mbOk], 0, nil);
        Exit;
      end;
    end;
    // Verifica il GUID del rigo
    SetRowGUID(DC, RI);
    // Effettua l'inserimento dei righi selezionati nell'archivio
    // temporaneo dei righi selezionati per essere importati in altri documenti.
    // ------------------------------------------------------------------------
    Qry.SQL.Clear;
    Qry.SQL.Add
      ('insert into tmprighi (STATION_ID, TipoDocumento, TipoDocumentoEsteso, Registro, NumOrdPrev, DataDocumento, ProgRigo, ProgRigo2, CodiceCliente, CodiceArticolo, CodiceArticoloStm, Pratica, DataPratica,');
    Qry.SQL.Add
      ('CodiceIVA, DescrizioneIVA, AliquotaIVA, Descrizione, PrezzoUnitario, PrezzoUnitarioIVACompresa, QTA, ScontoRigo, ScontoRigo2, ScontoRigo3, UnitaDiMisura, PrezzoAcquistoArticolo,');
    Qry.SQL.Add
      ('Margine, ImportoMargine, NoteRigo, MovMag, QtaOpera, CodiceMagazzino, CodiceMagazzino2, MinutiPrevisti, Tipo1, Tipo2, Tipo3, Tipo4, Tipo5, Tipo6,');
    Qry.SQL.Add('SOTTOCANTIERE1, SOTTOCANTIERE2, SOTTOCANTIERE3, SOTTOCANTIERE4, SOTTOCANTIERE5, SOTTOCANTIERE6,');
    Qry.SQL.Add('GUID_REF, GUID_ANCESTOR, RAGSOCCLI, DESCPRATICA, RifDoc_Tipo, RifDoc_Num, RifDoc_Reg, RifDoc_Data, RifDoc_CorrispNoPag, EXTRA_RIFERIMENTO,');
    Qry.SQL.Add('RowType, RowSection, RowPrintPrices, PrezzoUnitarioAutocalc)');
    Qry.SQL.Add('values (');
    Qry.SQL.Add(DM1.CodiceUtente + ',');
    Qry.SQL.Add('''' + TipoDoc + ''',');
    Qry.SQL.Add(QuotedStr(QryDocumentoTIPODOCUMENTOESTESO.AsString) + ',');
    Qry.SQL.Add('''' + Registro + ''',');
    Qry.SQL.Add(IntToStr(NumeroDoc) + ',');
    Qry.SQL.Add('''' + FormatDateTime('mm/dd/yyyy', DataDoc) + ''',');
    Qry.SQL.Add(IntToStr(PR + i) + ',');
    Qry.SQL.Add('-1,');
    Qry.SQL.Add(IntToStr(QryDocumentoCODICECLIENTE.AsInteger) + ',');
    Qry.SQL.Add(DM1.StrVarToSQL(DC.Values[RI, tvCorpoCODICEARTICOLO.Index]) + ',');
    Qry.SQL.Add(DM1.StrVarToSQL(DC.Values[RI, tvCorpoCODICEARTICOLOSTM.Index]) + ',');
    Qry.SQL.Add(IntToStr(QryDocumentoPRATICA.AsInteger) + ',');
    Qry.SQL.Add('''' + FormatDateTime('mm/dd/yyyy', QryDocumentoDATAPRATICA1.AsDateTime) + ''',');
    Qry.SQL.Add(DM1.IntVarToSQL(DC.Values[RI, tvCorpoCODICEIVA.Index]) + ',');
    Qry.SQL.Add(DM1.StrVarToSQL(DC.Values[RI, tvCorpoDESCRIZIONEIVA.Index]) + ',');
    Qry.SQL.Add(DM1.FloatVarToSQL(DC.Values[RI, tvCorpoALIQUOTAIVA.Index]) + ',');
    // Se si sta esportando in bacheca un rigo di manodopera ci mette nella descrizione
    // del rigo principale anche le note inserite nei sottorighi, altrimenti esportas solo la
    // descrizione normale
    // -----------------------------------------------------------------------
    // Inizializza il valore di questa variabile appoggio alla descrizione attuale
    DescArt := DC.DisplayTexts[RI, tvCorpoDESCRIZIONE.Index];
    // Se il rigo attuale è un rigo di manodopera ed è un rigo principale...
    // provvede ad aggiungere le righe di note dei sottorighi di manodopera
    // eventualmente presenti.
    if (DM1.CodiceIsManodopera(DC.Values[RI, tvCorpoCODICEARTICOLO.Index])) and (not DC.IsDetailMode) then
    begin
      // RIcava il detail data controller
      DDC := DC.GetDetailDataController(RI, RELATION_IDX_SOTTORIGHI_ORE);
      // CIcla per tutti i sottorighi presenti
      for i := 0 to DDC.RecordCount - 1 do
      begin
        // Aggiunge alla descrizione principale le note del sottorigo corrente
        // ma salta il sottorigo di default obbligatorio
        if (DM1.NoNullIntValue(DDC, i, tvOreCODDIPENDENTE.Index) <> -1) and (Trim(DM1.NoNullStringValue(DDC, i, tvOreNOTE.Index)) <> '') then
          DescArt := DescArt + #13'- ' + DDC.DisplayTexts[i, tvOreNOTE.Index];
      end;
    end;
    // Salva la descrizione ottenuta
    Qry.SQL.Add(DM1.StrVarToSQL(DM1.StrLeft(DescArt, 5000)) + ',');
    // -----------------------------------------------------------------------
    Qry.SQL.Add(DM1.FloatVarToSQL(DC.Values[RI, tvCorpoPREZZOUNITARIO.Index]) + ',');
    Qry.SQL.Add(DM1.FloatVarToSQL(DC.Values[RI, tvCorpoPREZZOUNITARIOIVACOMPRESA.Index]) + ',');
    // Se la variabile QtaInEvasione <> -9999 significa che l'utente ha scelto la Qtà da
    // esportare con l'apposita form e quindi mette questa come QTA, altrimenti usa quella
    // del rigo origine.
    if Qta <> -9999 then
      Qry.SQL.Add(FloatToStr(Qta) + ',')
    else if QtaInEvasione <> -9999 then
      Qry.SQL.Add(FloatToStr(QtaInEvasione) + ',')
    else
      Qry.SQL.Add(DM1.FloatVarToSQL(DC.Values[RI, tvCorpoQTA.Index]) + ',');
    // COntinua
    Qry.SQL.Add(DM1.FloatVarToSQL_DefaultIfNull(DC.Values[RI, tvCorpoSCONTORIGO.Index], '0') + ',');
    Qry.SQL.Add(DM1.FloatVarToSQL_DefaultIfNull(DC.Values[RI, tvCorpoSCONTORIGO2.Index], '0') + ',');
    Qry.SQL.Add(DM1.FloatVarToSQL_DefaultIfNull(DC.Values[RI, tvCorpoSCONTORIGO3.Index], '0') + ',');
    Qry.SQL.Add(DM1.StrVarToSQL(DC.Values[RI, tvCorpoUNITADIMISURA.Index]) + ',');
    Qry.SQL.Add(DM1.FloatVarToSQL(DC.Values[RI, tvCorpoPREZZOACQUISTOARTICOLO.Index]) + ',');
    Qry.SQL.Add(DM1.FloatVarToSQL(DC.Values[RI, tvCorpoMARGINE.Index]) + ',');
    Qry.SQL.Add(DM1.FloatVarToSQL(DC.Values[RI, tvCorpoIMPORTOMARGINE.Index]) + ',');
    Qry.SQL.Add(AnsiQuotedStr(DM1.NoNullStringValue(DC, RI, tvCorpoNOTERIGO.Index), '''') + ',');
    Qry.SQL.Add(AnsiQuotedStr(QryDocumentoSEGNOOPERAZIONE.AsString, '''') + ',');
    Qry.SQL.Add(DM1.FloatVarToSQL(DC.Values[RI, tvCorpoQTAOPERA.Index]) + ',');
    Qry.SQL.Add(DM1.IntVarToSQL(DC.Values[RI, tvCorpoCODICEMAGAZZINO.Index]) + ',');
    Qry.SQL.Add(DM1.IntVarToSQL(DC.Values[RI, tvCorpoCODICEMAGAZZINO2.Index]) + ',');
    Qry.SQL.Add(DM1.IntVarToSQL(DC.Values[RI, tvCorpoMINUTIPREVISTI.Index]) + ',');
    Qry.SQL.Add(DM1.StrVarToSQL(DC.Values[RI, tvCorpoTIPO1.Index]) + ',');
    Qry.SQL.Add(DM1.StrVarToSQL(DC.Values[RI, tvCorpoTIPO2.Index]) + ',');
    Qry.SQL.Add(DM1.StrVarToSQL(DC.Values[RI, tvCorpoTIPO3.Index]) + ',');
    Qry.SQL.Add(DM1.StrVarToSQL(DC.Values[RI, tvCorpoTIPO4.Index]) + ',');
    Qry.SQL.Add(DM1.StrVarToSQL(DC.Values[RI, tvCorpoTIPO5.Index]) + ',');
    Qry.SQL.Add(DM1.StrVarToSQL(DC.Values[RI, tvCorpoTIPO6.Index]) + ',');
    Qry.SQL.Add(DM1.StrVarToSQL(DC.Values[RI, tvCorpoSOTTOCANTIERE1.Index]) + ',');
    Qry.SQL.Add(DM1.StrVarToSQL(DC.Values[RI, tvCorpoSOTTOCANTIERE2.Index]) + ',');
    Qry.SQL.Add(DM1.StrVarToSQL(DC.Values[RI, tvCorpoSOTTOCANTIERE3.Index]) + ',');
    Qry.SQL.Add(DM1.StrVarToSQL(DC.Values[RI, tvCorpoSOTTOCANTIERE4.Index]) + ',');
    Qry.SQL.Add(DM1.StrVarToSQL(DC.Values[RI, tvCorpoSOTTOCANTIERE5.Index]) + ',');
    Qry.SQL.Add(DM1.StrVarToSQL(DC.Values[RI, tvCorpoSOTTOCANTIERE6.Index]) + ',');
    // GUID_REF
    Qry.SQL.Add(DM1.StrVarToSQL(DC.Values[RI, tvCorpoGUID_REF.Index]) + ',');
    // GUID_ANCESTOR
    Qry.SQL.Add(DM1.StrVarToSQL(DC.Values[RI, tvCorpoGUID.Index]) + ',');
    Qry.SQL.Add(QuotedStr(QryDocumentoRAGSOCCLI.AsString) + ',');
    Qry.SQL.Add(QuotedStr(EditDescrizionePratica1.Text) + ',');
    Qry.SQL.Add(QuotedStr(QryDocumentoRIFDOC_TIPO.AsString) + ',');
    Qry.SQL.Add(IntToStr(QryDocumentoRIFDOC_NUM.AsInteger) + ',');
    Qry.SQL.Add(QuotedStr(QryDocumentoRIFDOC_REG.AsString) + ',');
    Qry.SQL.Add(QuotedStr(FormatDateTime('mm/dd/yyyy', QryDocumentoRIFDOC_DATA.AsDateTime)) + ',');
    Qry.SQL.Add(QuotedStr(QryDocumentoRIFDOC_CORRISPNOPAG.AsString) + ',');

    // Costruisce la descrizione da esportare e se è un rigo di manodopera principale
    // proccede ad aggiungere alla descrizione anche le note dei sottorighi presenti.
    // -----------------------------------------------------------------
    ExtraRif := '';

    // Aggiunge l'eventuale RDA
    if Self.IsImpegno then
      LRDA := ImpegnoForm.QryImpRDA.AsString;

    if LRDA <> '' then
      ExtraRif := ExtraRif + Format(' (RDA %s)', [LRDA]);
    // Aggiunge anche gli eventuali campo SUBSOGG1
    if QryDocumentoSUBSOGGCAMPO1.AsString <> '' then
      ExtraRif := ExtraRif + ' ' + DM1.RefCaptionLabelSubSogg1 + ' ' + QryDocumentoSUBSOGGCAMPO1.AsString;
    if QryDocumentoSUBSOGGCAMPO2.AsString <> '' then
      ExtraRif := ExtraRif + ' ' + DM1.RefCaptionLabelSubSogg2 + ' ' + QryDocumentoSUBSOGGCAMPO2.AsString;
    if QryDocumentoSUBSOGGCAMPO3.AsString <> '' then
      ExtraRif := ExtraRif + ' ' + DM1.RefCaptionLabelSubSogg3 + ' ' + QryDocumentoSUBSOGGCAMPO3.AsString;
    // Invio la descrizione così ottenuta alla query
    Qry.SQL.Add(AnsiQuotedStr(LeftStr(Trim(ExtraRif), 200), '''') + ',');
    // -----------------------------------------------------------------

    Qry.SQL.Add(DM1.StrVarToSQL(DC.Values[RI, tvCorpoROWTYPE.Index]) + ',');
    Qry.SQL.Add(DM1.StrVarToSQL(DC.Values[RI, tvCorpoROWSECTION.Index]) + ',');
    Qry.SQL.Add(DM1.StrVarToSQL(DC.Values[RI, tvCorpoROWPRINTPRICES.Index]) + ',');
    Qry.SQL.Add(DM1.StrVarToSQL(DC.Values[RI, tvCorpoPREZZOUNITARIOAUTOCALC.Index]));

    Qry.SQL.Add(')');
    Qry.ExecSQL;

    // Aggiorna la colonna QTAEVASA aggiungendo la QTA evasa.
    if QtaInEvasione <> -9999 then
    begin
      if VarIsNull(DC.Values[RI, tvCorpoQTAEVASA.Index]) then
        DC.Values[RI, tvCorpoQTAEVASA.Index] := QtaInEvasione
      else
        DC.Values[RI, tvCorpoQTAEVASA.Index] := DC.Values[RI, tvCorpoQTAEVASA.Index] + QtaInEvasione;
    end;
    // Marca il rigo come Esportato.
    MarcaImportExport(DC, RI, tvCorpoSELEZIONATO.Index, FLAG_VALUE_EXPORTED);
    // ------------------------------------------------------------------------
    // Inizio esportazione sottorighi
    // ------------------------------------------------------------------------
    // Se il rigo attuale possiede dei sottorighi procede con l'esportazione
    // dei sottorighi stessi
    if DM1.CheckIfExpandable(DC, RI, False) then
    begin
      // DC ora punta al DetailDataController del rigo attuale
      DC := DC.GetDetailDataController(RI, RELATION_IDX_SOTTORIGHI_NORMALI);
      // Cicla per tutti i sottorighi
      for yy := 0 to DC.RecordCount - 1 do
      begin
        // Verifica il GUID del rigo
        SetRowGUID(DC, yy);
        // Effettua l'inserimento dei righi selezionati nell'archivio
        // temporaneo dei righi selezionati per essere importati in altri documenti.
        // ------------------------------------------------------------------------
        // Se il rigo è tra quelli selezionati, procede alla suo esportazione.
        Qry.SQL.Clear;
        Qry.SQL.Add
          ('insert into tmprighi (STATION_ID, TipoDocumento, Registro, NumOrdPrev, DataDocumento, ProgRigo, ProgRigo2, CodiceCliente, CodiceArticolo, CodiceArticoloStm, Pratica, DataPratica,');
        Qry.SQL.Add
          ('CodiceIVA, DescrizioneIVA, AliquotaIVA, Descrizione, PrezzoUnitario, PrezzoUnitarioIVACompresa, QTA, ScontoRigo, ScontoRigo2, ScontoRigo3, UnitaDiMisura, PrezzoAcquistoArticolo,');
        Qry.SQL.Add
          ('Margine, ImportoMargine, NoteRigo, MovMag, QtaOpera, CodiceMagazzino, CodiceMagazzino2, MinutiPrevisti, Tipo1, Tipo2, Tipo3, Tipo4, Tipo5, Tipo6,');
        Qry.SQL.Add('SOTTOCANTIERE1, SOTTOCANTIERE2, SOTTOCANTIERE3, SOTTOCANTIERE4, SOTTOCANTIERE5, SOTTOCANTIERE6,');
        Qry.SQL.Add('GUID_REF, GUID_ANCESTOR, RAGSOCCLI, DESCPRATICA, EXTRA_RIFERIMENTO,');
        Qry.SQL.Add('RowType, RowSection, RowPrintPrices, PrezzoUnitarioAutocalc)');
        Qry.SQL.Add('values (');
        Qry.SQL.Add(DM1.CodiceUtente + ',');
        Qry.SQL.Add('''' + TipoDoc + ''',');
        Qry.SQL.Add('''' + Registro + ''',');
        Qry.SQL.Add(IntToStr(NumeroDoc) + ',');
        Qry.SQL.Add('''' + FormatDateTime('mm/dd/yyyy', DataDoc) + ''',');
        Qry.SQL.Add(IntToStr(PR + i) + ',');
        Qry.SQL.Add(IntToStr(yy) + ',');
        Qry.SQL.Add(IntToStr(QryDocumentoCODICECLIENTE.AsInteger) + ',');
        Qry.SQL.Add(DM1.StrVarToSQL(DC.Values[yy, tvCorpoCODICEARTICOLO.Index]) + ',');
        Qry.SQL.Add(DM1.StrVarToSQL(DC.Values[yy, tvCorpoCODICEARTICOLOSTM.Index]) + ',');
        Qry.SQL.Add(IntToStr(QryDocumentoPRATICA.AsInteger) + ',');
        Qry.SQL.Add('''' + FormatDateTime('mm/dd/yyyy', QryDocumentoDATAPRATICA1.AsDateTime) + ''',');
        Qry.SQL.Add(DM1.IntVarToSQL(DC.Values[yy, tvCorpoCODICEIVA.Index]) + ',');
        Qry.SQL.Add(DM1.StrVarToSQL(DC.Values[yy, tvCorpoDESCRIZIONEIVA.Index]) + ',');
        Qry.SQL.Add(DM1.FloatVarToSQL(DC.Values[yy, tvCorpoALIQUOTAIVA.Index]) + ',');
        Qry.SQL.Add(DM1.StrVarToSQL(DM1.StrLeft(DC.DisplayTexts[yy, tvCorpoDESCRIZIONE.Index], 5000)) + ',');
        Qry.SQL.Add(DM1.FloatVarToSQL(DC.Values[yy, tvCorpoPREZZOUNITARIO.Index]) + ',');
        Qry.SQL.Add(DM1.FloatVarToSQL(DC.Values[yy, tvCorpoPREZZOUNITARIOIVACOMPRESA.Index]) + ',');
        Qry.SQL.Add(DM1.FloatVarToSQL(DC.Values[yy, tvCorpoQTA.Index]) + ',');
        Qry.SQL.Add(DM1.FloatVarToSQL_DefaultIfNull(DC.Values[yy, tvCorpoSCONTORIGO.Index], '0') + ',');
        Qry.SQL.Add(DM1.FloatVarToSQL_DefaultIfNull(DC.Values[yy, tvCorpoSCONTORIGO2.Index], '0') + ',');
        Qry.SQL.Add(DM1.FloatVarToSQL_DefaultIfNull(DC.Values[yy, tvCorpoSCONTORIGO3.Index], '0') + ',');
        Qry.SQL.Add(DM1.StrVarToSQL(DC.Values[yy, tvCorpoUNITADIMISURA.Index]) + ',');
        Qry.SQL.Add(DM1.FloatVarToSQL(DC.Values[yy, tvCorpoPREZZOACQUISTOARTICOLO.Index]) + ',');
        Qry.SQL.Add(DM1.FloatVarToSQL(DC.Values[yy, tvCorpoMARGINE.Index]) + ',');
        Qry.SQL.Add(DM1.FloatVarToSQL(DC.Values[yy, tvCorpoIMPORTOMARGINE.Index]) + ',');
        Qry.SQL.Add(AnsiQuotedStr(DM1.NoNullStringValue(DC, yy, tvCorpoNOTERIGO.Index), '''') + ',');
        Qry.SQL.Add(AnsiQuotedStr(QryDocumentoSEGNOOPERAZIONE.AsString, '''') + ',');
        Qry.SQL.Add(DM1.FloatVarToSQL(DC.Values[yy, tvCorpoQTAOPERA.Index]) + ',');
        Qry.SQL.Add(DM1.IntVarToSQL(DC.Values[yy, tvCorpoCODICEMAGAZZINO.Index]) + ',');
        Qry.SQL.Add(DM1.IntVarToSQL(DC.Values[yy, tvCorpoCODICEMAGAZZINO2.Index]) + ',');
        Qry.SQL.Add(DM1.IntVarToSQL(DC.Values[yy, tvCorpoMINUTIPREVISTI.Index]) + ',');
        Qry.SQL.Add(DM1.StrVarToSQL(DC.Values[yy, tvCorpoTIPO1.Index]) + ',');
        Qry.SQL.Add(DM1.StrVarToSQL(DC.Values[yy, tvCorpoTIPO2.Index]) + ',');
        Qry.SQL.Add(DM1.StrVarToSQL(DC.Values[yy, tvCorpoTIPO3.Index]) + ',');
        Qry.SQL.Add(DM1.StrVarToSQL(DC.Values[yy, tvCorpoTIPO4.Index]) + ',');
        Qry.SQL.Add(DM1.StrVarToSQL(DC.Values[yy, tvCorpoTIPO5.Index]) + ',');
        Qry.SQL.Add(DM1.StrVarToSQL(DC.Values[yy, tvCorpoTIPO6.Index]) + ',');
        Qry.SQL.Add(DM1.StrVarToSQL(DC.Values[yy, tvCorpoSOTTOCANTIERE1.Index]) + ',');
        Qry.SQL.Add(DM1.StrVarToSQL(DC.Values[yy, tvCorpoSOTTOCANTIERE2.Index]) + ',');
        Qry.SQL.Add(DM1.StrVarToSQL(DC.Values[yy, tvCorpoSOTTOCANTIERE3.Index]) + ',');
        Qry.SQL.Add(DM1.StrVarToSQL(DC.Values[yy, tvCorpoSOTTOCANTIERE4.Index]) + ',');
        Qry.SQL.Add(DM1.StrVarToSQL(DC.Values[yy, tvCorpoSOTTOCANTIERE5.Index]) + ',');
        Qry.SQL.Add(DM1.StrVarToSQL(DC.Values[yy, tvCorpoSOTTOCANTIERE6.Index]) + ',');
        Qry.SQL.Add(DM1.StrVarToSQL(DC.Values[yy, tvCorpoGUID_REF.Index]) + ','); // GUID_REF
        Qry.SQL.Add(DM1.StrVarToSQL(DC.Values[yy, tvCorpoGUID.Index]) + ',');
        // GUID_ANCESTOR
        Qry.SQL.Add(QuotedStr(QryDocumentoRAGSOCCLI.AsString) + ',');
        Qry.SQL.Add(QuotedStr(EditDescrizionePratica1.Text) + ',');

        // Invio la descrizione così ottenuta alla query
        Qry.SQL.Add(AnsiQuotedStr(LeftStr(Trim(ExtraRif), 200), '''') + ',');

        Qry.SQL.Add(DM1.StrVarToSQL(DC.Values[yy, tvCorpoROWTYPE.Index]) + ',');
        Qry.SQL.Add(DM1.StrVarToSQL(DC.Values[yy, tvCorpoROWSECTION.Index]) + ',');
        Qry.SQL.Add(DM1.StrVarToSQL(DC.Values[yy, tvCorpoROWPRINTPRICES.Index]) + ',');
        Qry.SQL.Add(DM1.StrVarToSQL(DC.Values[yy, tvCorpoPREZZOUNITARIOAUTOCALC.Index]));

        Qry.SQL.Add(')');
        Qry.ExecSQL;
        // Marca il rigo come Esportato.
        MarcaImportExport(DC, yy, tvCorpoSELEZIONATO.Index, FLAG_VALUE_EXPORTED);
      end;
    end;
    // ------------------------------------------------------------------------
  finally
    Qry.Free;
  end;
end;

{ procedure TPreventiviOrdiniForm.CaricaScaricaMagazzino(SegnoOperazione:String);
  var
  i: Integer;
  QryArt: TIB_Cursor;
  QryMag: TIB_Cursor;
  CodArt, CodMag, MovMag: String;
  Qta: Double;
  begin
  QryArt := TIB_Cursor.Create(Self);
  QryMag := TIB_Cursor.Create(Self);
  try
  QryArt.DatabaseName  := DM1.ArcDBFile;
  QryArt.IB_Connection := DM1.DBAzienda;
  QryMag.DatabaseName  := DM1.ArcDBFile;
  QryMag.IB_Connection := DM1.DBAzienda;
  // Cicla per tutti i righi
  for i := 0 to tvCorpo.DataController.RecordCount -1 do begin
  // Inizializzazione variabili
  CodArt := DM1.NoNullStringValue(tvCorpo.DataController, i, tvCorpoCODICEARTICOLO.Index);
  CodMag := IntToStr(DM1.NoNullIntValue(tvCorpo.DataController, i, tvCorpoCODICEMAGAZZINO.Index));
  MovMag := DM1.NoNullStringValue(tvCorpo.DataController, i, tvCorpoMOVMAG.Index);
  Qta    := DM1.NoNullFloatValue(tvCorpo.DataController, i, tvCorpoQTA.Index);
  // Query che richiama l'articolo che si sta movimentando per verificarne la presenza ed avere il valore del flag 'AbilitaMovMag'
  QryArt.SQL.Clear;
  QryArt.SQL.Add('SELECT ABILITAMOVMAG FROM ARTICOLI WHERE CODICEARTICOLO = ''' + CodArt + '''');
  QryArt.Open;
  // Se ha trovato l'articolo...
  if not QryArt.Eof then begin
  // Se è abilitata la movimentazione di magazzino dell'articolo
  if QryArt.FieldByName('AbilitaMovMag').Value <> 'F' then begin
  // Effettua lo scarico o il carico di magazzino in base al tipo di documento
  //  in cui mi trovo.
  // -------------------------------------
  // Se il segno operazione della causale del documento indica che IMPEGNA la merce provvede a farlo
  //  controllando ovviamente che il rigo non sia già stato movimentato.
  if (SegnoOperazione = 'I') and (MovMag <> 'I') then begin
  // Query che effettua la movimentazione
  QryMag.SQL.Clear;
  QryMag.SQL.Add('UPDATE MAGAZZINI SET');
  QryMag.SQL.Add('IMPEGNATO = IMPEGNATO + ' + DM1.VirgolaPunto(Qta) + ',');
  QryMag.SQL.Add('DISPONIBILE = GIACENZA - IMPEGNATO,');
  QryMag.SQL.Add('SINCHRO = ''' + RECORD_MODIFIED + '''');
  QryMag.SQL.Add('WHERE CODICEMAGAZZINO = ' + CodMag + ' AND CODICEARTICOLO = ''' + CodArt + '''');
  QryMag.ExecSQL;
  // Marca il rigo corrente gome già movimentato in magazzino
  tvCorpo.DataController.Values[i, tvCorpoMOVMAG.Index] := 'I';
  // Se il segno operazione della causale del documento indica che deve SCARICARE la merce provvede a farlo
  //  e se il campo 'MovMag' <> '=' e anche <> '-' che significa che il rigo è già stato movimentato, oppure che proviene da un altro
  //  documento che ne ha già effettuato lo scarico (e quindi diventa inerte e non
  //  più movimentabile in alcun modo).
  end else if (SegnoOperazione = '-') and (MovMag <> '=') and (MovMag <> '-') then begin
  // Query che effettua la movimentazione
  QryMag.SQL.Clear;
  QryMag.SQL.Add('UPDATE MAGAZZINI SET');
  // Se è marcato 'I' significa che è un rigo proveniente da un Ordine cliente
  //  nel quale è stato eseguito l'impegno della merce e quindi sottrae la
  //  quantità del rigo dalla merce impegnata.
  if MovMag = 'I' then QryMag.SQL.Add('IMPEGNATO = IMPEGNATO - ' + DM1.VirgolaPunto(Qta) + ',');
  QryMag.SQL.Add('GIACENZA = GIACENZA - ' + DM1.VirgolaPunto(Qta) + ',');
  QryMag.SQL.Add('DISPONIBILE = GIACENZA - IMPEGNATO,');
  QryMag.SQL.Add('SINCHRO = ''' + RECORD_MODIFIED + '''');
  QryMag.SQL.Add('WHERE CODICEMAGAZZINO = ' + CodMag + ' AND CODICEARTICOLO = ''' + CodArt + '''');
  QryMag.ExecSQL;
  // Marca il rigo corrente gome già movimentato in magazzino
  tvCorpo.DataController.Values[i,tvCorpoMOVMAG.Index] := '-';
  // Se il segno operazione della causale del documento indica che deve CARICARE la merce provvede a farlo
  //  e se il campo 'MovMag' <> '='  e anche <> '+' che significa che il rigo è già movimentato oppure che proviene da un altro
  //  documento che ne ha già effettuato il carico (e quindi diventa inerte e non
  //  più movimentabile in alcun modo).
  end else if (SegnoOperazione = '+') and (MovMag <> '=') and (MovMag <> '+') then begin
  // Query che effettua la movimentazione
  QryMag.SQL.Clear;
  QryMag.SQL.Add('UPDATE MAGAZZINI SET');
  // Se è marcato 'I' significa che è un rigo proveniente da un Ordine cliente
  //  nel quale è stato eseguito l'impegno della merce e quindi sottrae la
  //  quantità del rigo dalla merce impegnata.
  if MovMag = 'O' then QryMag.SQL.Add('ORDINATO = ORDINATO - ' + DM1.VirgolaPunto(Qta) + ',');
  QryMag.SQL.Add('GIACENZA = GIACENZA + ' + DM1.VirgolaPunto(Qta) + ',');
  QryMag.SQL.Add('DISPONIBILE = GIACENZA - IMPEGNATO,');
  QryMag.SQL.Add('SINCHRO = ''' + RECORD_MODIFIED + '''');
  QryMag.SQL.Add('WHERE CODICEMAGAZZINO = ' + CodMag + ' AND CODICEARTICOLO = ''' + CodArt + '''');
  QryMag.ExecSQL;
  // Marca il rigo corrente gome già movimentato in magazzino
  tvCorpo.DataController.Values[i,tvCorpoMOVMAG.Index] := '+';
  // Se il segno operazione della causale del documento indica che deve ORDINARE la merce provvede a farlo
  //  e se il campo 'MovMag' <> 'O' cioè se non è già stato ordinato, lo ordina.
  end else if (SegnoOperazione = 'O') and (MovMag <> 'O') then begin
  // Query che effettua la movimentazione
  QryMag.SQL.Clear;
  QryMag.SQL.Add('UPDATE MAGAZZINI SET');
  QryMag.SQL.Add('ORDINATO = ORDINATO + ' + DM1.Virgola(Qta) + ',');
  QryMag.SQL.Add('SINCHRO = ''' + RECORD_MODIFIED + '''');
  QryMag.SQL.Add('WHERE CODICEMAGAZZINO = ' + CodMag + ' AND CODICEARTICOLO = ''' + CodArt + '''');
  QryMag.ExecSQL;
  // Marca il rigo corrente gome già movimentato in magazzino
  tvCorpo.DataController.Values[i,tvCorpoMOVMAG.Index] := 'O';
  end;
  end;
  end;
  QryArt.Close;
  end;
  finally
  QryArt.Close;
  QryMag.Close;
  QryArt.Free;
  QryMag.Free;
  end;
  end;
}

// Procedura che verifica se ci sono articoli nel documento che non sono presenti nell'archivio articoli
// e se ne trova propone un loro inserimento automatico.
procedure TPreventiviOrdiniForm.ControllaNuoviArticoliDaInserire(DC: TcxCustomDataController);
var
  i: Integer;
  CodArt, DescArt: String;
  LFirstTime: Boolean;
begin
  LFirstTime := True;
  // Cicla per tutti i righi del documento
  for i := 0 to DC.RecordCount - 1 do
  begin
    // Carica il Codice Articolo del rigo corrente
    CodArt := Trim(DM1.NoNullStringValue(DC, i, tvCorpoCODICEARTICOLO.Index));
    DescArt := Trim(DM1.NoNullStringValue(DC, i, tvCorpoDESCRIZIONE.Index));
    // Verifica se l'articolo del rigo corrente esiste nell'archivio corrente
    // e se non esiste...
    // Prima verifica che il codice articolo del rigo corrente sia valido
    if (CodArt <> '') and (not DM1.CodiceIsManodopera(CodArt)) and (not DM1.ArticoloExist(CodArt)) then
    begin
      // Richiede una prima autorizzazione complessiva a procedere o meno per tutti gli eventuali articoli
      // da creare automaticamente
      if LFirstTime and (DM1.Messaggi('Creazione automatica articoli',
        'A T T E N Z I O N E !!!'#13#13'Ci sono alcuni articoli non presenti nel listino/anagrafiche articoli.'#13#13'Vuoi che li elenco per decidere se crearli automaticamente?',
        'NB: Se si risponde "SI" verranno elencati gli articoli interessati e si potrà decidere singolarmente se creare la relativa scheda anagrafica/listino oppure no.',
        [mbYes, mbNo], 0, nil) <> mrYes) then
        Exit;
      LFirstTime := False;
      // Chiede conferma all'utente se lo vuole inserire automaticamente
      if DM1.Messaggi('Nuovo articolo', 'L''articolo "' + CodArt + ' - ' + DM1.NoNullStringValue(DC, i, tvCorpoDESCRIZIONE.Index) +
        '" non è presente nell''archivio articoli.'#13#13'Inserire automaticamente l''articolo nell''archivio?',
        'NB: Annotare il codice dell''articolo per poi andarlo a completare con i dati mancanti.', [mbYes, mbNo], 0, nil) = mrYes then
      begin
        // Carica l'articolo del rigo corrente nell'archivio articoli
        DM1.NuovoArticolo(CodArt, DescArt, DM1.NoNullStringValue(DC, i, tvCorpoUNITADIMISURA.Index), DM1.NoNullFloatValue(DC, i, tvCorpoPREZZOUNITARIO.Index),
          DM1.NoNullFloatValue(DC, i, tvCorpoSCONTORIGO.Index), DM1.NoNullFloatValue(DC, i, tvCorpoSCONTORIGO2.Index),
          DM1.NoNullFloatValue(DC, i, tvCorpoSCONTORIGO3.Index));
      end;
    end;
  end;
end;

procedure TPreventiviOrdiniForm.CalcolaTotali(const AForceRecalc: Boolean);
begin
  if FSospendiCalcoloTotali and not AForceRecalc then
    Exit;
  // B: Se il documento è a sola lettura ovviamente esce subito
  // NB: Se siamo in modalità fatturazione differita disabilita i calcoli automatici
  // perchè darebbero fastidio
  if SolaLettura or ((Tag = MODE_FATTURAZIONE_DIFFERITA) and not AForceRecalc) then
    Exit;
  // Se abilitato e necessario ricalcola i totali del documento
  if fCalcoloTotaliACorpoAutomatico or fCalcoloBeniSignificativiAutomatico or fCalcoloTotaliAutomatico or fRaggruppamentoSezioni or AForceRecalc then
  begin
    if DM1.ScorporoIVA then
      CalcolaTotaliConScorporoIVA(fCalcoloTotaliAutomatico or AForceRecalc)
    else
      CalcolaTotaliNormale(fCalcoloTotaliAutomatico or AForceRecalc);
  end;
  // ---------- OLD CODE ----------
  // // Se abilitato e necessario ricalcola i totali del documento
  // if fCalcoloTotaliAutomatico or AForceRecalc then
  // begin
  // if DM1.ScorporoIVA then
  // CalcolaTotaliConScorporoIVA
  // else
  // CalcolaTotaliNormale;
  // end;
  // ---------- OLD CODE ----------
end;

procedure TPreventiviOrdiniForm.CalcolaTotaliNormale(const ACalcolaTotali: Boolean);
var
  TempTotal1, TempTotal2, TempTotal3, TempTotal4, CostoTot, AliquotaIVARigo, ImportoRigo, QtaRigo, PrzAcqRigo, ImponibileRitAcc,
    LBolloImportoDaAggiungereAiTotali: Double;
  i, CI1, CI2, CI3, CI4, CIRigo, RI: Integer;
  IVAIndex, DescIVARigo: String;
begin
  // Pone la griglia in modalità di Update per velucizzare le operazioni
  // NB: Migliora notevolmente la valocità nel caso di modifica di un  sottorigo di
  // un rigo composto.
  // tvCorpo.DataController.BeginFullUpdate;
  GridCorpo.BeginUpdate;
  // Reset del sistema di gestione di totali a corpo
  FTotaleCorpo.Clear;
  // Fattura beni significativi e non sigficativi automatica
  if fCalcoloBeniSignificativiAutomatico then
    ControlloBeniSignificativi(tvCorpo.DataController);
  // Avvia il sistema che determina se deve essere attivata la visualizzazione raggruppata
  // per sezione oppure no.
  TSectionGrouped.StartCheck;
  // Disabilita/Riabilita l'eventhandler per il ricalcolo della ritenuta d'acconto alla modifica di uno dei dati relativi
  QryDocumentoRITACCPERCIMPONIBILE.OnValidate := nil;
  QryDocumentoRITACCIMPONIBILE.OnValidate := nil;
  try
    // Azzera i totali
    TempTotal1 := 0;
    TempTotal2 := 0;
    TempTotal3 := 0;
    TempTotal4 := 0;
    CostoTot := 0;
    // Carica i codici IVA del documento nelle variabili temporanee
    CI1 := 0;
    CI2 := 0;
    CI3 := 0;
    CI4 := 0;
    // Azzera i codici IVA del documento
    QryDocumentoCODICEIVA1.Value := 0;
    QryDocumentoCODICEIVA2.Value := 0;
    QryDocumentoCODICEIVA3.Value := 0;
    QryDocumentoCODICEIVA4.Value := 0;

    // Cicla per tutti i righi del documento per costruire i 4 totali delle aliquote
    // NB: Modificato per fare in modo che funzionasse correttamente
    // il nuovo totale a corpo che necessitava di ciclare per le righe del documento
    // nell'ordine in cui queste appaiono sullo schermo (RowIndex), poi però
    // valorizzo anche la variabile i con il RecordIndex in modo che tutto il resto continuasse
    // a funzionare come prima.
    // NB: Ho divuto mettere anche la condizione "if i >= tvCorpo.DataController.RecordCount" subito sotto
    // a quanto sopra scritto perchè si verificava una discrepanza durante l'eliminazione di un rigo tra il RowCount ViewData
    // e il RecordCount nel DataController, in pratica nel DataController i record erano già eliminati
    // mentre nel ViewData invece risultavano ancora presenti, questo generava un errore ovviamente
    // quando cercava di accedere al record nel DataController con un indice che non esiste più.
    // for i := 0 to tvCorpo.DataController.RecordCount - 1 do
    // begin
    for RI := 0 to tvCorpo.ViewData.RowCount - 1 do
    begin
      i := tvCorpo.ViewData.Rows[RI].RecordIndex;
      if i >= tvCorpo.DataController.RecordCount then
        break;
      // Calcola i totali degli eventuali sottorighi del rigo attuale
      // NB: Deve rimanere prima del calcolo dei totali a corpo
      if ACalcolaTotali then
        CalcolaTotaliSottorighi(tvCorpo.DataController, i);
      // Carica alcune variabili con i valori del rigo corrente
      CIRigo := DM1.NoNullIntValue(tvCorpo.DataController, i, tvCorpoCODICEIVA.Index);
      // --------------------------------------------------------------------------------------
      // Check del sistema che determina se deve essere attivata la visualizzazione raggruppata
      // per sezione oppure no.
      if fRaggruppamentoSezioni then
        TSectionGrouped.CheckRow(tvCorpo.DataController, i);
      // Verifica il rigo attuale per la gestione del totale a corpo
      // NB: Salta i righi di riferimento
      if fCalcoloTotaliACorpoAutomatico and (CIRigo <> -9) then
        FTotaleCorpo.CheckRow(RI);
      // Se non deve ricalcolare i totali del documento continua al prossimo rigo
      if not ACalcolaTotali then
        Continue;
      // --------------------------------------------------------------------------------------
      // Carica alcune variabili con i valori del rigo corrente
      // CIRigo := DM1.NoNullIntValue(tvCorpo.DataController, i, tvCorpoCODICEIVA.Index); // NB: Sposta più sopra perchè serviva per il totale a corpo
      DescIVARigo := DM1.NoNullStringValue(tvCorpo.DataController, i, tvCorpoDESCRIZIONEIVA.Index);
      AliquotaIVARigo := DM1.NoNullFloatValue(tvCorpo.DataController, i, tvCorpoALIQUOTAIVA.Index);
      ImportoRigo := DM1.NoNullFloatValue(tvCorpo.DataController, i, tvCorpoIMPORTORIGO.Index);
      QtaRigo := DM1.NoNullFloatValue(tvCorpo.DataController, i, tvCorpoQTA.Index);
      PrzAcqRigo := DM1.NoNullFloatValue(tvCorpo.DataController, i, tvCorpoPREZZOACQUISTOARTICOLO.Index);
      // Se il codice IVA del rigo = -9 significa che è un rigo descrittivo senza importo
      // e quindi non deve essere inserito nei calcoli per i totali del documento
      // (es: i righi di riferimento ad altri documenti)
      // NB: Anche se si tratta di righi marcati come BeniSignificativi o Beni NonSignificativi o cmq
      // che sono marcati come righi da non considerare nel calcolo dei totali (RowType che finisce con il carattere "_" underscore)
      if (CIRigo = -9) or (RightStr(VarToStr(tvCorpo.DataController.Values[i, tvCorpoROWTYPE.Index]), 1) = TIPORIGODOC_CHAR_GRAYED) or
        (not tvCorpo.ViewData.Rows[RI].IsData) then
        Continue;
      // Controlla se l'aliquota del rigo è già inserita nel castelletto IVA
      // e se non lo è la inserisce nel primo rigo di castelletto libero.
      if (CI1 = 0) or (CI1 = CIRigo) then
      begin
        if CI1 = 0 then
        begin
          CI1 := CIRigo;
          QryDocumentoCODICEIVA1.Value := CI1;
          QryDocumentoDescrizioneIVA1.Value := DescIVARigo;
          QryDocumentoALIQUOTAIVA1.Value := AliquotaIVARigo;
        end;
        TempTotal1 := TempTotal1 + ImportoRigo;
      end
      else if (CI2 = 0) or (CI2 = CIRigo) then
      begin
        if CI2 = 0 then
        begin
          CI2 := CIRigo;
          QryDocumentoCODICEIVA2.Value := CI2;
          QryDocumentoDescrizioneIVA2.Value := DescIVARigo;
          QryDocumentoALIQUOTAIVA2.Value := AliquotaIVARigo;
        end;
        TempTotal2 := TempTotal2 + ImportoRigo;
      end
      else if (CI3 = 0) or (CI3 = CIRigo) then
      begin
        if CI3 = 0 then
        begin
          CI3 := CIRigo;
          QryDocumentoCODICEIVA3.Value := CI3;
          QryDocumentoDescrizioneIVA3.Value := DescIVARigo;
          QryDocumentoALIQUOTAIVA3.Value := AliquotaIVARigo;
        end;
        TempTotal3 := TempTotal3 + ImportoRigo;
      end
      else if (CI4 = 0) or (CI4 = CIRigo) then
      begin
        if CI4 = 0 then
        begin
          CI4 := CIRigo;
          QryDocumentoCODICEIVA4.Value := CI4;
          QryDocumentoDescrizioneIVA4.Value := DescIVARigo;
          QryDocumentoALIQUOTAIVA4.Value := AliquotaIVARigo;
        end;
        TempTotal4 := TempTotal4 + ImportoRigo;
      end;
      // Aggiorna il calcolo del costo totale delle merci del documento per poi
      // calcolare il margine totale del documento
      // NB: Arrotonda per il DecMicroPrz e solo alla fine Arrotonda il Totalealle 2 cifre canoniche degli euro
      CostoTot := CostoTot + (PrzAcqRigo * QtaRigo);
    end;

    // --------------------------------------------------------------------------------------
    // Se non deve ricalcolare i totali del documento esce
    if not ACalcolaTotali then
      Exit;
    // --------------------------------------------------------------------------------------

    // Aggiorna la tabella dei documenti con in nuovi totali
    QryDocumentoTOTALERIGHI1.Value := DM1.Arrotonda(TempTotal1, FormatSettings.CurrencyDecimals);
    QryDocumentoTOTALERIGHI2.Value := DM1.Arrotonda(TempTotal2, FormatSettings.CurrencyDecimals);
    QryDocumentoTOTALERIGHI3.Value := DM1.Arrotonda(TempTotal3, FormatSettings.CurrencyDecimals);
    QryDocumentoTOTALERIGHI4.Value := DM1.Arrotonda(TempTotal4, FormatSettings.CurrencyDecimals);
    QryDocumentoTOTALEMERCE.Value := QryDocumentoTOTALERIGHI1.Value + QryDocumentoTOTALERIGHI2.Value + QryDocumentoTOTALERIGHI3.Value +
      QryDocumentoTOTALERIGHI4.Value;
    // Calcola i TOTALI IMPONIBILI
    QryDocumentoTOTALEIMPONIBILE1.Value := QryDocumentoTOTALERIGHI1.Value - DM1.Arrotonda(QryDocumentoTOTALERIGHI1.Value / 100 * QryDocumentoSCONTOALIQUOTA1.Value, FormatSettings.CurrencyDecimals);
    QryDocumentoTOTALEIMPONIBILE2.Value := QryDocumentoTOTALERIGHI2.Value - DM1.Arrotonda(QryDocumentoTOTALERIGHI2.Value / 100 * QryDocumentoSCONTOALIQUOTA2.Value, FormatSettings.CurrencyDecimals);
    QryDocumentoTOTALEIMPONIBILE3.Value := QryDocumentoTOTALERIGHI3.Value - DM1.Arrotonda(QryDocumentoTOTALERIGHI3.Value / 100 * QryDocumentoSCONTOALIQUOTA3.Value, FormatSettings.CurrencyDecimals);
    QryDocumentoTOTALEIMPONIBILE4.Value := QryDocumentoTOTALERIGHI4.Value - DM1.Arrotonda(QryDocumentoTOTALERIGHI4.Value / 100 * QryDocumentoSCONTOALIQUOTA4.Value, FormatSettings.CurrencyDecimals);
    QryDocumentoTOTALENETTOMERCE.Value := QryDocumentoTOTALEIMPONIBILE1.Value + QryDocumentoTOTALEIMPONIBILE2.Value + QryDocumentoTOTALEIMPONIBILE3.Value +
      QryDocumentoTOTALEIMPONIBILE4.Value;
    // Calcola il totale sconti
    QryDocumentoTOTALESCONTI.Value := QryDocumentoTOTALEMERCE.Value - QryDocumentoTOTALENETTOMERCE.Value;

    // Aggiunge le spese all'aliquota IVA ordinaria corrente
    // --------------------------------------------------------------------------------------------------------------------------------
    // Calcola le spese
    Self.CalcolaSpese(TempTotal1, TempTotal2, TempTotal3, TempTotal4);
    // --------------------------------------------------------------------------------------------------------------------------------

    // Aggiunge l'eventuale bollo all'apposita aliquota IVA
    // --------------------------------------------------------------------------------------------------------------------------------
    // Calcola il bollo e se abilitato lo applica automaticamente
    LBolloImportoDaAggiungereAiTotali := CalcolaBollo(TempTotal1, TempTotal2, TempTotal3, TempTotal4);
    // --------------------------------------------------------------------------------------------------------------------------------

    // Calcola il totale imponibile comprensivo delle spese e del bollo
    QryDocumentoTOTALEIMPONIBILE.Value := QryDocumentoTOTALENETTOMERCE.Value + QryDocumentoSPESE.Value + LBolloImportoDaAggiungereAiTotali;
    // Calcola gli IMPORTI IVA
    QryDocumentoIMPORTOIVA1.Value := DM1.Arrotonda(QryDocumentoTOTALEIMPONIBILE1.Value * QryDocumentoALIQUOTAIVA1.Value / 100, FormatSettings.CurrencyDecimals);
    QryDocumentoIMPORTOIVA2.Value := DM1.Arrotonda(QryDocumentoTOTALEIMPONIBILE2.Value * QryDocumentoALIQUOTAIVA2.Value / 100, FormatSettings.CurrencyDecimals);
    QryDocumentoIMPORTOIVA3.Value := DM1.Arrotonda(QryDocumentoTOTALEIMPONIBILE3.Value * QryDocumentoALIQUOTAIVA3.Value / 100, FormatSettings.CurrencyDecimals);
    QryDocumentoIMPORTOIVA4.Value := DM1.Arrotonda(QryDocumentoTOTALEIMPONIBILE4.Value * QryDocumentoALIQUOTAIVA4.Value / 100, FormatSettings.CurrencyDecimals);
    QryDocumentoTOTALEIVA.Value := QryDocumentoIMPORTOIVA1.Value + QryDocumentoIMPORTOIVA2.Value + QryDocumentoIMPORTOIVA3.Value +
      QryDocumentoIMPORTOIVA4.Value;

    // Se è selezionato il calcolo della ritenuta d'acconto su imponibile inserito dall'utente
    // calcola la percentuale di imponibile corrispondente (giusto per avere un dato coerente perchè in
    // realtà non la usa nemmeno) e poi calcola l'importo della ritenuta d'acconto.
    if QryDocumentoRITACCSUIMPORTOIMP.AsString = 'T' then
    begin
      if (not QryDocumentoTOTALENETTOMERCE.IsNull) and (QryDocumentoTOTALENETTOMERCE.AsFloat <> 0) then
        QryDocumentoRITACCPERCIMPONIBILE.Value := DM1.Arrotonda((QryDocumentoRITACCIMPONIBILE.AsFloat * 100 / QryDocumentoTOTALENETTOMERCE.AsFloat), FormatSettings.CurrencyDecimals)
      else
        QryDocumentoRITACCPERCIMPONIBILE.Value := 0;
    end
    // Se è selezionato il calcolo della ritenuta d'acconto su percentuale di imponibile
    // calcola prima l'imponibile corrispondente come base per il calcolo della ritenuta stessa
    // e poi calcola la ritenuta d'acconto
    else
    begin
      QryDocumentoRITACCIMPONIBILE.Value := DM1.Arrotonda((QryDocumentoTOTALENETTOMERCE.AsFloat * (QryDocumentoRITACCPERCIMPONIBILE.AsFloat / 100)), FormatSettings.CurrencyDecimals);
    end;
    // Calcola la ritenuta d'acconto
    QryDocumentoRITACC.Value := DM1.Arrotonda((QryDocumentoRITACCIMPONIBILE.AsFloat * (QryDocumentoRITACCPERC.AsFloat / 100) * (-1)), FormatSettings.CurrencyDecimals);

    // Calcola il TOTALI DOCUMENTO con anche l'eventuale abbuono e la ritenuta d'acconto
    QryDocumentoTOTALEDOCUMENTO.Value := QryDocumentoTOTALEIMPONIBILE.Value + QryDocumentoTOTALEIVA.Value;
    // Calcolo dello sconto finale
    CalcolaAbbuonoSePercentuale(QryDocumentoTOTALEDOCUMENTO.Value);
    QryDocumentoTOTALEDAPAGARE.Value := QryDocumentoTOTALEDOCUMENTO.Value + QryDocumentoRITACC.Value - QryDocumentoTOTALESPLITPAYMENT.Value - QryDocumentoABBUONO.AsFloat;
    // Calcola il mergine totale del documento e aggiorna la Caption del pulsate di visualizzazione del totale margine documento
    QryDocumentoTOTALEMARGINE.Value := QryDocumentoTOTALENETTOMERCE.Value - CostoTot;
    // Rende visibili solo i righi del castelletto IVA che non sono vuoti
    ControllaVisualizzazioneCastellettoIVA;
  finally
    // Disabilita/Riabilita l'eventhandler per il ricalcolo della ritenuta d'acconto alla modifica di uno dei dati relativi
    QryDocumentoRITACCPERCIMPONIBILE.OnValidate := QryDocumentoRicalcolaDocumentoEventHandler;
    QryDocumentoRITACCIMPONIBILE.OnValidate := QryDocumentoRicalcolaDocumentoEventHandler;
    // Termina il sistema che determina se deve essere attivata la visualizzazione raggruppata
    // per sezione oppure no.
    if fRaggruppamentoSezioni then
      TSectionGrouped.EndCheck;
    // Pone la griglia in modalità di Update per velucizzare le operazioni
    // NB: Migliora notevolmente la valocità nel caso di modifica di un  sottorigo di
    // un rigo composto.
    // tvCorpo.DataController.EndFullUpdate;
    GridCorpo.EndUpdate;
  end;
end;

procedure TPreventiviOrdiniForm.CalcolaTotaliConScorporoIVA(const ACalcolaTotali: Boolean);
var
  TempTotal1, TempTotal2, TempTotal3, TempTotal4, CostoTot, AliquotaIVARigo, ImportoRigo, PrzAcqRigo, QtaRigo, ImponibileRitAcc: Double;
  i, CI1, CI2, CI3, CI4, CIRigo, RI: Integer;
  PrecTotaliRealTime: Boolean;
  IVAIndex, DescIVARigo: String;
begin
  // Pone la griglia in modalità di Update per velucizzare le operazioni
  // NB: Migliora notevolmente la valocità nel caso di modifica di un  sottorigo di
  // un rigo composto.
  // tvCorpo.DataController.BeginFullUpdate;
  GridCorpo.BeginUpdate;
  // Reset del sistema di gestione di totali a corpo
  FTotaleCorpo.Clear;
  // Se è una fattura di vendita controlla il discorso dei beni significativi e non significativi aggiungendo
  // le relative righe di riepilogo all'occorrenza.
  // Controlla solo le prime 7 lettere del TipoDoc perchè così funziona anche per le
  // Fatture R.F.
  // NB: ATUALMENTE E' DISABILITATO PERCHE' NON FUNZIONA BENE CON LO SCORPORO IVA E POI NON SERVE NEMMENO
  // if fCalcoloBeniSignificativiAutomatico then
  // ControlloBeniSignificativi(tvCorpo.DataController);

  // Avvia il sistema che determina se deve essere attivata la visualizzazione raggruppata
  // per sezione oppure no.
  TSectionGrouped.StartCheck;
  // Disabilita/Riabilita l'eventhandler per il ricalcolo della ritenuta d'acconto alla modifica di uno dei dati relativi
  QryDocumentoRITACCPERCIMPONIBILE.OnValidate := nil;
  QryDocumentoRITACCIMPONIBILE.OnValidate := nil;
  try
    // Inizializzazione
    TempTotal1 := 0;
    TempTotal2 := 0;
    TempTotal3 := 0;
    TempTotal4 := 0;
    CostoTot := 0;
    // Carica i codici IVA del documento nelle variabili temporanee
    CI1 := 0;
    CI2 := 0;
    CI3 := 0;
    CI4 := 0;
    // Azzera i codici IVA del documento
    QryDocumentoCODICEIVA1.Value := 0;
    QryDocumentoCODICEIVA2.Value := 0;
    QryDocumentoCODICEIVA3.Value := 0;
    QryDocumentoCODICEIVA4.Value := 0;

    // Cicla per tutti i righi del documento per costruire i 4 totali delle aliquote
    // NB: Modificato per fare in modo che funzionasse correttamente
    // il nuovo totale a corpo che necessitava di ciclare per le righe del documento
    // nell'ordine in cui queste appaiono sullo schermo (RowIndex), poi però
    // valorizzo anche la variabile i con il RecordIndex in modo che tutto il resto continuasse
    // a funzionare come prima.
    // NB: Ho divuto mettere anche la condizione "if i >= tvCorpo.DataController.RecordCount" subito sotto
    // a quanto sopra scritto perchè si verificava una discrepanza durante l'eliminazione di un rigo tra il RowCount ViewData
    // e il RecordCount nel DataController, in pratica nel DataController i record erano già eliminati
    // mentre nel ViewData invece risultavano ancora presenti, questo generava un errore ovviamente
    // quando cercava di accedere al record nel DataController con un indice che non esiste più.
    // for i := 0 to tvCorpo.DataController.RecordCount - 1 do
    // begin
    for RI := 0 to tvCorpo.ViewData.RowCount - 1 do
    begin
      i := tvCorpo.ViewData.Rows[RI].RecordIndex;
      if i >= tvCorpo.DataController.RecordCount then
        break;
      // Calcola i totali degli eventuali sottorighi del rigo attuale
      // NB: Deve rimanere prima del calcolo dei totali a corpo
      if ACalcolaTotali then
        CalcolaTotaliSottorighi(tvCorpo.DataController, i);
      // --------------------------------------------------------------------------------------
      // Check del sistema che determina se deve essere attivata la visualizzazione raggruppata
      // per sezione oppure no.
      if fRaggruppamentoSezioni then
        TSectionGrouped.CheckRow(tvCorpo.DataController, i);
      // Verifica il rigo attuale per la gestione del totale a corpo
      // NB: Salta i righi di riferimento
      if fCalcoloTotaliACorpoAutomatico and (CIRigo <> -9) then
        FTotaleCorpo.CheckRow(RI);
      // Se non deve ricalcolare i totali del documento continua al prossimo rigo
      if not ACalcolaTotali then
        Continue;
      // --------------------------------------------------------------------------------------
      // Carica alcune variabili con i valori del rigo corrente
      CIRigo := DM1.NoNullIntValue(tvCorpo.DataController, i, tvCorpoCODICEIVA.Index);
      DescIVARigo := DM1.NoNullStringValue(tvCorpo.DataController, i, tvCorpoDESCRIZIONEIVA.Index);
      AliquotaIVARigo := DM1.NoNullFloatValue(tvCorpo.DataController, i, tvCorpoALIQUOTAIVA.Index);
      ImportoRigo := DM1.NoNullFloatValue(tvCorpo.DataController, i, tvCorpoIMPORTORIGOIVACOMPRESA.Index);
      PrzAcqRigo := DM1.NoNullFloatValue(tvCorpo.DataController, i, tvCorpoPREZZOACQUISTOARTICOLO.Index);
      QtaRigo := DM1.NoNullFloatValue(tvCorpo.DataController, i, tvCorpoQTA.Index);
      // Se il codice IVA del rigo = -9 significa che è un rigo descrittivo senza importo
      // e quindi non deve essere inserito nei calcoli per i totali del documento
      // (es: i righi di riferimento ad altri documenti)
      // NB: Anche se si tratta di righi marcati come BeniSignificativi o Beni NonSignificativi o cmq
      // che sono marcati come righi da non considerare nel calcolo dei totali (RowType che finisce con il carattere "_" underscore)
      if (CIRigo = -9) or (RightStr(VarToStr(tvCorpo.DataController.Values[i, tvCorpoROWTYPE.Index]), 1) = TIPORIGODOC_CHAR_GRAYED) or
        (not tvCorpo.ViewData.Rows[RI].IsData) then
        Continue;
      // Controlla se l'aliquota del rigo è già inserita nel castelletto IVA
      // e se non lo è la inserisce nel primo rigo di castelletto libero.
      if (CI1 = 0) or (CI1 = CIRigo) then
      begin
        if CI1 = 0 then
        begin
          CI1 := CIRigo;
          QryDocumentoCODICEIVA1.Value := CI1;
          QryDocumentoDescrizioneIVA1.Value := DescIVARigo;
          QryDocumentoALIQUOTAIVA1.Value := AliquotaIVARigo;
        end;
        TempTotal1 := TempTotal1 + ImportoRigo;
      end
      else if (CI2 = 0) or (CI2 = CIRigo) then
      begin
        if CI2 = 0 then
        begin
          CI2 := CIRigo;
          QryDocumentoCODICEIVA2.Value := CI2;
          QryDocumentoDescrizioneIVA2.Value := DescIVARigo;
          QryDocumentoALIQUOTAIVA2.Value := AliquotaIVARigo;
        end;
        TempTotal2 := TempTotal2 + ImportoRigo;
      end
      else if (CI3 = 0) or (CI3 = CIRigo) then
      begin
        if CI3 = 0 then
        begin
          CI3 := CIRigo;
          QryDocumentoCODICEIVA3.Value := CI3;
          QryDocumentoDescrizioneIVA3.Value := DescIVARigo;
          QryDocumentoALIQUOTAIVA3.Value := AliquotaIVARigo;
        end;
        TempTotal3 := TempTotal3 + ImportoRigo;
      end
      else if (CI4 = 0) or (CI4 = CIRigo) then
      begin
        if CI4 = 0 then
        begin
          CI4 := CIRigo;
          QryDocumentoCODICEIVA4.Value := CI4;
          QryDocumentoDescrizioneIVA4.Value := DescIVARigo;
          QryDocumentoALIQUOTAIVA4.Value := AliquotaIVARigo;
        end;
        TempTotal4 := TempTotal4 + ImportoRigo;
      end;
      // Aggiorna il calcolo del costo totale delle merci del documento per poi
      // calcolare il margine totale del documento.
      CostoTot := CostoTot + (PrzAcqRigo * QtaRigo);
    end;

    // --------------------------------------------------------------------------------------
    // Se non deve ricalcolare i totali del documento esce
    if not ACalcolaTotali then
      Exit;
    // --------------------------------------------------------------------------------------

    // Salva il valore di DM1.TotaliRealTime per poterlo disabilitare e poi ripristinare (Devo comunque disabilitare
    // i totali realtime prima di variare gli sconti delle aliquote IVA altrimenti viene richiamata ricorsivamente
    // questa funzione senza fine)
    PrecTotaliRealTime := fCalcoloTotaliAutomatico;
    fCalcoloTotaliAutomatico := False;
    // Prima di tutto azzera tutti gli sconti perchè non sono compatibili con lo scorporo dell'IVA nel quale
    // gli eventuali sconti possono essere solo sul rigo
    QryDocumentoSCONTOALIQUOTA1.Value := 0;
    QryDocumentoSCONTOALIQUOTA2.Value := 0;
    QryDocumentoSCONTOALIQUOTA3.Value := 0;
    QryDocumentoSCONTOALIQUOTA4.Value := 0;
    QryDocumentoTOTALESCONTI.Value := 0;
    // Ripristina la variabile DM1.TotaliRealTime
    fCalcoloTotaliAutomatico := PrecTotaliRealTime;

    // Aggiunge le spese all'aliquota IVA ordinaria corrente
    // --------------------------------------------------------------------------------------------------------------------------------
    CalcolaSpese(TempTotal1, TempTotal2, TempTotal3, TempTotal4);
    // --------------------------------------------------------------------------------------------------------------------------------

    // Aggiunge l'eventuale bollo all'apposita aliquota IVA
    // --------------------------------------------------------------------------------------------------------------------------------
    // Calcola il bollo e se abilitato lo applica automaticamente
    CalcolaBollo(TempTotal1, TempTotal2, TempTotal3, TempTotal4);
    // --------------------------------------------------------------------------------------------------------------------------------

    // Calcola gli IMPORTI IVA con lo scorporo
    QryDocumentoIMPORTOIVA1.Value := DM1.Arrotonda(TempTotal1 * QryDocumentoALIQUOTAIVA1.Value / (100 + QryDocumentoALIQUOTAIVA1.Value), FormatSettings.CurrencyDecimals);
    QryDocumentoIMPORTOIVA2.Value := DM1.Arrotonda(TempTotal2 * QryDocumentoALIQUOTAIVA2.Value / (100 + QryDocumentoALIQUOTAIVA2.Value), FormatSettings.CurrencyDecimals);
    QryDocumentoIMPORTOIVA3.Value := DM1.Arrotonda(TempTotal3 * QryDocumentoALIQUOTAIVA3.Value / (100 + QryDocumentoALIQUOTAIVA3.Value), FormatSettings.CurrencyDecimals);
    QryDocumentoIMPORTOIVA4.Value := DM1.Arrotonda(TempTotal4 * QryDocumentoALIQUOTAIVA4.Value / (100 + QryDocumentoALIQUOTAIVA4.Value), FormatSettings.CurrencyDecimals);
    // Aggiorna la tabella dei documenti con in nuovi totali merci ottenuti scorporando l'IVA
    QryDocumentoTOTALERIGHI1.Value := TempTotal1 - QryDocumentoIMPORTOIVA1.Value;
    QryDocumentoTOTALERIGHI2.Value := TempTotal2 - QryDocumentoIMPORTOIVA2.Value;
    QryDocumentoTOTALERIGHI3.Value := TempTotal3 - QryDocumentoIMPORTOIVA3.Value;
    QryDocumentoTOTALERIGHI4.Value := TempTotal4 - QryDocumentoIMPORTOIVA4.Value;
    // Calcola il TOTALE MERCE
    QryDocumentoTOTALEMERCE.Value := QryDocumentoTOTALERIGHI1.Value + QryDocumentoTOTALERIGHI2.Value + QryDocumentoTOTALERIGHI3.Value +
      QryDocumentoTOTALERIGHI4.Value;
    // Calcola i TOTALI IMPONIBILI
    QryDocumentoTOTALEIMPONIBILE1.Value := QryDocumentoTOTALERIGHI1.Value;
    QryDocumentoTOTALEIMPONIBILE2.Value := QryDocumentoTOTALERIGHI2.Value;
    QryDocumentoTOTALEIMPONIBILE3.Value := QryDocumentoTOTALERIGHI3.Value;
    QryDocumentoTOTALEIMPONIBILE4.Value := QryDocumentoTOTALERIGHI4.Value;
    // Calcola il TOTALE IMPONIBILE
    QryDocumentoTOTALEIMPONIBILE.Value := QryDocumentoTOTALEIMPONIBILE1.Value + QryDocumentoTOTALEIMPONIBILE2.Value + QryDocumentoTOTALEIMPONIBILE3.Value +
      QryDocumentoTOTALEIMPONIBILE4.Value;
    // Calcola il TOTALE NETTO MERCE
    QryDocumentoTOTALENETTOMERCE.Value := QryDocumentoTOTALEIMPONIBILE1.Value + QryDocumentoTOTALEIMPONIBILE2.Value + QryDocumentoTOTALEIMPONIBILE3.Value +
      QryDocumentoTOTALEIMPONIBILE4.Value;
    // Calcola il TOTALE IVA
    QryDocumentoTOTALEIVA.Value := QryDocumentoIMPORTOIVA1.Value + QryDocumentoIMPORTOIVA2.Value + QryDocumentoIMPORTOIVA3.Value +
      QryDocumentoIMPORTOIVA4.Value;

    // Se è selezionato il calcolo della ritenuta d'acconto su imponibile inserito dall'utente
    // calcola la percentuale di imponibile corrispondente (giusto per avere un dato coerente perchè in
    // realtà non la usa nemmeno) e poi calcola l'importo della ritenuta d'acconto.
    if QryDocumentoRITACCSUIMPORTOIMP.AsString = 'T' then
    begin
      if (not QryDocumentoTOTALENETTOMERCE.IsNull) and (QryDocumentoTOTALENETTOMERCE.AsFloat <> 0) then
        QryDocumentoRITACCPERCIMPONIBILE.Value := DM1.Arrotonda((QryDocumentoRITACCIMPONIBILE.AsFloat * 100 / QryDocumentoTOTALENETTOMERCE.AsFloat), FormatSettings.CurrencyDecimals)
      else
        QryDocumentoRITACCPERCIMPONIBILE.Value := 0;
    end
    // Se è selezionato il calcolo della ritenuta d'acconto su percentuale di imponibile
    // calcola prima l'imponibile corrispondente come base per il calcolo della ritenuta stessa
    // e poi calcola la ritenuta d'acconto
    else
    begin
      QryDocumentoRITACCIMPONIBILE.Value := DM1.Arrotonda((QryDocumentoTOTALENETTOMERCE.AsFloat * (QryDocumentoRITACCPERCIMPONIBILE.AsFloat / 100)), FormatSettings.CurrencyDecimals);
    end;
    // Calcola la ritenuta d'acconto
    QryDocumentoRITACC.Value := DM1.Arrotonda((QryDocumentoRITACCIMPONIBILE.AsFloat * (QryDocumentoRITACCPERC.AsFloat / 100) * (-1)), FormatSettings.CurrencyDecimals);

    // Calcola il TOTALI DOCUMENTO con anche l'eventuale abbuono
    QryDocumentoTOTALEDOCUMENTO.Value := QryDocumentoTOTALEIMPONIBILE.Value + QryDocumentoTOTALEIVA.Value;
    // Calcolo dello sconto finale
    CalcolaAbbuonoSePercentuale(QryDocumentoTOTALEDOCUMENTO.Value);
    QryDocumentoTOTALEDAPAGARE.Value := QryDocumentoTOTALEDOCUMENTO.Value - QryDocumentoABBUONO.Value + QryDocumentoRITACC.Value - QryDocumentoABBUONO.AsFloat;
    // Calcola il mergine totale del documento e aggiorna la Caption del pulsate di visualizzazione del totale margine documento
    QryDocumentoTOTALEMARGINE.Value := QryDocumentoTOTALENETTOMERCE.Value - CostoTot;
    // Rende visibili solo i righi del castelletto IVA che non sono vuoti
    ControllaVisualizzazioneCastellettoIVA;
  finally
    // Disabilita/Riabilita l'eventhandler per il ricalcolo della ritenuta d'acconto alla modifica di uno dei dati relativi
    QryDocumentoRITACCPERCIMPONIBILE.OnValidate := QryDocumentoRicalcolaDocumentoEventHandler;
    QryDocumentoRITACCIMPONIBILE.OnValidate := QryDocumentoRicalcolaDocumentoEventHandler;
    // Termina il sistema che determina se deve essere attivata la visualizzazione raggruppata
    // per sezione oppure no.
    if fRaggruppamentoSezioni then
      TSectionGrouped.EndCheck;
    // Pone la griglia in modalità di Update per velucizzare le operazioni
    // NB: Migliora notevolmente la valocità nel caso di modifica di un  sottorigo di
    // un rigo composto.
    // tvCorpo.DataController.EndFullUpdate;
    GridCorpo.EndUpdate;
  end;
end;

procedure TPreventiviOrdiniForm.CalcolaAbbuonoSePercentuale(const ATotaleDocumento: Double);
begin
  if (QryDocumentoABBUONOPERC.AsFloat <> 0) and (QryDocumentoAbbuonoSu.AsString <> '') then
  begin
    QryDocumentoABBUONO.OnChange := nil;
    QryDocumentoABBUONO.OnValidate := nil;
    try
      if QryDocumentoAbbuonoSu.AsString = 'T' then
        QryDocumentoABBUONO.Value := DM1.Arrotonda(QryDocumentoTOTALEDOCUMENTO.Value * QryDocumentoABBUONOPERC.Value / 100,   FormatSettings.CurrencyDecimals)
      else
      if QryDocumentoAbbuonoSu.AsString = 'I' then
        QryDocumentoABBUONO.Value := DM1.Arrotonda(QryDocumentoTOTALEIMPONIBILE.Value * QryDocumentoABBUONOPERC.Value / 100,   FormatSettings.CurrencyDecimals)
      else
        Dialogs.MessageDlg('CalcoloAbbuonoSePercentuale: Valore campo "AbbuonoSu" non valido', mtError, [mbOk], 0);
    finally
      QryDocumentoABBUONO.OnChange := QryDocumentoABBUONOChange;
      QryDocumentoABBUONO.OnValidate := QryDocumentoRicalcolaDocumentoEventHandler;
    end;
  end;
end;

procedure TPreventiviOrdiniForm.ControlloBeniSignificativi(const DC: TcxCustomDataController);
var
  i, IdxUpperLine, IdxValComplessivo, IdxValBeniSign, IdxIvaAgevolata, IdxIvaOrdinaria, IdxAltriCosti, IdxBottomLine: Integer;
  TotBeniSign, TotBeniNonSign, TotBS10, TotBS22: Currency;
  IdxRowType, IdxRowTotal, IdxRowDescription, IdxRowQty, IdxPrzUnit, IdxRowCodiceIva, IdxRowDescrizioneIva, IdxRowAliquotaIva, IdxRowOrder,
    IdxRowCostoUnit: Integer;
  RowType: string;
begin
  // init
  IdxRowType := tvCorpoROWTYPE.Index;
  IdxRowTotal := tvCorpoIMPORTORIGO.Index;
  IdxRowDescription := tvCorpoDESCRIZIONE.Index;
  IdxPrzUnit := tvCorpoPREZZOUNITARIO.Index;
  IdxRowQty := tvCorpoQTA.Index;
  IdxRowCodiceIva := tvCorpoCODICEIVA.Index;
  IdxRowDescrizioneIva := tvCorpoDESCRIZIONEIVA.Index;
  IdxRowAliquotaIva := tvCorpoALIQUOTAIVA.Index;
  IdxRowOrder := tvCorpoORDER.Index;
  IdxRowCostoUnit := tvCorpoPREZZOACQUISTOARTICOLO.Index;
  IdxUpperLine := -1;
  IdxValComplessivo := -1;
  IdxValBeniSign := -1;
  IdxIvaAgevolata := -1;
  IdxIvaOrdinaria := -1;
  IdxAltriCosti := -1;
  IdxBottomLine := -1;
  TotBeniSign := 0;
  TotBeniNonSign := 0;
  // Cicla per tutte le righe del documento...
  for i := 0 to DC.RecordCount - 1 do
  begin
    RowType := VarToStr(DC.Values[i, IdxRowType]);
    // Se il RowType comincia con 'BS_' allora è un rigo  di riepilogo dei beni significativi o non significativi
    // in questo caso cerca di individuare e memorizzare la posizione delle righe di riepilogo per poi poterte aggiornare o rimuovere
    if LeftStr(RowType, 3) = 'BS_' then
    begin
      if RowType = TIPORIGODOC_BS_UpperLine then
        IdxUpperLine := i
      else if RowType = TIPORIGODOC_BS_ValoreComplessivo then
        IdxValComplessivo := i
      else if RowType = TIPORIGODOC_BS_ValoreBS then
        IdxValBeniSign := i
      else if RowType = TIPORIGODOC_BS_IvaAgevolata then
        IdxIvaAgevolata := i
      else if RowType = TIPORIGODOC_BS_IvaOrdinaria then
        IdxIvaOrdinaria := i
      else if RowType = TIPORIGODOC_BS_AltriCosti then
        IdxAltriCosti := i
      else if RowType = TIPORIGODOC_BS_BottomLine then
        IdxBottomLine := i;
    end
    // ... se invece il RowType non comincia con 'BS_' allora è un rigo normale e se è un bene significativo oppure
    // non significativo lo aggiunte al rispettivo totale.
    else if RowType = TIPORIGODOC_BeneSignificativo then
      TotBeniSign := TotBeniSign + DC.Values[i, IdxRowTotal]
    else if RowType = TIPORIGODOC_BeneNonSignificativo then
      TotBeniNonSign := TotBeniNonSign + DC.Values[i, IdxRowTotal];
  end;
  // Se i Beni NON Significativi sono in valore superiore ai Beni Significativi allora
  // tutto il valore si questi ultimi saranno assogettati a IVA 10%
  // altrimenti segue il procedimento normale
  if TotBeniNonSign >= TotBeniSign then
  begin
    TotBS10 := TotBeniSign;
    TotBS22 := 0;
  end
  else
  begin
    TotBS10 := TotBeniNonSign;
    TotBS22 := TotBeniSign - TotBS10;
  end;
  // A questo punto verifica se i righi di riepilogo dei beni significativi sono già presenti oppure no
  // inoltre, se sono presenti verifica anche che ci siano tutti quelli indispensabili.
  // Quindi se ci sono già ma non ci sono tutti provvede ad aliminare quelli presenti e poi a ricrearli nuovi in fondo
  // al documento, se invece proprio non ci sono per nulla li crea semplicemente in fondo al documento.
  if ((IdxValComplessivo = -1) or (IdxValBeniSign = -1) or (IdxIvaAgevolata = -1) or (IdxIvaOrdinaria = -1) or (IdxAltriCosti = -1)) or
    ((TotBeniSign = 0) or (TotBeniNonSign = 0)) then
  begin
    // NB: Vengono eliminati in ordine inverso per evitare problemi con gli indici
    if IdxBottomLine > -1 then
      DC.DeleteRecord(IdxBottomLine);
    if IdxAltriCosti > -1 then
      DC.DeleteRecord(IdxAltriCosti);
    if IdxIvaOrdinaria > -1 then
      DC.DeleteRecord(IdxIvaOrdinaria);
    if IdxIvaAgevolata > -1 then
      DC.DeleteRecord(IdxIvaAgevolata);
    if IdxValBeniSign > -1 then
      DC.DeleteRecord(IdxValBeniSign);
    if IdxValComplessivo > -1 then
      DC.DeleteRecord(IdxValComplessivo);
    if IdxUpperLine > -1 then
      DC.DeleteRecord(IdxUpperLine);
    // Se non ci sono righi marcati come beni significativi e non significativi esce subito
    if (TotBeniSign = 0) or (TotBeniNonSign = 0) then
      Exit;
    // upper line
    IdxUpperLine := DC.AppendRecord;
    DC.Values[IdxUpperLine, IdxRowType] := TIPORIGODOC_BS_UpperLine;
    DC.Values[IdxUpperLine, IdxRowDescription] := '----------------------------------------';
    DC.Values[IdxUpperLine, IdxRowCodiceIva] := DEFAULT_CODICE_IVA;
    // Codice aliquota IVA ordinaria
    DC.Values[IdxUpperLine, IdxRowDescrizioneIva] := DEFAULT_DESCRIZIONE_IVA;
    DC.Values[IdxUpperLine, IdxRowAliquotaIva] := DEFAULT_ALIQUOTA_IVA;
    DC.Values[IdxUpperLine, IdxRowOrder] := 999999.1;
    // valore complessivo
    IdxValComplessivo := DC.AppendRecord;
    DC.Values[IdxValComplessivo, IdxRowType] := TIPORIGODOC_BS_ValoreComplessivo;
    DC.Values[IdxValComplessivo, IdxRowDescription] := 'Valore complessivo della prestazione/intervento';
    DC.Values[IdxValComplessivo, IdxRowCodiceIva] := DEFAULT_CODICE_IVA;
    // Codice aliquota IVA ordinaria
    DC.Values[IdxValComplessivo, IdxRowDescrizioneIva] := DEFAULT_DESCRIZIONE_IVA;
    DC.Values[IdxValComplessivo, IdxRowAliquotaIva] := DEFAULT_ALIQUOTA_IVA;
    DC.Values[IdxValComplessivo, IdxRowOrder] := 999999.2;
    // valore beni significativi
    IdxValBeniSign := DC.AppendRecord;
    DC.Values[IdxValBeniSign, IdxRowType] := TIPORIGODOC_BS_ValoreBS;
    DC.Values[IdxValBeniSign, IdxRowDescription] := 'Valore dei Beni Significativi (DM 29/12/1999)';
    DC.Values[IdxValBeniSign, IdxRowCodiceIva] := DEFAULT_CODICE_IVA;
    // Codice aliquota IVA ordinaria
    DC.Values[IdxValBeniSign, IdxRowDescrizioneIva] := DEFAULT_DESCRIZIONE_IVA;
    DC.Values[IdxValBeniSign, IdxRowAliquotaIva] := DEFAULT_ALIQUOTA_IVA;
    DC.Values[IdxValBeniSign, IdxRowOrder] := 999999.3;
    // Parte dei beni significativi con aliquota agevolata (10%)
    IdxIvaAgevolata := DC.AppendRecord;
    DC.Values[IdxIvaAgevolata, IdxRowType] := TIPORIGODOC_BS_IvaAgevolata;
    DC.Values[IdxIvaAgevolata, IdxRowDescription] := 'Parte dei beni significativi assogettata al 10%';
    DC.Values[IdxIvaAgevolata, IdxRowQty] := 1;
    DC.Values[IdxIvaAgevolata, IdxRowCodiceIva] := 506; // Codice IVA al 10%
    DC.Values[IdxIvaAgevolata, IdxRowDescrizioneIva] := '10%';
    DC.Values[IdxIvaAgevolata, IdxRowAliquotaIva] := 10;
    DC.Values[IdxIvaAgevolata, IdxRowOrder] := 999999.4;
    // Parte dei beni significativi con aliquota ordinaria (22%)
    IdxIvaOrdinaria := DC.AppendRecord;
    DC.Values[IdxIvaOrdinaria, IdxRowType] := TIPORIGODOC_BS_IvaOrdinaria;
    DC.Values[IdxIvaOrdinaria, IdxRowDescription] := 'Parte dei beni significativi assogettata al 22%';
    DC.Values[IdxIvaOrdinaria, IdxRowQty] := 1;
    DC.Values[IdxIvaOrdinaria, IdxRowCodiceIva] := DEFAULT_CODICE_IVA;
    // Codice aliquota IVA ordinaria
    DC.Values[IdxIvaOrdinaria, IdxRowDescrizioneIva] := DEFAULT_DESCRIZIONE_IVA;
    DC.Values[IdxIvaOrdinaria, IdxRowAliquotaIva] := DEFAULT_ALIQUOTA_IVA;
    DC.Values[IdxIvaOrdinaria, IdxRowOrder] := 999999.5;
    // Altri costi (prestazione lavorativa al 10% manodopera comprensiva di altri beni o materiali non significativi)
    IdxAltriCosti := DC.AppendRecord;
    DC.Values[IdxAltriCosti, IdxRowType] := TIPORIGODOC_BS_AltriCosti;
    // DC.Values[IdxAltriCosti,IdxRowDescription] := 'Altri costi (prestazione lavorativa al 10% manodopera comprensiva di altri beni o materiali non significativi)';
    DC.Values[IdxAltriCosti, IdxRowDescription] := 'Manodopera e materiali accessori non significativi (10%)';
    DC.Values[IdxAltriCosti, IdxRowQty] := 1;
    DC.Values[IdxAltriCosti, IdxRowCodiceIva] := 506; // Codice IVA al 10%
    DC.Values[IdxAltriCosti, IdxRowDescrizioneIva] := '10%';
    DC.Values[IdxAltriCosti, IdxRowAliquotaIva] := 10;
    DC.Values[IdxAltriCosti, IdxRowOrder] := 999999.6;
    // bottom line
    IdxBottomLine := DC.AppendRecord;
    DC.Values[IdxBottomLine, IdxRowType] := TIPORIGODOC_BS_BottomLine;
    DC.Values[IdxBottomLine, IdxRowDescription] := '----------------------------------------';
    DC.Values[IdxBottomLine, IdxRowCodiceIva] := DEFAULT_CODICE_IVA;
    // Codice aliquota IVA ordinaria
    DC.Values[IdxBottomLine, IdxRowDescrizioneIva] := DEFAULT_DESCRIZIONE_IVA;
    DC.Values[IdxBottomLine, IdxRowAliquotaIva] := DEFAULT_ALIQUOTA_IVA;
    DC.Values[IdxBottomLine, IdxRowOrder] := 999999.7;
  end;
  // Aggiorna i valori dei righi di riepilogo dei beni significativi e non significativi
  DC.Values[IdxValComplessivo, IdxPrzUnit] := (TotBeniSign + TotBeniNonSign);
  DC.Values[IdxValBeniSign, IdxPrzUnit] := TotBeniSign;
  DC.Values[IdxIvaAgevolata, IdxPrzUnit] := TotBS10;
  DC.Values[IdxIvaOrdinaria, IdxPrzUnit] := TotBS22;
  DC.Values[IdxAltriCosti, IdxPrzUnit] := TotBeniNonSign;
  // Anche i costi unitari dei righi (argine sempre uguale a zero
  DC.Values[IdxIvaAgevolata, IdxRowCostoUnit] := DC.Values[IdxIvaAgevolata, IdxPrzUnit];
  DC.Values[IdxIvaOrdinaria, IdxRowCostoUnit] := DC.Values[IdxIvaOrdinaria, IdxPrzUnit];
  DC.Values[IdxAltriCosti, IdxRowCostoUnit] := DC.Values[IdxAltriCosti, IdxPrzUnit];
  // Esegue il ricalcolo per variazione del prezzo unitario perchè altrimenti il Margine % rimaneva vuoto
  CalcolaPerModificaPrezzoUnitario(IdxIvaAgevolata, DC);
  CalcolaPerModificaPrezzoUnitario(IdxIvaOrdinaria, DC);
  CalcolaPerModificaPrezzoUnitario(IdxAltriCosti, DC);
  // Effettua il calcolo dei totali del rigo
  CalcolaImportoRigo(DC, IdxIvaAgevolata);
  CalcolaImportoRigo(DC, IdxIvaOrdinaria);
  CalcolaImportoRigo(DC, IdxAltriCosti);
end;

procedure TPreventiviOrdiniForm.CalcolaSpese(var TempTotal1: Double; var TempTotal2: Double; var TempTotal3: Double; var TempTotal4: Double);
var
  IVAIndex: string;
begin
  // Se nullo il campo spese := 0
  if QryDocumentoSPESE.IsNull then
    QryDocumentoSPESE.Value := 0;
  if QryDocumentoSPESE.Value <> 0 then
  begin
    // Prima Pone in una variabile stringa l'indice dell'aliquota IVA nel castelletto
    IVAIndex := '';
    if (QryDocumentoCODICEIVA1.Value = DocIvaDefault.Codice) or (QryDocumentoCODICEIVA1.Value = 0) then
      IVAIndex := '1'
    else if (QryDocumentoCODICEIVA2.Value = DocIvaDefault.Codice) or (QryDocumentoCODICEIVA2.Value = 0) then
      IVAIndex := '2'
    else if (QryDocumentoCODICEIVA3.Value = DocIvaDefault.Codice) or (QryDocumentoCODICEIVA3.Value = 0) then
      IVAIndex := '3'
    else if (QryDocumentoCODICEIVA4.Value = DocIvaDefault.Codice) or (QryDocumentoCODICEIVA4.Value = 0) then
      IVAIndex := '4'
    else
      raise Exception.Create('Si è superato il numero massimo di aliquote IVA nel documento.');
    // Poi controlla che l'aliquota IVA non fosse vuota (non c'è alcun rigo con l'aliquota IVA di default) e se è vuota inerisce i campi opportuni
    if QryDocumento.FieldByName('CodiceIVA' + IVAIndex).Value = 0 then
    begin
      QryDocumento.FieldByName('CodiceIVA' + IVAIndex).Value := DocIvaDefault.Codice;
      QryDocumento.FieldByName('DescrizioneIVA' + IVAIndex).Value := DocIvaDefault.Descrizione;
      QryDocumento.FieldByName('AliquotaIVA' + IVAIndex).Value := DocIvaDefault.AliquotaIVA;
    end;
    // Alla fine aggunge le spese al totale corretto.
    // NB: Se siamo in scorporo IVA lo aggiunge comprensivo di IVA
    if DM1.ScorporoIVA then
    begin
      // IVA compresa (scorporo)
      case StrToInt(IVAIndex) of
        1:
          TempTotal1 := TempTotal1 + DM1.Arrotonda(QryDocumentoSPESE.Value * (100 + QryDocumentoALIQUOTAIVA1.Value) / 100, FormatSettings.CurrencyDecimals);
        2:
          TempTotal2 := TempTotal2 + DM1.Arrotonda(QryDocumentoSPESE.Value * (100 + QryDocumentoALIQUOTAIVA2.Value) / 100, FormatSettings.CurrencyDecimals);
        3:
          TempTotal3 := TempTotal3 + DM1.Arrotonda(QryDocumentoSPESE.Value * (100 + QryDocumentoALIQUOTAIVA3.Value) / 100, FormatSettings.CurrencyDecimals);
        4:
          TempTotal4 := TempTotal4 + DM1.Arrotonda(QryDocumentoSPESE.Value * (100 + QryDocumentoALIQUOTAIVA4.Value) / 100, FormatSettings.CurrencyDecimals);
      end;
    end
    else
    begin
      // Normale senza IVA
      QryDocumento.FieldByName('TotaleImponibile' + IVAIndex).Value := QryDocumento.FieldByName('TotaleImponibile' + IVAIndex).Value + QryDocumentoSPESE.Value;
    end;
  end;
end;

function TPreventiviOrdiniForm.CalcolaBollo(var TempTotal1: Double; var TempTotal2: Double; var TempTotal3: Double; var TempTotal4: Double): Double;
var
  TotaleNoIVA: Double;
  IVAIndex: string;
  CIBollo: Integer;
begin
  Result := 0;
  // Disabilita l'event handler che causerebbe un ricalcolo inutile e ricorsivo del documento
  QryDocumentoBOLLOIMPORTO.OnChange := nil;
  try
    // ------------ BOLLO AUTOMATICO ---------------------------------------------
    // Se è abilitato l'automatismo per il bollo in fattura cicla per il castelletto IVA
    // e determina il totali importo non assogettato all'IVA e se è superiore alla soglia
    // applica il bollo nell'importo imopstato nei parametri
    if (QryDocumentoTIPODOCUMENTO.AsString = 'Fattura') and (DM1.TableProgressivi2BOLLOAUTOMATICO.AsString = 'T') then
    begin
      TotaleNoIVA := 0;
      if QryDocumentoALIQUOTAIVA1BOLLOAUTOMATICO.AsString = 'T' then
        TotaleNoIVA := TotaleNoIVA + QryDocumentoTOTALEIMPONIBILE1.AsFloat;
      if QryDocumentoALIQUOTAIVA2BOLLOAUTOMATICO.AsString = 'T' then
        TotaleNoIVA := TotaleNoIVA + QryDocumentoTOTALEIMPONIBILE2.AsFloat;
      if QryDocumentoALIQUOTAIVA3BOLLOAUTOMATICO.AsString = 'T' then
        TotaleNoIVA := TotaleNoIVA + QryDocumentoTOTALEIMPONIBILE3.AsFloat;
      if QryDocumentoALIQUOTAIVA4BOLLOAUTOMATICO.AsString = 'T' then
        TotaleNoIVA := TotaleNoIVA + QryDocumentoTOTALEIMPONIBILE4.AsFloat;
      // Se viene superata la soglia mette il bollo in automatico, altrimenti lo rimette a zero
      // Se invece non viene superata la soglia allora lo rimette a zero
      if TotaleNoIVA > DM1.TableProgressivi2BOLLOAUTOMATICOSOGLIA.AsFloat then
        QryDocumentoBOLLOIMPORTO.Value := DM1.TableProgressivi2BOLLOAUTOMATICOIMPORTO.AsFloat
      else
        QryDocumentoBOLLOIMPORTO.Value := 0;
    end;
    // ---------------------------------------------------------------------------
    // ------------ CALCOLO BOLLO NEI TOTALI -------------------------------------
    // Se nullo il campo spese := 0
    if QryDocumentoBOLLOIMPORTO.IsNull then
      QryDocumentoBOLLOIMPORTO.Value := 0;
    // Se il bollo deve essere addebitato in fattura (rimborso)...
    if (QryDocumentoBOLLOADDEBITAINFATTURA.AsString = 'T') and (QryDocumentoBOLLOIMPORTO.Value <> 0) then
    begin
      // Carica il codice IVA da usare per il bollo
      IVAIndex := '';
      CIBollo := DM1.TableProgressivi2BOLLOCODICEIVA.AsInteger;
      if CIBollo = 0 then
        raise Exception.Create('Codice IVA del bollo non specificato nei parametri!');
      // Prima Pone in una variabile stringa l'indice dell'aliquota IVA nel castelletto
      if (QryDocumentoCODICEIVA1.Value = CIBollo) or (QryDocumentoCODICEIVA1.Value = 0) then
        IVAIndex := '1'
      else if (QryDocumentoCODICEIVA2.Value = CIBollo) or (QryDocumentoCODICEIVA2.Value = 0) then
        IVAIndex := '2'
      else if (QryDocumentoCODICEIVA3.Value = CIBollo) or (QryDocumentoCODICEIVA3.Value = 0) then
        IVAIndex := '3'
      else if (QryDocumentoCODICEIVA4.Value = CIBollo) or (QryDocumentoCODICEIVA4.Value = 0) then
        IVAIndex := '4'
      else
        raise Exception.Create('Si è superato il numero massimo di aliquote IVA nel documento.');
      // Poi controlla che l'aliquota IVA non fosse vuota (non c'è alcun rigo con l'aliquota IVA di default) e se è vuota inerisce i campi opportuni
      if QryDocumento.FieldByName('CodiceIVA' + IVAIndex).Value = 0 then
      begin
        QryDocumento.FieldByName('CodiceIVA' + IVAIndex).Value := CIBollo;
        QryDocumento.FieldByName('DescrizioneIVA' + IVAIndex).Value := DM1.TableProgressivi2BOLLODESCRIZIONEIVA.AsString;
        QryDocumento.FieldByName('AliquotaIVA' + IVAIndex).Value := DM1.TableProgressivi2BOLLOALIQUOTAIVA.AsFloat;
        // Deve essere escluso art. 15
      end;
      // Alla fine aggunge il bollo al totale corretto.
      // NB: Se siamo in scorporo IVA lo aggiunge comprensivo di IVA
      if DM1.ScorporoIVA then
      begin
        // IVA compresa (scorporo)
        case StrToInt(IVAIndex) of
          1:
            TempTotal1 := TempTotal1 + DM1.Arrotonda(QryDocumentoBOLLOIMPORTO.Value * (100 + QryDocumentoALIQUOTAIVA1.Value) / 100, FormatSettings.CurrencyDecimals);
          2:
            TempTotal2 := TempTotal2 + DM1.Arrotonda(QryDocumentoBOLLOIMPORTO.Value * (100 + QryDocumentoALIQUOTAIVA2.Value) / 100, FormatSettings.CurrencyDecimals);
          3:
            TempTotal3 := TempTotal3 + DM1.Arrotonda(QryDocumentoBOLLOIMPORTO.Value * (100 + QryDocumentoALIQUOTAIVA3.Value) / 100, FormatSettings.CurrencyDecimals);
          4:
            TempTotal4 := TempTotal4 + DM1.Arrotonda(QryDocumentoBOLLOIMPORTO.Value * (100 + QryDocumentoALIQUOTAIVA4.Value) / 100, FormatSettings.CurrencyDecimals);
        end;
      end
      else
      begin
        // Normale senza IVA
        QryDocumento.FieldByName('TotaleImponibile' + IVAIndex).Value := QryDocumento.FieldByName('TotaleImponibile' + IVAIndex).Value +
          QryDocumentoBOLLOIMPORTO.Value;
        Result := QryDocumentoBOLLOIMPORTO.Value;
      end;
    end;
  finally
    QryDocumentoBOLLOIMPORTO.OnChange := QryDocumentoRicalcolaDocumentoEventHandler;
  end;
end;

function TPreventiviOrdiniForm.CalcolaPrezzoScontato(PrezzoLordo, Sc1, Sc2, Sc3: Variant; const AArrotonda: Boolean): Double;
begin
  // Defaultizzazione dei parametri
  if VarIsNull(PrezzoLordo) then
    PrezzoLordo := 0;
  if VarIsNull(Sc1) then
    Sc1 := 0;
  if VarIsNull(Sc2) then
    Sc2 := 0;
  if VarIsNull(Sc3) then
    Sc3 := 0;
  // Se è attiva la modalità di sconto al contrario allora il calcolo degli "sconti"
  // deve essere diverso, in pratica per ogni livello di sconto (percentuale di avanzamento cantiere)
  // deve lavorare sempre sul prezzo unitario.
  if fScontiAlContrario then
  begin
    // NB: Se siamo con gli sconto al contrario e gli sconti (cioè la percentuale di avanzamento in questo caso) sono
    // tutti a zero, lui considera lo sconto 1 (% avanzamento 1) uguale a 100 altrimenti, come default
    // l'importo rimarrebbe a zero.
    if (Sc1 = 0) and (Sc2 = 0) and (Sc3 = 0) then
      Sc1 := 100;
    Result := (PrezzoLordo * Sc1 / 100) + (PrezzoLordo * Sc2 / 100) + (PrezzoLordo * Sc3 / 100);
  end
  else
  begin
    Result := PrezzoLordo;
    { Prima era così ma poi la Idrofutura mi ha detto che arrotondava male con PrzUnit = 6.55, sconto = 55%, Qta = 2 Levante dava 5,89 invece di 5,90
      Result := Result - DM1.Arrotonda((Result / 100 * Sc1), DM1.DecMicroPrz);
      Result := Result - DM1.Arrotonda((Result / 100 * Sc2), DM1.DecMicroPrz);
      Result := Result - DM1.Arrotonda((Result / 100 * Sc3), DM1.DecMicroPrz);
    }
    { Prima dell'adeguamento alla fattura elettronica 1.6.1 era cosi
    // Calcola l'importo scontato e applica solo alla fine l'arrotondamento
    Result := Result - Result / 100 * Sc1;
    Result := Result - Result / 100 * Sc2;
    Result := Result - Result / 100 * Sc3;
    Result := DM1.Arrotonda(Result, DM1.DecMicroPrz);
    }
    // Calcola l'importo scontato e applica solo alla fine l'arrotondamento
    Result := Result - ((Result * Sc1) / 100);
    Result := Result - ((Result * Sc2) / 100);
    Result := Result - ((Result * Sc3) / 100);
  end;
  // Evantuale arrotondamento
  if AArrotonda then
    Result := DM1.Arrotonda(Result, DM1.DecMicroPrz);
end;

procedure TPreventiviOrdiniForm.CalcolaPerModificaPrezzoUnitario(i: Integer; DC: TcxCustomDataController);
var
  LPrzVend: Double;
begin
  with DC do
  begin
    LPrzVend := DM1.NoNullFloatValue(DC, i, tvCorpoPREZZOUNITARIO.Index);
    // Calcola il PrzUnitIvaComp: PUIC := PU + (PU * IVA / 100)
    Values[i, tvCorpoPREZZOUNITARIOIVACOMPRESA.Index] := LPrzVend + DM1.Arrotonda((LPrzVend * DM1.NoNullFloatValue(DC, i, tvCorpoALIQUOTAIVA.Index) / 100),
      DM1.DecMicroPrz);
    // Controlla che il prezzo di acquisto sia > 0 poi calcola il margine
    RicalcolaMarginePerModificaPrzVend(i, DC);
  end;
end;

procedure TPreventiviOrdiniForm.CalcolaPerModificaPrezzoAcquistoArticolo(i: Integer; DC: TcxCustomDataController);
var
  LPrzAcq, LPrzVend: Double;
begin
  with DC do
  begin
    // Se il prezzo di vendita è bloccato (calculato automaticamente) allora evita di modificarlo
    if IsPrzUnitAutocalc(DC, i) then
    begin
      // Calcola il PrezzoUnitario: PAcq + (PAcq * Marg /100)
      LPrzAcq := DM1.NoNullFloatValue(DC, i, tvCorpoPREZZOACQUISTOARTICOLO.Index);
      LPrzVend := DM1.Arrotonda(LPrzAcq + (LPrzAcq * DM1.NoNullFloatValue(DC, i, tvCorpoMARGINE.Index) / 100), DM1.DecMicroPrz);
      Values[i, tvCorpoPREZZOUNITARIO.Index] := LPrzVend;
      // Calcola il PrezzoUnitarioIVACompresa: PUIC := PU + (PU * IVA / 100)
      Values[i, tvCorpoPREZZOUNITARIOIVACOMPRESA.Index] := LPrzVend + DM1.Arrotonda((LPrzVend * DM1.NoNullFloatValue(DC, i, tvCorpoALIQUOTAIVA.Index) / 100),
        DM1.DecMicroPrz);
    end
    else
      // Controlla che il prezzo di acquisto sia > 0 poi calcola il margine
      RicalcolaMarginePerModificaPrzVend(i, DC);
  end;
end;

procedure TPreventiviOrdiniForm.CalcolaPerModificaMargine(i: Integer; DC: TcxCustomDataController);
var
  LPrzAcq, LPrzVend: Double;
begin
  with DC do
  begin
    // Se il prezzo di vendita è bloccato (calculato automaticamente) allora evita di modificarlo
    if not IsPrzUnitAutocalc(DC, i) then
    begin
      // Calcola il PrezzoUnitario: PAcq + (PAcq * Marg /100)
      LPrzAcq := DM1.NoNullFloatValue(DC, i, tvCorpoPREZZOACQUISTOARTICOLO.Index);
      LPrzVend := DM1.Arrotonda(LPrzAcq + (LPrzAcq * DM1.NoNullFloatValue(DC, i, tvCorpoMARGINE.Index) / 100), DM1.DecMicroPrz);
      Values[i, tvCorpoPREZZOUNITARIO.Index] := LPrzVend;
      // Calcola il PrezzoUnitarioIVACompresa: PUIC := PU + (PU * IVA / 100)
      Values[i, tvCorpoPREZZOUNITARIOIVACOMPRESA.Index] := LPrzVend + DM1.Arrotonda((LPrzVend * DM1.NoNullFloatValue(DC, i, tvCorpoALIQUOTAIVA.Index) / 100),
        DM1.DecMicroPrz);
      // Ricalcola il margine (per il MargineImporto)
      RicalcolaMarginePerModificaPrzVend(i, DC);
    end;
  end;
  // Da quando abbiamo rifatto gli articoli composti questo calcolo è diventato
  // uguale a quello per ModificaPrezzoAcquistoArticolo
  // CalcolaPerModificaPrezzoAcquistoArticolo(i, DC);
end;

procedure TPreventiviOrdiniForm.CalcolaPerModificaPrezzoUnitarioIVACompresa(i: Integer; DC: TcxCustomDataController);
var
  ImportoMargine, PrezzoScontato: Double;
begin
  with DC do
  begin
    // Calcola il PrzUnit: PU := PUIC * 100 / (100 + AliqIVA)
    Values[i, tvCorpoPREZZOUNITARIO.Index] := DM1.Arrotonda(DM1.NoNullFloatValue(DC, i, tvCorpoPREZZOUNITARIOIVACOMPRESA.Index) * 100 /
      (100 + DM1.NoNullFloatValue(DC, i, tvCorpoALIQUOTAIVA.Index)), DM1.DecMicroPrz);
    // Controlla che il prezzo di acquisto sia > 0 poi calcola il margine
    RicalcolaMarginePerModificaPrzVend(i, DC);
  end;
end;

procedure TPreventiviOrdiniForm.CalcolaImportoRigo(DC: TcxCustomDataController; i: Integer);
var
  Qta, PrzUnit, PrzAcquisto, ImportoAcquisto, ImportoRigoScontato, ImportoRigoScontatoIvaComp, Sconto1, Sconto2, Sconto3: Double;
begin
  Qta := DM1.NoNullFloatValue(DC, i, tvCorpoQTA.Index);
  PrzUnit := DM1.NoNullFloatValue(DC, i, tvCorpoPREZZOUNITARIO.Index);
  PrzAcquisto := DM1.NoNullFloatValue(DC, i, tvCorpoPREZZOACQUISTOARTICOLO.Index);
  ImportoAcquisto := DM1.Arrotonda(PrzAcquisto * Qta, DM1.DecMicroPrz);
  Sconto1 := DM1.NoNullFloatValue(DC, i, tvCorpoSCONTORIGO.Index);
  Sconto2 := DM1.NoNullFloatValue(DC, i, tvCorpoSCONTORIGO2.Index);
  Sconto3 := DM1.NoNullFloatValue(DC, i, tvCorpoSCONTORIGO3.Index);
  // Calcola IMPORTO RIGO
  // Importo acquisto
  DC.Values[i, tvCorpoIMPORTOCOSTO.Index] := ImportoAcquisto;
  // Se il calcolo deve essere su base IVA COMPRESA...(scorporo)
  if DM1.ScorporoIVA then
  begin
    // --------------------------------------------------------------------------------------------------------------------
    with DC do
    begin
// --- Prima dell'adeguamento alla F.E. 1.6.1 ---
//      // Prima calcola il totale rigo non scontatoe poi applica gli sconti sul totale rigo IVA compresa
//      ImportoRigoScontatoIvaComp := DM1.Arrotonda(DM1.NoNullFloatValue(DC, i, tvCorpoPREZZOUNITARIOIVACOMPRESA.Index) * Qta, DM1.DecCalcoliIntermedi);
//      ImportoRigoScontatoIvaComp := CalcolaPrezzoScontato(ImportoRigoScontatoIvaComp, Sconto1, Sconto2, Sconto3);
// --- Prima dell'adeguamento alla F.E. 1.6.1 ---
      // Prima calcola il prezzo unitario scontato con l'arrotondamento standard (cifre)
      //  poi lo moltiplica per la Qtà
      ImportoRigoScontatoIvaComp := CalcolaPrezzoScontato(DM1.NoNullFloatValue(DC, i, tvCorpoPREZZOUNITARIOIVACOMPRESA.Index), Sconto1, Sconto2, Sconto3, False);
      ImportoRigoScontatoIvaComp := DM1.Arrotonda((ImportoRigoScontatoIvaComp * Qta), DM1.DecMicroPrz);

      // Calcola l'importo rigo
      ImportoRigoScontato := DM1.Arrotonda(ImportoRigoScontatoIvaComp / (DM1.NoNullFloatValue(DC, i, tvCorpoALIQUOTAIVA.Index) / 100 + 1), DM1.DecMicroPrz);
      Values[i, tvCorpoIMPORTORIGO.Index] := ImportoRigoScontato;
      // Calcola importo margine
      Values[i, tvCorpoIMPORTOMARGINE.Index] := DM1.Arrotonda(ImportoRigoScontato - ImportoAcquisto, DM1.DecMicroPrz);
      // Assegna l'importo del rigo IVA compresa
      Values[i, tvCorpoIMPORTORIGOIVACOMPRESA.Index] := ImportoRigoScontatoIvaComp;
    end;
    // --------------------------------------------------------------------------------------------------------------------
  end
  // Se il calcolo deve essere su base IVA ESCLUSA
  else
  begin
    // --------------------------------------------------------------------------------------------------------------------
    with DC do
    begin
// --- Prima dell'adeguamento alla F.E. 1.6.1 ---
//      // Prima calcola il totale rigo non scontato e poi applica gli sconti sul totale rigo
//      // ImportoRigoScontato := DM1.Arrotonda((PrzUnit * Qta), DM1.DecMicroPrz);  // Prima della fattura elettronica era così
//      ImportoRigoScontato := DM1.Arrotonda((PrzUnit * Qta), DM1.DecCalcoliIntermedi);
//      ImportoRigoScontato := CalcolaPrezzoScontato(ImportoRigoScontato, Sconto1, Sconto2, Sconto3);
// --- Prima dell'adeguamento alla F.E. 1.6.1 ---
      // Prima calcola il prezzo unitario scontato con l'arrotondamento standard (cifre)
      //  poi lo moltiplica per la Qtà
      ImportoRigoScontato := CalcolaPrezzoScontato(PrzUnit, Sconto1, Sconto2, Sconto3, False);
      ImportoRigoScontato := DM1.Arrotonda((ImportoRigoScontato * Qta), DM1.DecMicroPrz);

      // Calcola l'importo del margine
      Values[i, tvCorpoIMPORTOMARGINE.Index] := DM1.Arrotonda(ImportoRigoScontato - ImportoAcquisto, DM1.DecMicroPrz);
      // Assegna l'importo del rigo
      Values[i, tvCorpoIMPORTORIGO.Index] := ImportoRigoScontato;
      // Calcola l'importo rigo IVA compresa
      ImportoRigoScontatoIvaComp := ImportoRigoScontato + DM1.Arrotonda(ImportoRigoScontato * DM1.NoNullFloatValue(DC, i, tvCorpoALIQUOTAIVA.Index) / 100,
        DM1.DecMicroPrz);
      Values[i, tvCorpoIMPORTORIGOIVACOMPRESA.Index] := ImportoRigoScontatoIvaComp;
    end;
    // --------------------------------------------------------------------------------------------------------------------
  end;

  // Se siamo su un documento di acquisto, forza il prezzo di acquisto = al prezzo unitario eventualmente al
  // netto degli sconti (ImportoRigo/Qta) e il margine a 0.
  // NB: Imposto il prezzo di costo uguale al prezzo unitario scontato anche nel caso
  // che il prezzo di costo sia 0 uppore nullo, in questo modo almeno il margine risulta sempre 0 e l'utente
  // sta sempre dalla parte del cortello invece che vedere un margine elevatissimo vede margine zero.
  // NB: Anche i righi di manodopera
  if DM1.IsDocumentoDiIngresso(QryDocumentoTIPODOCUMENTO.AsString) or (PrzAcquisto = 0) then
  begin
    if Qta <> 0 then
      PrzAcquisto := DM1.Arrotonda((ImportoRigoScontato / Qta), DM1.DecMicroPrz)
    else
      PrzAcquisto := 0;
    // Ricalcola l'importo di acquisto comprendendo anche gli sconti sul rigo
    ImportoAcquisto := DM1.Arrotonda(PrzAcquisto * Qta, DM1.DecMicroPrz);
    DC.Values[i, tvCorpoPREZZOACQUISTOARTICOLO.Index] := PrzAcquisto;
    DC.Values[i, tvCorpoIMPORTOCOSTO.Index] := ImportoAcquisto;
    DC.Values[i, tvCorpoMARGINE.Index] := 0;
    DC.Values[i, tvCorpoIMPORTOMARGINE.Index] := 0;
  end;

  // ==================================================================================================================
  // Parte per la valorizzazione dei valori relativi ai subtotali di manodopera e componenti del rigo
  // ------------------------------------------------------------------------------------------------------------------
  // Se è un rigo di manodopera:
  // SI comporta allo stesso modo sia che sia un rigo di manodopera principale con anche dei sottorighi sia che
  // invece sia un rigo di manodopera semplice (senza sottorighi). In pratica i valori degli eventuali
  // sottorighi non influenzano mai qualli del rigo principale (a parte la qtà che invece si somma).
  if DM1.CodiceIsManodopera(DC.Values[i, tvCorpoCODICEARTICOLO.Index]) then
  begin
    // Valori unitari
    DC.Values[i, tvCorpoCOSTOCOMPONENTIUNIT.Index] := 0;
    DC.Values[i, tvCorpoCOSTOOPERAUNIT.Index] := 0;
    DC.Values[i, tvCorpoCOMPONENTIUNIT.Index] := 0;
    DC.Values[i, tvCorpoOPERAUNIT.Index] := 0;
    DC.Values[i, tvCorpoQTAOPERAUNIT.Index] := 0;
    DC.Values[i, tvCorpoIMPORTOMARGINECOMPONENTI.Index] := 0;
    DC.Values[i, tvCorpoIMPORTOMARGINEOPERA.Index] := 0;
    DC.Values[i, tvCorpoPERCMARGINECOMPONENTI.Index] := 0;
    DC.Values[i, tvCorpoPERCMARGINEOPERA.Index] := 0;
    // Valori complessivi
    DC.Values[i, tvCorpoIMPORTOCOSTOCOMPONENTI.Index] := 0;
    DC.Values[i, tvCorpoIMPORTOCOSTOOPERA.Index] := ImportoAcquisto;
    DC.Values[i, tvCorpoIMPORTOCOMPONENTI.Index] := 0;
    DC.Values[i, tvCorpoIMPORTOOPERA.Index] := ImportoRigoScontato;
    DC.Values[i, tvCorpoQTAOPERA.Index] := Qta;
    DC.Values[i, tvCorpoIMPORTOMARGINECOMPONENTI.Index] := 0;
    DC.Values[i, tvCorpoIMPORTOMARGINEOPERA.Index] := DC.Values[i, tvCorpoIMPORTOMARGINE.Index];
    DC.Values[i, tvCorpoPERCMARGINECOMPONENTI.Index] := 0;
    DC.Values[i, tvCorpoPERCMARGINEOPERA.Index] := DC.Values[i, tvCorpoMARGINE.Index];
  end
  // Altrimenti se è rigo di materiali/componenti:
  else
  begin
    // Se è un rigo composto e ha dei sottorighi...
    if DM1.CheckIfExpandable(DC, i) or ((not DC.IsDetailMode) and (VarToStr(DC.Values[i, tvCorpoROWTYPE.Index]) = TIPORIGODOC_TC_Totale)) then
    begin
      // Solo i valori complessivi perchè quelli unitari sono già stati impostati da "CalcolaTotaliSottorighi"
      DC.Values[i, tvCorpoPREZZOACQUISTOARTICOLO.Index] := DC.Values[i, tvCorpoCOSTOCOMPONENTIUNIT.Index] + DC.Values[i, tvCorpoCOSTOOPERAUNIT.Index];
      DC.Values[i, tvCorpoIMPORTOCOSTOCOMPONENTI.Index] := DM1.Arrotonda((DC.Values[i, tvCorpoCOSTOCOMPONENTIUNIT.Index] * Qta), DM1.DecMicroPrz);
      DC.Values[i, tvCorpoIMPORTOCOSTOOPERA.Index] := DM1.Arrotonda((DC.Values[i, tvCorpoCOSTOOPERAUNIT.Index] * Qta), DM1.DecMicroPrz);
      DC.Values[i, tvCorpoIMPORTOCOSTO.Index] := DC.Values[i, tvCorpoIMPORTOCOSTOCOMPONENTI.Index] + DC.Values[i, tvCorpoIMPORTOCOSTOOPERA.Index];
      // DC.Values[i, tvCorpoIMPORTOOPERA.Index] := CalcolaPrezzoScontato(   (DC.Values[i, tvCorpoOPERAUNIT.Index] * Qta)   , Sconto1, Sconto2, Sconto3);
      DC.Values[i, tvCorpoIMPORTOOPERA.Index] := DM1.Arrotonda((DC.Values[i, tvCorpoOPERAUNIT.Index] * Qta), DM1.DecMicroPrz);
      // NB: La manodopera non viene scontata mai
      DC.Values[i, tvCorpoQTAOPERA.Index] := DM1.Arrotonda((DC.Values[i, tvCorpoQTAOPERAUNIT.Index] * Qta), DM1.DecMicroPrz);

      DC.Values[i, tvCorpoIMPORTOCOMPONENTI.Index] := ImportoRigoScontato - DC.Values[i, tvCorpoIMPORTOOPERA.Index];

      // Calcola margini importo
      DC.Values[i, tvCorpoIMPORTOMARGINECOMPONENTI.Index] := DC.Values[i, tvCorpoIMPORTOCOMPONENTI.Index] - DC.Values[i, tvCorpoIMPORTOCOSTOCOMPONENTI.Index];
      DC.Values[i, tvCorpoIMPORTOMARGINEOPERA.Index] := DC.Values[i, tvCorpoIMPORTOOPERA.Index] - DC.Values[i, tvCorpoIMPORTOCOSTOOPERA.Index];
      // Calcola margine perc. componenti
      if DM1.NoNullFloatValue(DC, i, tvCorpoIMPORTOCOSTOCOMPONENTI.Index) <> 0 then
        DC.Values[i, tvCorpoPERCMARGINECOMPONENTI.Index] := DM1.Arrotonda(DC.Values[i, tvCorpoIMPORTOMARGINECOMPONENTI.Index] * 100 / DC.Values[i,
          tvCorpoIMPORTOCOSTOCOMPONENTI.Index], 2)
      else
        DC.Values[i, tvCorpoPERCMARGINECOMPONENTI.Index] := 0;
      // Calcola margine perc. opera
      if DM1.NoNullFloatValue(DC, i, tvCorpoIMPORTOCOSTOOPERA.Index) <> 0 then
        DC.Values[i, tvCorpoPERCMARGINEOPERA.Index] := DM1.Arrotonda(DC.Values[i, tvCorpoIMPORTOMARGINEOPERA.Index] * 100 / DC.Values[i,
          tvCorpoIMPORTOCOSTOOPERA.Index], 2)
      else
        DC.Values[i, tvCorpoPERCMARGINEOPERA.Index] := 0;
    end
    // Se invece non è un rigo composto o non ha dei sottorighi...
    else
    begin
      // Valori unitari
      DC.Values[i, tvCorpoQTAOPERAUNIT.Index] := 0;
      DC.Values[i, tvCorpoOPERAUNIT.Index] := 0;
      DC.Values[i, tvCorpoCOSTOOPERAUNIT.Index] := 0;
      DC.Values[i, tvCorpoCOMPONENTIUNIT.Index] := 0;
      DC.Values[i, tvCorpoCOSTOCOMPONENTIUNIT.Index] := 0;
      DC.Values[i, tvCorpoIMPORTOMARGINECOMPONENTI.Index] := 0;
      DC.Values[i, tvCorpoIMPORTOMARGINEOPERA.Index] := 0;
      DC.Values[i, tvCorpoPERCMARGINECOMPONENTI.Index] := 0;
      DC.Values[i, tvCorpoPERCMARGINEOPERA.Index] := 0;
      // Valori complessivi
      DC.Values[i, tvCorpoQTAOPERA.Index] := 0;
      DC.Values[i, tvCorpoIMPORTOOPERA.Index] := 0;
      DC.Values[i, tvCorpoIMPORTOCOSTOOPERA.Index] := 0;
      DC.Values[i, tvCorpoIMPORTOCOMPONENTI.Index] := ImportoRigoScontato;
      DC.Values[i, tvCorpoIMPORTOCOSTOCOMPONENTI.Index] := ImportoAcquisto;
      DC.Values[i, tvCorpoIMPORTOMARGINECOMPONENTI.Index] := DC.Values[i, tvCorpoIMPORTOMARGINE.Index];
      DC.Values[i, tvCorpoIMPORTOMARGINEOPERA.Index] := 0;
      DC.Values[i, tvCorpoPERCMARGINECOMPONENTI.Index] := DC.Values[i, tvCorpoMARGINE.Index];
      DC.Values[i, tvCorpoPERCMARGINEOPERA.Index] := 0;
    end;
  end;
  // ==================================================================================================================
end;

procedure TPreventiviOrdiniForm.AssegnaAliquotaIVA(CodIVA, Row: Integer; LocDataController: TcxCustomDataController);
var
  Qry: TIB_Cursor;
begin
  // Questa procedura importa i dati del codice IVA ricevuto come parametro nel rigo del corpo documento corrente
  // -------------------------------------------------------------------------------------------------------------
  // Se  il codice IVA da assegnare = -9 significa che si tratta di un rigo di riferimento
  // e quindi gli pone codice = -9 e vuoto il resto e poi esce subito
  if CodIVA = -9 then
  begin
    LocDataController.Values[Row, tvCorpoCODICEIVA.Index] := CodIVA;
    Exit;
  end;
  // Prima di tutto controlla se il codice dell'AliquotaIVA da assegnare è il codice IVA di default dell'applicazione (IVA ordinaria 20%)
  // oppure di quella di default del documento (Quella che è assegnata opzionalmente nell'anagrafica cliente), nel qual caso evita di eseguire
  // la query e preleva i dati dalle variabili opportune, altrimenti esegue una query per prekevare i dati dal database.
  if (CodIVA = DEFAULT_CODICE_IVA) or (CodIVA = 0) then
  begin
    LocDataController.Values[Row, tvCorpoCODICEIVA.Index] := DEFAULT_CODICE_IVA;
    LocDataController.Values[Row, tvCorpoALIQUOTAIVA.Index] := DEFAULT_ALIQUOTA_IVA;
    LocDataController.Values[Row, tvCorpoDESCRIZIONEIVA.Index] := DEFAULT_DESCRIZIONE_IVA;
  end
  else if CodIVA = DocIvaDefault.Codice then
  begin
    LocDataController.Values[Row, tvCorpoCODICEIVA.Index] := DocIvaDefault.Codice;
    LocDataController.Values[Row, tvCorpoALIQUOTAIVA.Index] := DocIvaDefault.AliquotaIVA;
    LocDataController.Values[Row, tvCorpoDESCRIZIONEIVA.Index] := DocIvaDefault.Descrizione;
  end
  else
  begin
    Qry := TIB_Cursor.Create(Self);
    Qry.DatabaseName := DM1.ArcDBFile;
    Qry.IB_Connection := DM1.DBAzienda;
    try
      // IMposta la query in modo da richiamare i dati dell'aliquota IVA Voluta
      Qry.SQL.Add('SELECT * FROM AliqIVA WHERE CodiceIVA = ' + IntToStr(CodIVA));
      Qry.Open;
      // Se è stata trovata la importa altrimenti niente e visualizza un errore
      if not Qry.Eof then
      begin
        LocDataController.Values[Row, tvCorpoCODICEIVA.Index] := CodIVA;
        LocDataController.Values[Row, tvCorpoALIQUOTAIVA.Index] := Qry.FieldByName('AliquotaIVA').AsInteger;
        LocDataController.Values[Row, tvCorpoDESCRIZIONEIVA.Index] := Qry.FieldByName('DescrizioneIVA').AsString;
      end
      else
      begin
        DM1.Messaggi('Errore', 'Aliquota IVA non trovata. !', '', [mbOk], 0, nil)
      end;
      Qry.Close;
    finally
      Qry.Free;
    end;
  end;
end;

function TPreventiviOrdiniForm.CalcolaImportoVendRigoPerQtaEvasaODaEvadere(ImportoOriginale, QtaOriginale, QtaVoluta: Variant): Double;
begin
  // Inizializzazione
  Result := 0;
  // Verifica
  if VarIsNull(ImportoOriginale) then
    ImportoOriginale := 0;
  if VarIsNull(QtaOriginale) then
    QtaOriginale := 0;
  if VarIsNull(QtaVoluta) then
    QtaVoluta := 0;
  // Se la qtà originale = 0 ritorna subito 0
  if QtaOriginale = 0 then
    Exit;
  // Altrimenti calcola il tutto
  Result := DM1.Arrotonda(ImportoOriginale / QtaOriginale * QtaVoluta, DM1.DecMicroPrz);
end;

function TPreventiviOrdiniForm.CalcolaImportoCostoRigoPerQtaEvasaODaEvadere(CostoUnit, QtaVoluta: Variant): Double;
begin
  // Inizializzazione
  Result := 0;
  // Verifica
  if VarIsNull(CostoUnit) then
    CostoUnit := 0;
  if VarIsNull(QtaVoluta) then
    QtaVoluta := 0;
  // Altrimenti calcola il tutto
  Result := DM1.Arrotonda(CostoUnit * QtaVoluta, DM1.DecMicroPrz);
end;

// Procedura che ritorna il valore dal salvare per il campo CodiceMagazzino1 e 2
// considerando gli eventuali valori nulli e il flag che indica se tale valore
// debba essere preso dalla testata (quindi scelta magazzino per l'intero documento
// e non frazionabile) oppure dal rigo stesso (quindi possibilità di sciegliere
// il magazzino da movimentare singolarmente rigo per rigo).
function TPreventiviOrdiniForm.GetCodiceMagazzinoDaSalvare(DC: TcxCustomDataController; RowIdx, ColIdx: Longint; CampoTestata: TField): Variant;
begin
  // Se l'apposito flag indica che il CodiceMagazzino da salvare sul rigo lo devo prendere dalla testata
  // e non dal rigo stesso oppure se anche in case il flag indicasse di salvare il valore del rigo ma quest'ultimo è NULL
  // allora in questi casi salva il CodiceMagazzino della testata del documento.
  // Altrimenti salva il CodiceMagazzino del rigo stesso.
  if (not DM1.SalvaMagazzinoDocumentoDalRigo) or VarIsNull(DC.Values[RowIdx, ColIdx]) then
  begin
    if not CampoTestata.IsNull then
      Result := CampoTestata.Value;
  end
  else
    Result := DC.Values[RowIdx, ColIdx];
end;

// Procedura che salva il singolo rigo.
procedure TPreventiviOrdiniForm.SalvaRigo(TipoDocumento, Registro: String; NumDoc: Longint; DocData: TDate; Soggetto, RowIdx, ProgRigo, ProgRigo2: Longint;
  DC: TcxCustomDataController);
var
  Qry: TIB_Cursor;
  SegnoOpMag, SegnoOpCant: String;
  QtaDaEvadere: Double;
  procedure SetParamsForGC(const ASegno, AQtaParamName, AImportoAcqParamName, AImportoVendParamName: String);
  begin
    // Le impostazioni dei parametri DestMag... e DestGC... hanno la precedenza
    // su quanto impostato dalle causali.
    // Quindi le IF seguenti sono in ordine di precedenza.
    if DestGCQtaEvasa = ASegno then
    begin
      Qry.ParamByName(AQtaParamName).Value := DC.Values[RowIdx, tvCorpoQTAEVASA.Index];
      Qry.ParamByName(AImportoAcqParamName).AsDouble := CalcolaImportoCostoRigoPerQtaEvasaODaEvadere(DC.Values[RowIdx, tvCorpoPREZZOACQUISTOARTICOLO.Index],
        DC.Values[RowIdx, tvCorpoQTAEVASA.Index]);
      Qry.ParamByName(AImportoVendParamName).AsDouble := CalcolaImportoVendRigoPerQtaEvasaODaEvadere(DC.Values[RowIdx, tvCorpoIMPORTORIGO.Index],
        DC.Values[RowIdx, tvCorpoQTA.Index], DC.Values[RowIdx, tvCorpoQTAEVASA.Index]);
      Qry.ParamByName('P_SegnoOperazioneCantiere').AsString := ASegno;
    end
    else if DestGCQtaDaEvadere = ASegno then
    begin
      Qry.ParamByName(AQtaParamName).Value := QtaDaEvadere;
      Qry.ParamByName(AImportoAcqParamName).AsDouble := CalcolaImportoCostoRigoPerQtaEvasaODaEvadere(DC.Values[RowIdx, tvCorpoPREZZOACQUISTOARTICOLO.Index],
        QtaDaEvadere);
      Qry.ParamByName(AImportoVendParamName).AsDouble := CalcolaImportoVendRigoPerQtaEvasaODaEvadere(DC.Values[RowIdx, tvCorpoIMPORTORIGO.Index],
        DC.Values[RowIdx, tvCorpoQTA.Index], QtaDaEvadere);
      Qry.ParamByName('P_SegnoOperazioneCantiere').AsString := ASegno;
    end
    else if SegnoOpCant = ASegno then
    begin
      Qry.ParamByName(AQtaParamName).Value := DC.Values[RowIdx, tvCorpoQTA.Index];
      Qry.ParamByName(AImportoAcqParamName).AsDouble := CalcolaImportoCostoRigoPerQtaEvasaODaEvadere(DC.Values[RowIdx, tvCorpoPREZZOACQUISTOARTICOLO.Index],
        DC.Values[RowIdx, tvCorpoQTA.Index]);
      Qry.ParamByName(AImportoVendParamName).Value := DC.Values[RowIdx, tvCorpoIMPORTORIGO.Index];
      Qry.ParamByName('P_SegnoOperazioneCantiere').AsString := ASegno;
    end
    else
    begin
      Qry.ParamByName(AQtaParamName).AsDouble := 0;
      Qry.ParamByName(AImportoAcqParamName).AsDouble := 0;
      Qry.ParamByName(AImportoVendParamName).AsDouble := 0;
    end;
  end;

begin
  // Se è il rigo temporaneo non lo salva
  if DM1.NoNullStringValue(DC, RowIdx, tvCorpoROWTYPE.Index) = TIPORIGODOC_SottorigoTemporaneo then
    Exit;
  // Inizializzazione
  SegnoOpMag := QryDocumentoSEGNOOPERAZIONE.AsString;
  SegnoOpCant := QryDocumentoSEGNOOPERAZIONECANTIERE.AsString;
  // Verifica il GUID del rigo
  SetRowGUID(DC, RowIdx);
  // Ottiene la query per il salvataggio del rigo
  Qry := GetQrySalvaRighi;
  // Imposta i parametri della query
  Qry.ParamByName('P_TipoDocumento').AsString := TipoDocumento;
  Qry.ParamByName('P_Registro').AsString := Registro;
  Qry.ParamByName('P_NumOrdPrev').AsInteger := NumDoc;
  Qry.ParamByName('P_DataDocumento').AsDateTime := DocData;
  Qry.ParamByName('P_ProgRigo').AsInteger := ProgRigo;
  Qry.ParamByName('P_ProgRigo2').AsInteger := ProgRigo2;
  Qry.ParamByName('P_CodiceCliente').AsInteger := Soggetto;
  Qry.ParamByName('P_CodiceArticolo').AsString := DM1.NoNullStringValue(DC, RowIdx, tvCorpoCODICEARTICOLO.Index);
  Qry.ParamByName('P_CodiceArticoloStm').AsString := DM1.NoNullStringValue(DC, RowIdx, tvCorpoCODICEARTICOLOSTM.Index);
  Qry.ParamByName('P_Descrizione').AsString := Trim(DM1.StrLeft(DC.DisplayTexts[RowIdx, tvCorpoDESCRIZIONE.Index], WidthRighiDESCRIZIONE.DisplayWidth));
  Qry.ParamByName('P_PrezzoUnitario').AsDouble := DM1.NoNullFloatValue(DC, RowIdx, tvCorpoPREZZOUNITARIO.Index);
  Qry.ParamByName('P_QTA').Value := DC.Values[RowIdx, tvCorpoQTA.Index];
  Qry.ParamByName('P_ScontoRigo').AsDouble := DM1.NoNullFloatValue(DC, RowIdx, tvCorpoSCONTORIGO.Index);
  Qry.ParamByName('P_ScontoRigo2').AsDouble := DM1.NoNullFloatValue(DC, RowIdx, tvCorpoSCONTORIGO2.Index);
  Qry.ParamByName('P_ScontoRigo3').AsDouble := DM1.NoNullFloatValue(DC, RowIdx, tvCorpoSCONTORIGO3.Index);
  Qry.ParamByName('P_ImportoRigo').Value := DC.Values[RowIdx, tvCorpoIMPORTORIGO.Index];
  Qry.ParamByName('P_UnitaDiMisura').Value := DC.Values[RowIdx, tvCorpoUNITADIMISURA.Index];
  Qry.ParamByName('P_PrezzoAcquistoArticolo').Value := DC.Values[RowIdx, tvCorpoPREZZOACQUISTOARTICOLO.Index];
  Qry.ParamByName('P_ImportoCosto').Value := DC.Values[RowIdx, tvCorpoIMPORTOCOSTO.Index];
  Qry.ParamByName('P_MovMag').AsString := QryDocumentoSEGNOOPERAZIONE.AsString;
  // NB: Lasciarlo così e non che prende il dato dal rigo
  Qry.ParamByName('P_DestQtaEvasa').AsString := DestMagQtaEvasa;
  Qry.ParamByName('P_DestQtaDaEvadere').AsString := DestMagQtaDaEvadere;
  // Ricava i valori dei CodiciMagazzino chiamando l'apposita funzione
  Qry.ParamByName('P_CodiceMagazzino').Value := GetCodiceMagazzinoDaSalvare(DC, RowIdx, tvCorpoCODICEMAGAZZINO.Index, QryDocumentoCODICEMAGAZZINO);
  Qry.ParamByName('P_CodiceMagazzino2').Value := GetCodiceMagazzinoDaSalvare(DC, RowIdx, tvCorpoCODICEMAGAZZINO2.Index, QryDocumentoCODICEMAGAZZINO2);
  Qry.ParamByName('P_DescrizioneIVA').Value := DC.Values[RowIdx, tvCorpoDESCRIZIONEIVA.Index];
  Qry.ParamByName('P_AliquotaIVA').Value := DC.Values[RowIdx, tvCorpoALIQUOTAIVA.Index];
  Qry.ParamByName('P_Margine').Value := DC.Values[RowIdx, tvCorpoMARGINE.Index];
  Qry.ParamByName('P_ImportoMargine').Value := DC.Values[RowIdx, tvCorpoIMPORTOMARGINE.Index];
  Qry.ParamByName('P_NoteRigo').Value := DC.Values[RowIdx, tvCorpoNOTERIGO.Index];
  Qry.ParamByName('P_CodiceIVA').Value := DC.Values[RowIdx, tvCorpoCODICEIVA.Index];
  Qry.ParamByName('P_PrezzoUnitarioIVACompresa').Value := DC.Values[RowIdx, tvCorpoPREZZOUNITARIOIVACOMPRESA.Index];
  Qry.ParamByName('P_ImportoRigoIVACompresa').Value := DC.Values[RowIdx, tvCorpoIMPORTORIGOIVACOMPRESA.Index];
  Qry.ParamByName('P_Sinchro').AsString := RECORD_MODIFIED;

  Qry.ParamByName('P_QtaOperaUnit').Value := DC.Values[RowIdx, tvCorpoQTAOPERAUNIT.Index];
  Qry.ParamByName('P_OperaUnit').Value := DC.Values[RowIdx, tvCorpoOPERAUNIT.Index];
  Qry.ParamByName('P_ComponentiUnit').Value := DC.Values[RowIdx, tvCorpoCOMPONENTIUNIT.Index];
  Qry.ParamByName('P_CostoOperaUnit').Value := DC.Values[RowIdx, tvCorpoCOSTOCOMPONENTIUNIT.Index];
  Qry.ParamByName('P_CostoComponentiUnit').Value := DC.Values[RowIdx, tvCorpoCOSTOCOMPONENTIUNIT.Index];

  Qry.ParamByName('P_QtaOpera').Value := DC.Values[RowIdx, tvCorpoQTAOPERA.Index];
  Qry.ParamByName('P_ImportoOpera').Value := DC.Values[RowIdx, tvCorpoIMPORTOOPERA.Index];
  Qry.ParamByName('P_ImportoComponenti').Value := DC.Values[RowIdx, tvCorpoIMPORTOCOMPONENTI.Index];
  Qry.ParamByName('P_ImportoCostoOpera').Value := DC.Values[RowIdx, tvCorpoIMPORTOCOSTOOPERA.Index];
  Qry.ParamByName('P_ImportoCostoComponenti').Value := DC.Values[RowIdx, tvCorpoIMPORTOCOSTOCOMPONENTI.Index];
  Qry.ParamByName('P_ImportoMargineComponenti').Value := DC.Values[RowIdx, tvCorpoIMPORTOMARGINECOMPONENTI.Index];
  Qry.ParamByName('P_ImportoMargineOpera').Value := DC.Values[RowIdx, tvCorpoIMPORTOMARGINEOPERA.Index];
  Qry.ParamByName('P_MargineComponenti').Value := DC.Values[RowIdx, tvCorpoPERCMARGINECOMPONENTI.Index];
  Qry.ParamByName('P_MargineOpera').Value := DC.Values[RowIdx, tvCorpoPERCMARGINEOPERA.Index];

  Qry.ParamByName('P_Selezionato').Value := DC.Values[RowIdx, tvCorpoSELEZIONATO.Index];
  Qry.ParamByName('P_MinutiPrevisti').Value := DC.Values[RowIdx, tvCorpoMINUTIPREVISTI.Index];

  Qry.ParamByName('P_Sottocantiere1').AsString := DM1.NoNullStringValue(DC, RowIdx, tvCorpoSOTTOCANTIERE1.Index);
  Qry.ParamByName('P_Sottocantiere2').AsString := DM1.NoNullStringValue(DC, RowIdx, tvCorpoSOTTOCANTIERE2.Index);
  Qry.ParamByName('P_Sottocantiere3').AsString := DM1.NoNullStringValue(DC, RowIdx, tvCorpoSOTTOCANTIERE3.Index);
  Qry.ParamByName('P_Sottocantiere4').AsString := DM1.NoNullStringValue(DC, RowIdx, tvCorpoSOTTOCANTIERE4.Index);
  Qry.ParamByName('P_Sottocantiere5').AsString := DM1.NoNullStringValue(DC, RowIdx, tvCorpoSOTTOCANTIERE5.Index);
  Qry.ParamByName('P_Sottocantiere6').AsString := DM1.NoNullStringValue(DC, RowIdx, tvCorpoSOTTOCANTIERE6.Index);

  Qry.ParamByName('P_SegnoOperazioneCantiere').AsString := QryDocumentoSEGNOOPERAZIONECANTIERE.AsString;
  Qry.ParamByName('P_Pratica').AsInteger := QryDocumentoPRATICA.AsInteger;
  Qry.ParamByName('P_DataPratica1').AsDateTime := QryDocumentoDATAPRATICA1.AsDateTime;
  Qry.ParamByName('P_QtaEvasa').AsDouble := DM1.NoNullFloatValue(DC, RowIdx, tvCorpoQTAEVASA.Index);

  Qry.ParamByName('P_Tipo1').AsString := DM1.NoNullStringValue(DC, RowIdx, tvCorpoTIPO1.Index);;
  Qry.ParamByName('P_Tipo2').AsString := DM1.NoNullStringValue(DC, RowIdx, tvCorpoTIPO2.Index);;
  Qry.ParamByName('P_Tipo3').AsString := DM1.NoNullStringValue(DC, RowIdx, tvCorpoTIPO3.Index);;
  Qry.ParamByName('P_Tipo4').AsString := DM1.NoNullStringValue(DC, RowIdx, tvCorpoTIPO4.Index);;
  Qry.ParamByName('P_Tipo5').AsString := DM1.NoNullStringValue(DC, RowIdx, tvCorpoTIPO5.Index);;
  Qry.ParamByName('P_Tipo6').AsString := DM1.NoNullStringValue(DC, RowIdx, tvCorpoTIPO6.Index);;

  // =======================================================================
  // INIZIO IMPOSTAZIONE CAMPI PER LA GESTIONE DEL MAGAZZINO E DEL CANTIERE
  // -----------------------------------------------------------------------
  // Prima di tutto carica su una variabile locale il valore della QtaDaEvadere del rigo
  // perchè altrimenti siccome si tratta di un campo calcolato al volo
  // nel relativo evento OnGetDataText ci sarebbero delle difficoltà
  QtaDaEvadere := CalcolaQtaDaEvadere(DC, RowIdx);
  // GC_COMMESSA
  SetParamsForGC('C', 'P_GC_COMMESSA_QTA', 'P_GC_COMMESSA_IMPORTOACQ', 'P_GC_COMMESSA_IMPORTOVEND');
  // GC_CARICO
  SetParamsForGC('+', 'P_GC_CARICO_QTA', 'P_GC_CARICO_IMPORTOACQ', 'P_GC_CARICO_IMPORTOVEND');
  // GC_SCARICO
  SetParamsForGC('-', 'P_GC_SCARICO_QTA', 'P_GC_SCARICO_IMPORTOACQ', 'P_GC_SCARICO_IMPORTOVEND');
  // GC_FATTURATO
  SetParamsForGC('F', 'P_GC_FATTURATO_QTA', 'P_GC_FATTURATO_IMPORTOACQ', 'P_GC_FATTURATO_IMPORTOVEND');
  // GC_MONTATO
  SetParamsForGC('M', 'P_GC_MONTATO_QTA', 'P_GC_MONTATO_IMPORTOACQ', 'P_GC_MONTATO_IMPORTOVEND');

//  // GC_MONTATO (Le impostazioni dei parametri DestMag... e DestGC... hanno la precedenza
//  // su quanto impostato dalle causali.
//  // Quindi le IF seguenti sono in ordine di precedenza.
//  if DestGCQtaEvasa = 'M' then
//    Qry.ParamByName('P_GC_MONTATO_QTA').Value := DC.Values[RowIdx, tvCorpoQTAEVASA.Index]
//  else if DestGCQtaDaEvadere = 'M' then
//    Qry.ParamByName('P_GC_MONTATO_QTA').AsDouble := QtaDaEvadere
//  else if SegnoOpCant = 'M' then
//    Qry.ParamByName('P_GC_MONTATO_QTA').Value := DC.Values[RowIdx, tvCorpoQTA.Index]
//  else
//    Qry.ParamByName('P_GC_MONTATO_QTA').AsDouble := 0;

  // Altri campi relativi al GC
  Qry.ParamByName('P_GC_COSTONETTOUNITARIO_MOD').Value := DC.Values[RowIdx, tvCorpoGC_COSTONETTOUNITARIO_MOD.Index];
  Qry.ParamByName('P_GC_COSTONETTOUNITARIO').Value := DC.Values[RowIdx, tvCorpoGC_COSTONETTOUNITARIO.Index];
  Qry.ParamByName('P_GC_RICARICO_MOD').Value := DC.Values[RowIdx, tvCorpoGC_RICARICO_MOD.Index];
  Qry.ParamByName('P_GC_RICARICO').Value := DC.Values[RowIdx, tvCorpoGC_RICARICO.Index];
  Qry.ParamByName('P_GC_QTA_MOD').Value := DC.Values[RowIdx, tvCorpoGC_QTA_MOD.Index];
  Qry.ParamByName('P_GC_QTA').Value := DC.Values[RowIdx, tvCorpoGC_QTA.Index];
  Qry.ParamByName('P_GC_DESCRIZIONE_MOD').Value := DC.Values[RowIdx, tvCorpoGC_DESCRIZIONE_MOD.Index];
  Qry.ParamByName('P_GC_DESCRIZIONE').AsString := Trim(DM1.StrLeft(DC.DisplayTexts[RowIdx, tvCorpoGC_DESCRIZIONE.Index], WidthRighiDESCRIZIONE.DisplayWidth));
  // -----------------------------------------------------------------------
  // FINE IMPOSTAZIONE CAMPI PER LA GESTIONE DEL MAGAZZINO E DEL CANTIERE
  // =======================================================================

  Qry.ParamByName('P_GUID').Value := DC.Values[RowIdx, tvCorpoGUID.Index];
  Qry.ParamByName('P_GUID_REF').Value := DC.Values[RowIdx, tvCorpoGUID_REF.Index];
  Qry.ParamByName('P_GUID_ANCESTOR').Value := DC.Values[RowIdx, tvCorpoGUID_ANCESTOR.Index];
  Qry.ParamByName('P_IDAPPARECCHIOPRAT').Value := DC.Values[RowIdx, tvCorpoIDAPPARECCHIO.Index];
  Qry.ParamByName('P_IDOPIMPEGNO').Value := DC.Values[RowIdx, tvCorpoIDOPIMPEGNO.Index];
  Qry.ParamByName('P_PrezzoUnitarioAutocalc').Value := DC.Values[RowIdx, tvCorpoPREZZOUNITARIOAUTOCALC.Index];
  Qry.ParamByName('P_RowType').Value := DC.Values[RowIdx, tvCorpoROWTYPE.Index];
  Qry.ParamByName('P_RowPrintPrices').Value := DC.Values[RowIdx, tvCorpoROWPRINTPRICES.Index];
  Qry.ParamByName('P_RowSection').Value := DC.Values[RowIdx, tvCorpoROWSECTION.Index];

  Qry.ParamByName('P_ADG1_TIPODATO').Value := DC.Values[RowIdx, tvCorpoADG1_TIPODATO.Index];
  Qry.ParamByName('P_ADG1_RIFERIMENTOTESTO').Value := DC.Values[RowIdx, tvCorpoADG1_RIFERIMENTOTESTO.Index];
  Qry.ParamByName('P_ADG1_RIFERIMENTONUMERO').Value := DC.Values[RowIdx, tvCorpoADG1_RIFERIMENTONUMERO.Index];
  Qry.ParamByName('P_ADG1_RIFERIMENTODATA').Value := DC.Values[RowIdx, tvCorpoADG1_RIFERIMENTODATA.Index];

  Qry.ExecSQL;
end;

// Salva il sottorigo di manodopera attuale
procedure TPreventiviOrdiniForm.SalvaRigoManodopera(TipoDocumento, Registro: String; NumDoc: Longint; DocData: TDate; Soggetto: Integer; CodPrat: Integer;
  DataPrat: String; RowIdx, ProgRigo, ProgRigo2: Longint; DC: TcxCustomDataController);
var
  Qry: TIB_Cursor;
begin
  // Se si tratta del rigo obbligatorio non lo salva ed esce subito
  if not VarIsNull(DC.Values[RowIdx, tvOreCODDIPENDENTE.Index]) and (DC.Values[RowIdx, tvOreCODDIPENDENTE.Index] = -1) then
    Exit;
  // Ottiene la query per il salvataggio del rigo
  Qry := GetQrySalvaRighiOre;
  // Imposta i parametri della query
  Qry.ParamByName('P_TIPODOC').AsString := TipoDocumento;
  Qry.ParamByName('P_NUMDOC').AsInteger := NumDoc;
  Qry.ParamByName('P_DATADOC').AsDateTime := DocData;
  Qry.ParamByName('P_REGISTRO').AsString := Registro;
  Qry.ParamByName('P_NUMRIGO').AsInteger := ProgRigo;
  Qry.ParamByName('P_NUMRIGO2').AsInteger := ProgRigo2;
  Qry.ParamByName('P_CODDIPENDENTE').Value := DC.Values[RowIdx, tvOreCODDIPENDENTE.Index];
  Qry.ParamByName('P_DESCRIZDIPENDENTE').Value := DC.Values[RowIdx, tvOreDESCRIZDIPENDENTE.Index];

  // Pratica
  if CodPrat > 0 then
    Qry.ParamByName('P_CODCANTIERE').AsInteger := CodPrat
  else
    Qry.ParamByName('P_CODCANTIERE').Clear;
  // Data pratica
  if DataPrat <> '' then
    Qry.ParamByName('P_DATACANTIERE').AsDateTime := StrToDate(DataPrat)
  else
    Qry.ParamByName('P_DATACANTIERE').Clear;
  // Descrizione pratica
  if EditDescrizionePratica1.Text <> '' then
    Qry.ParamByName('P_DESCRIZCANTIERE').AsString := EditDescrizionePratica1.Text
  else
    Qry.ParamByName('P_DESCRIZCANTIERE').Clear;

  // Soggetto
  Qry.ParamByName('P_CODSOGGETTO').AsInteger := Soggetto;
  Qry.ParamByName('P_CODICEDESCRIZSOGGETTO').AsInteger := Soggetto;

  Qry.ParamByName('P_QTA').Value := DC.Values[RowIdx, tvOreQTA.Index];
  Qry.ParamByName('P_COSTOORARIO').Value := DC.Values[RowIdx, tvOreCOSTOORARIO.Index];
  Qry.ParamByName('P_IMPORTOCOSTOORARIO').Value := DC.Values[RowIdx, tvOreIMPORTOCOSTOORARIO.Index];
  Qry.ParamByName('P_NOTE').Value := DC.Values[RowIdx, tvOreNOTE.Index];

  Qry.ParamByName('P_TIPOORE1').Value := DC.Values[RowIdx, tvOreTIPOORE1.Index];
  Qry.ParamByName('P_TIPOORE2').Value := DC.Values[RowIdx, tvOreTIPOORE2.Index];
  Qry.ParamByName('P_TIPOORE3').Value := DC.Values[RowIdx, tvOreTIPOORE3.Index];

  Qry.ParamByName('P_TIPO1').Value := DC.Values[RowIdx, tvOreTIPO1.Index];
  Qry.ParamByName('P_TIPO2').Value := DC.Values[RowIdx, tvOreTIPO2.Index];
  Qry.ParamByName('P_TIPO3').Value := DC.Values[RowIdx, tvOreTIPO3.Index];
  Qry.ParamByName('P_TIPO4').Value := DC.Values[RowIdx, tvOreTIPO4.Index];
  Qry.ParamByName('P_TIPO5').Value := DC.Values[RowIdx, tvOreTIPO5.Index];
  Qry.ParamByName('P_TIPO6').Value := DC.Values[RowIdx, tvOreTIPO6.Index];

  Qry.ParamByName('P_OPERAINDEX').Value := DC.Values[RowIdx, tvOreOPERAINDEX.Index];
  Qry.ParamByName('P_PRZVEND').Value := DC.Values[RowIdx, tvOrePRZUNITVEND.Index];
  Qry.ParamByName('P_IMPORTOVEND').Value := DC.Values[RowIdx, tvOreIMPORTOVEND.Index];
  Qry.ParamByName('P_SEGNOOPERAZIONECANTIERE').AsString := QryDocumentoSEGNOOPERAZIONECANTIERE.AsString;

  Qry.ParamByName('P_SOTTOCANTIERE1').AsString := DM1.NoNullStringValue(DC, RowIdx, tvOreSOTTOCANTIERE1.Index);
  Qry.ParamByName('P_SOTTOCANTIERE2').AsString := DM1.NoNullStringValue(DC, RowIdx, tvOreSOTTOCANTIERE2.Index);
  Qry.ParamByName('P_SOTTOCANTIERE3').AsString := DM1.NoNullStringValue(DC, RowIdx, tvOreSOTTOCANTIERE3.Index);

  Qry.ParamByName('P_GC_COSTONETTOUNITARIO_MOD').Value := DC.Values[RowIdx, tvOreGC_COSTONETTOUNITARIO_MOD.Index];
  Qry.ParamByName('P_GC_COSTONETTOUNITARIO').Value := DC.Values[RowIdx, tvOreGC_COSTONETTOUNITARIO.Index];
  Qry.ParamByName('P_GC_RICARICO_MOD').Value := DC.Values[RowIdx, tvOreGC_RICARICO_MOD.Index];
  Qry.ParamByName('P_GC_RICARICO').Value := DC.Values[RowIdx, tvOreGC_RICARICO.Index];
  Qry.ParamByName('P_GC_QTA_MOD').Value := DC.Values[RowIdx, tvOreGC_QTA_MOD.Index];
  Qry.ParamByName('P_GC_QTA').Value := DC.Values[RowIdx, tvOreGC_QTA.Index];
  Qry.ParamByName('P_GC_DESCRIZIONE_MOD').Value := DC.Values[RowIdx, tvOreGC_DESCRIZIONE_MOD.Index];
  Qry.ParamByName('P_GC_DESCRIZIONE').AsString := Trim(DM1.StrLeft(DC.DisplayTexts[RowIdx, tvOreGC_DESCRIZIONE.Index], WidthRighiDESCRIZIONE.DisplayWidth));

  Qry.ParamByName('P_GUID').Value := DC.Values[RowIdx, tvOreGUID.Index];
  Qry.ParamByName('P_GUID_REF').Value := DC.Values[RowIdx, tvOreGUID_REF.Index];
  Qry.ParamByName('P_GUID_ANCESTOR').Value := DC.Values[RowIdx, tvOreGUID_ANCESTOR.Index];

  Qry.ExecSQL;
end;

procedure TPreventiviOrdiniForm.SalvaRighiAccorpatiInUnUnicoRigo(TipoDocumento, Registro: String; NumDoc: Longint; DocData: TDate;
  Soggetto, RowIdx, ProgRigo: Longint);
var
  TotQta, TotQtaOpera, TotQtaEvasa, TotMinutiPrevisti, TotImportoRigo, TotImportoRigoIVACompresa: Real;
  i: Integer;
  Qry: TIB_Cursor;
  DC: TcxCustomDataController;
begin
  TotQta := 0;
  TotQtaOpera := 0;
  TotQtaEvasa := 0;
  TotMinutiPrevisti := 0;
  TotImportoRigo := 0;
  TotImportoRigoIVACompresa := 0;

  // Crea l'oggetto Qry
  Qry := TIB_Cursor.Create(Self);
  Qry.DatabaseName := DM1.ArcDBFile;
  Qry.IB_Connection := DM1.DBAzienda;
  try
    // DC Punta al DataController
    DC := tvCorpo.DataController;
    // Cicla per tutti i righi successivi a quello puntato da RowIndex (che è quello che stiamo salvando)
    for i := (RowIdx + 1) to DC.RecordCount - 1 do
    begin
      // Prima di tutto se il rigo è già stato marcato per l'eliminazione
      if not DC.Values[i, tvCorpoTODELETE.Index] then
      begin
        // In base al tipo di accorpamento specificato in Layouts.ini effettua tipi di controllo di accorpamento
        // diverso.
        // NB: 0 = Accorpamento righi disabilitato
        // 1 = Accorpamento righi che controlla tutti i campi del rigo documento e somma della Qtà dei righi assolutamente identici
        // 2 = Accorpamento righi che controlla solo il codice e la descrizione e somma gli importi del rigo e Qtà sempre = 1
        if TipoAccorpamentoRighi = 1 then
        begin
          if (DM1.NoNullStringValue(DC, i, tvCorpoCODICEARTICOLO.Index) = DM1.NoNullStringValue(DC, RowIdx, tvCorpoCODICEARTICOLO.Index)) and
            (DM1.NoNullStringValue(DC, i, tvCorpoCODICEARTICOLOSTM.Index) = DM1.NoNullStringValue(DC, RowIdx, tvCorpoCODICEARTICOLOSTM.Index)) and
            (DM1.NoNullStringValue(DC, i, tvCorpoDESCRIZIONE.Index) = DM1.NoNullStringValue(DC, RowIdx, tvCorpoDESCRIZIONE.Index)) and
            (DM1.NoNullFloatValue(DC, i, tvCorpoPREZZOUNITARIO.Index) = DM1.NoNullFloatValue(DC, RowIdx, tvCorpoPREZZOUNITARIO.Index)) and
            (DM1.NoNullFloatValue(DC, i, tvCorpoSCONTORIGO.Index) = DM1.NoNullFloatValue(DC, RowIdx, tvCorpoSCONTORIGO.Index)) and
            (DM1.NoNullFloatValue(DC, i, tvCorpoSCONTORIGO2.Index) = DM1.NoNullFloatValue(DC, RowIdx, tvCorpoSCONTORIGO2.Index)) and
            (DM1.NoNullFloatValue(DC, i, tvCorpoSCONTORIGO3.Index) = DM1.NoNullFloatValue(DC, RowIdx, tvCorpoSCONTORIGO3.Index)) and
            (DM1.NoNullStringValue(DC, i, tvCorpoUNITADIMISURA.Index) = DM1.NoNullStringValue(DC, RowIdx, tvCorpoUNITADIMISURA.Index)) and
            (DM1.NoNullFloatValue(DC, i, tvCorpoPREZZOACQUISTOARTICOLO.Index) = DM1.NoNullFloatValue(DC, RowIdx, tvCorpoPREZZOACQUISTOARTICOLO.Index)) and
            (DM1.NoNullIntValue(DC, i, tvCorpoCODICEIVA.Index) = DM1.NoNullIntValue(DC, RowIdx, tvCorpoCODICEIVA.Index)) and
            (DM1.NoNullFloatValue(DC, i, tvCorpoMARGINE.Index) = DM1.NoNullFloatValue(DC, RowIdx, tvCorpoMARGINE.Index)) and
            (DM1.NoNullStringValue(DC, i, tvCorpoMOVMAG.Index) = DM1.NoNullStringValue(DC, RowIdx, tvCorpoMOVMAG.Index))
          // and(DM1.NoNullStringValue(DC,i,tvCorpoSELEZIONATO.Index) = DM1.NoNullStringValue(DC,RowIdx,tvCorpoSELEZIONATO.Index))

          // Ricava i valori da confrontare relativi ai magazzini dall'apposita funzione
            and (GetCodiceMagazzinoDaSalvare(DC, i, tvCorpoCODICEMAGAZZINO.Index, QryDocumentoCODICEMAGAZZINO) = GetCodiceMagazzinoDaSalvare(DC, RowIdx,
            tvCorpoCODICEMAGAZZINO.Index, QryDocumentoCODICEMAGAZZINO)) and
            (GetCodiceMagazzinoDaSalvare(DC, i, tvCorpoCODICEMAGAZZINO2.Index, QryDocumentoCODICEMAGAZZINO2) = GetCodiceMagazzinoDaSalvare(DC, RowIdx,
            tvCorpoCODICEMAGAZZINO2.Index, QryDocumentoCODICEMAGAZZINO2))

            and (DM1.NoNullFloatValue(DC, i, tvCorpoPREZZOUNITARIOIVACOMPRESA.Index) = DM1.NoNullFloatValue(DC, RowIdx, tvCorpoPREZZOUNITARIOIVACOMPRESA.Index))
            and (DM1.NoNullStringValue(DC, i, tvCorpoSOTTOCANTIERE1.Index) = DM1.NoNullStringValue(DC, RowIdx, tvCorpoSOTTOCANTIERE1.Index)) and
            (DM1.NoNullStringValue(DC, i, tvCorpoSOTTOCANTIERE2.Index) = DM1.NoNullStringValue(DC, RowIdx, tvCorpoSOTTOCANTIERE2.Index)) and
            (DM1.NoNullStringValue(DC, i, tvCorpoSOTTOCANTIERE3.Index) = DM1.NoNullStringValue(DC, RowIdx, tvCorpoSOTTOCANTIERE3.Index)) and
            (DM1.NoNullStringValue(DC, i, tvCorpoSOTTOCANTIERE4.Index) = DM1.NoNullStringValue(DC, RowIdx, tvCorpoSOTTOCANTIERE1.Index)) and
            (DM1.NoNullStringValue(DC, i, tvCorpoSOTTOCANTIERE5.Index) = DM1.NoNullStringValue(DC, RowIdx, tvCorpoSOTTOCANTIERE2.Index)) and
            (DM1.NoNullStringValue(DC, i, tvCorpoSOTTOCANTIERE6.Index) = DM1.NoNullStringValue(DC, RowIdx, tvCorpoSOTTOCANTIERE3.Index))

            and (DM1.NoNullStringValue(DC, i, tvCorpoTIPO1.Index) = DM1.NoNullStringValue(DC, RowIdx, tvCorpoTIPO1.Index)) and
            (DM1.NoNullStringValue(DC, i, tvCorpoTIPO2.Index) = DM1.NoNullStringValue(DC, RowIdx, tvCorpoTIPO2.Index)) and
            (DM1.NoNullStringValue(DC, i, tvCorpoTIPO3.Index) = DM1.NoNullStringValue(DC, RowIdx, tvCorpoTIPO3.Index)) and
            (DM1.NoNullStringValue(DC, i, tvCorpoTIPO4.Index) = DM1.NoNullStringValue(DC, RowIdx, tvCorpoTIPO4.Index)) and
            (DM1.NoNullStringValue(DC, i, tvCorpoTIPO5.Index) = DM1.NoNullStringValue(DC, RowIdx, tvCorpoTIPO5.Index)) and
            (DM1.NoNullStringValue(DC, i, tvCorpoTIPO6.Index) = DM1.NoNullStringValue(DC, RowIdx, tvCorpoTIPO6.Index)) and
            (DM1.NoNullStringValue(DC, i, tvCorpoGC_COSTONETTOUNITARIO_MOD.Index) = DM1.NoNullStringValue(DC, RowIdx, tvCorpoGC_COSTONETTOUNITARIO_MOD.Index))
            and (DM1.NoNullFloatValue(DC, i, tvCorpoGC_COSTONETTOUNITARIO.Index) = DM1.NoNullFloatValue(DC, RowIdx, tvCorpoGC_COSTONETTOUNITARIO.Index)) and
            (DM1.NoNullStringValue(DC, i, tvCorpoGC_RICARICO_MOD.Index) = DM1.NoNullStringValue(DC, RowIdx, tvCorpoGC_RICARICO_MOD.Index)) and
            (DM1.NoNullFloatValue(DC, i, tvCorpoGC_RICARICO.Index) = DM1.NoNullFloatValue(DC, RowIdx, tvCorpoGC_RICARICO.Index)) and
            (DM1.NoNullStringValue(DC, i, tvCorpoGC_QTA_MOD.Index) = DM1.NoNullStringValue(DC, RowIdx, tvCorpoGC_QTA_MOD.Index)) and
            (DM1.NoNullFloatValue(DC, i, tvCorpoGC_QTA.Index) = DM1.NoNullFloatValue(DC, RowIdx, tvCorpoGC_QTA.Index)) and
            (DM1.NoNullStringValue(DC, i, tvCorpoGC_DESCRIZIONE_MOD.Index) = DM1.NoNullStringValue(DC, RowIdx, tvCorpoGC_DESCRIZIONE_MOD.Index)) and
            (DM1.NoNullStringValue(DC, i, tvCorpoGC_DESCRIZIONE.Index) = DM1.NoNullStringValue(DC, RowIdx, tvCorpoGC_DESCRIZIONE.Index)) and
            (DM1.NoNullStringValue(DC, i, tvCorpoIDAPPARECCHIO.Index) = DM1.NoNullStringValue(DC, RowIdx, tvCorpoIDAPPARECCHIO.Index)) and
            (DM1.NoNullStringValue(DC, i, tvCorpoIDOPIMPEGNO.Index) = DM1.NoNullStringValue(DC, RowIdx, tvCorpoIDOPIMPEGNO.Index)) then
          begin
            // Aggiorna i totali
            TotQta := TotQta + DM1.NoNullFloatValue(DC, i, tvCorpoQTA.Index);
            TotQtaOpera := TotQtaOpera + DM1.NoNullFloatValue(DC, i, tvCorpoQTAOPERA.Index);
            TotQtaEvasa := TotQtaEvasa + DM1.NoNullFloatValue(DC, i, tvCorpoQTAEVASA.Index);
            TotMinutiPrevisti := TotMinutiPrevisti + DM1.NoNullIntValue(DC, i, tvCorpoMINUTIPREVISTI.Index);
            // Marca il record corrente come eliminare
            DC.Values[i, tvCorpoTODELETE.Index] := True;
          end;

        end
        else if TipoAccorpamentoRighi = 2 then
        begin
          if (DM1.NoNullStringValue(DC, i, tvCorpoCODICEARTICOLO.Index) = DM1.NoNullStringValue(DC, RowIdx, tvCorpoCODICEARTICOLO.Index)) and
            (DM1.NoNullStringValue(DC, i, tvCorpoCODICEARTICOLOSTM.Index) = DM1.NoNullStringValue(DC, RowIdx, tvCorpoCODICEARTICOLOSTM.Index)) and
            (DM1.NoNullStringValue(DC, i, tvCorpoDESCRIZIONE.Index) = DM1.NoNullStringValue(DC, RowIdx, tvCorpoDESCRIZIONE.Index)) and
            (DM1.NoNullIntValue(DC, i, tvCorpoCODICEIVA.Index) = DM1.NoNullIntValue(DC, RowIdx, tvCorpoCODICEIVA.Index)) and
            (DM1.NoNullStringValue(DC, i, tvCorpoMOVMAG.Index) = DM1.NoNullStringValue(DC, RowIdx, tvCorpoMOVMAG.Index))
          // and(DM1.NoNullStringValue(DC,i,tvCorpoSELEZIONATO.Index)               = DM1.NoNullStringValue(DC,RowIdx,tvCorpoSELEZIONATO.Index))

          // Ricava i valori da confrontare relativi ai magazzini dall'apposita funzione
            and (GetCodiceMagazzinoDaSalvare(DC, i, tvCorpoCODICEMAGAZZINO.Index, QryDocumentoCODICEMAGAZZINO) = GetCodiceMagazzinoDaSalvare(DC, RowIdx,
            tvCorpoCODICEMAGAZZINO.Index, QryDocumentoCODICEMAGAZZINO)) and
            (GetCodiceMagazzinoDaSalvare(DC, i, tvCorpoCODICEMAGAZZINO2.Index, QryDocumentoCODICEMAGAZZINO2) = GetCodiceMagazzinoDaSalvare(DC, RowIdx,
            tvCorpoCODICEMAGAZZINO2.Index, QryDocumentoCODICEMAGAZZINO2))

            and (DM1.NoNullFloatValue(DC, i, tvCorpoSOTTOCANTIERE1.Index) = DM1.NoNullFloatValue(DC, RowIdx, tvCorpoSOTTOCANTIERE1.Index)) and
            (DM1.NoNullFloatValue(DC, i, tvCorpoSOTTOCANTIERE2.Index) = DM1.NoNullFloatValue(DC, RowIdx, tvCorpoSOTTOCANTIERE2.Index)) and
            (DM1.NoNullFloatValue(DC, i, tvCorpoSOTTOCANTIERE3.Index) = DM1.NoNullFloatValue(DC, RowIdx, tvCorpoSOTTOCANTIERE3.Index)) and
            (DM1.NoNullStringValue(DC, i, tvCorpoSOTTOCANTIERE4.Index) = DM1.NoNullStringValue(DC, RowIdx, tvCorpoSOTTOCANTIERE1.Index)) and
            (DM1.NoNullStringValue(DC, i, tvCorpoSOTTOCANTIERE5.Index) = DM1.NoNullStringValue(DC, RowIdx, tvCorpoSOTTOCANTIERE2.Index)) and
            (DM1.NoNullStringValue(DC, i, tvCorpoSOTTOCANTIERE6.Index) = DM1.NoNullStringValue(DC, RowIdx, tvCorpoSOTTOCANTIERE3.Index))

            and (DM1.NoNullStringValue(DC, i, tvCorpoTIPO1.Index) = DM1.NoNullStringValue(DC, RowIdx, tvCorpoTIPO1.Index)) and
            (DM1.NoNullStringValue(DC, i, tvCorpoTIPO2.Index) = DM1.NoNullStringValue(DC, RowIdx, tvCorpoTIPO2.Index)) and
            (DM1.NoNullStringValue(DC, i, tvCorpoTIPO3.Index) = DM1.NoNullStringValue(DC, RowIdx, tvCorpoTIPO3.Index)) and
            (DM1.NoNullStringValue(DC, i, tvCorpoTIPO4.Index) = DM1.NoNullStringValue(DC, RowIdx, tvCorpoTIPO4.Index)) and
            (DM1.NoNullStringValue(DC, i, tvCorpoTIPO5.Index) = DM1.NoNullStringValue(DC, RowIdx, tvCorpoTIPO5.Index)) and
            (DM1.NoNullStringValue(DC, i, tvCorpoTIPO6.Index) = DM1.NoNullStringValue(DC, RowIdx, tvCorpoTIPO6.Index)) and
            (DM1.NoNullStringValue(DC, i, tvCorpoGC_COSTONETTOUNITARIO_MOD.Index) = DM1.NoNullStringValue(DC, RowIdx, tvCorpoGC_COSTONETTOUNITARIO_MOD.Index))
            and (DM1.NoNullFloatValue(DC, i, tvCorpoGC_COSTONETTOUNITARIO.Index) = DM1.NoNullFloatValue(DC, RowIdx, tvCorpoGC_COSTONETTOUNITARIO.Index)) and
            (DM1.NoNullStringValue(DC, i, tvCorpoGC_RICARICO_MOD.Index) = DM1.NoNullStringValue(DC, RowIdx, tvCorpoGC_RICARICO_MOD.Index)) and
            (DM1.NoNullFloatValue(DC, i, tvCorpoGC_RICARICO.Index) = DM1.NoNullFloatValue(DC, RowIdx, tvCorpoGC_RICARICO.Index)) and
            (DM1.NoNullStringValue(DC, i, tvCorpoGC_QTA_MOD.Index) = DM1.NoNullStringValue(DC, RowIdx, tvCorpoGC_QTA_MOD.Index)) and
            (DM1.NoNullFloatValue(DC, i, tvCorpoGC_QTA.Index) = DM1.NoNullFloatValue(DC, RowIdx, tvCorpoGC_QTA.Index)) and
            (DM1.NoNullStringValue(DC, i, tvCorpoGC_DESCRIZIONE_MOD.Index) = DM1.NoNullStringValue(DC, RowIdx, tvCorpoGC_DESCRIZIONE_MOD.Index)) and
            (DM1.NoNullStringValue(DC, i, tvCorpoGC_DESCRIZIONE.Index) = DM1.NoNullStringValue(DC, RowIdx, tvCorpoGC_DESCRIZIONE.Index)) and
            (DM1.NoNullStringValue(DC, i, tvCorpoIDAPPARECCHIO.Index) = DM1.NoNullStringValue(DC, RowIdx, tvCorpoIDAPPARECCHIO.Index)) and
            (DM1.NoNullStringValue(DC, i, tvCorpoIDOPIMPEGNO.Index) = DM1.NoNullStringValue(DC, RowIdx, tvCorpoIDOPIMPEGNO.Index)) then
          begin
            // Aggiorna i totali
            TotImportoRigo := TotImportoRigo + DM1.NoNullFloatValue(DC, i, tvCorpoIMPORTORIGO.Index);
            TotImportoRigoIVACompresa := TotImportoRigoIVACompresa + DM1.NoNullFloatValue(DC, i, tvCorpoIMPORTORIGOIVACOMPRESA.Index);
            TotMinutiPrevisti := TotMinutiPrevisti + DM1.NoNullIntValue(DC, i, tvCorpoMINUTIPREVISTI.Index);
            // Marca il record corrente come da eliminare
            DC.Values[i, tvCorpoTODELETE.Index] := True;
          end;
        end;
      end;
    end;

    // In base al tipo di accorpamento specificato in Layouts.ini imposta gli importi del rigo accorpato in modo diverso
    // NB: 0 = Accorpamento righi disabilitato
    // 1 = Accorpamento righi che controlla tutti i campi del rigo documento e somma della Qtà dei righi assolutamente identici
    // 2 = Accorpamento righi che controlla solo il codice e la descrizione e somma gli importi del rigo e Qtà sempre = 1
    if TipoAccorpamentoRighi = 1 then
    begin
      // Aggiunge alla qtà del primo rigo i TotaliQtà fin quì calcolati
      DC.Values[RowIdx, tvCorpoQTA.Index] := DM1.NoNullFloatValue(DC, RowIdx, tvCorpoQTA.Index) + TotQta;
      DC.Values[RowIdx, tvCorpoQTAOPERA.Index] := DM1.NoNullFloatValue(DC, RowIdx, tvCorpoQTAOPERA.Index) + TotQtaOpera;
      DC.Values[RowIdx, tvCorpoQTAEVASA.Index] := DM1.NoNullFloatValue(DC, RowIdx, tvCorpoQTAEVASA.Index) + TotQtaEvasa;
      DC.Values[RowIdx, tvCorpoMINUTIPREVISTI.Index] := DM1.NoNullFloatValue(DC, RowIdx, tvCorpoMINUTIPREVISTI.Index) + TotMinutiPrevisti;
    end
    else if TipoAccorpamentoRighi = 2 then
    begin
      // Imposta i campi del rigo risultante con i valori calcolati
      DC.Values[RowIdx, tvCorpoPREZZOUNITARIO.Index] := DM1.NoNullFloatValue(DC, RowIdx, tvCorpoIMPORTORIGO.Index) + TotImportoRigo;
      DC.Values[RowIdx, tvCorpoSCONTORIGO.Index] := 0;
      DC.Values[RowIdx, tvCorpoSCONTORIGO2.Index] := 0;
      DC.Values[RowIdx, tvCorpoSCONTORIGO3.Index] := 0;
      DC.Values[RowIdx, tvCorpoUNITADIMISURA.Index] := 'N.';
      DC.Values[RowIdx, tvCorpoPREZZOACQUISTOARTICOLO.Index] := TotImportoRigo;
      DC.Values[RowIdx, tvCorpoMARGINE.Index] := 0;
      DC.Values[RowIdx, tvCorpoPREZZOUNITARIOIVACOMPRESA.Index] := TotImportoRigoIVACompresa;
      DC.Values[RowIdx, tvCorpoQTA.Index] := 1;
      DC.Values[RowIdx, tvCorpoQTAOPERA.Index] := 0;
      DC.Values[RowIdx, tvCorpoMINUTIPREVISTI.Index] := DM1.NoNullFloatValue(DC, RowIdx, tvCorpoMINUTIPREVISTI.Index) + TotMinutiPrevisti;
    end;
    // Ricalcola IMPORTO RIGO
    CalcolaImportoRigo(DC, RowIdx);
    // Salva il rigo così ottenuto.
    // NB: ProgRigo2 := -1 perchè se è un rigo accorpato non può essere un sottorigo
    // nb: Questa riga sostituisce tutto il blocco di salvataggio sottostante ora commentato
    SalvaRigo(TipoDocumento, Registro, NumDoc, DocData, Soggetto, RowIdx, ProgRigo, -1, DC);
  finally
    // Distrugge Qry
    Qry.Free;
  end;
end;

procedure TPreventiviOrdiniForm.SalvaRighiDocumento(TipoDocumento, Reg: String; NumDoc: Longint; DocData: TDate; Soggetto: Longint; AccorpaRighi: Boolean);
var
  Qry: TIB_Cursor;
  i, ii, ProgRigo, ProgRigo2: Integer;
  DC, DDC: TcxCustomDataController;
  IsManodopera: Boolean;
  CodPrat: Integer;
  DataPrat: String;
begin
  // Inizializzazione
  DC := tvCorpo.DataController;
  // Crea l'oggetto Qry
  Qry := TIB_Cursor.Create(Self);
  Qry.DatabaseName := DM1.ArcDBFile;
  Qry.IB_Connection := DM1.DBAzienda;
  // Avvia una transazione per cercare di migliorare le prestazioni
  // NB: Al momento l'ho aggiunto qui solo per motivi di prestazioni
  // e anche per evitare che in caso di errori dopo aver eliminato tutti i record
  // precedenti se si virificasse un errore l'utente perda tutti i righi.
  // NB: Provo a toglierlo perchè ho messo la transazione alla conferma del documento
  // DM1.DBAzienda.StartTransaction;
  try
    try
      DC.BeginFullUpdate;
      // FASE DI ELIMINAZIONE DEI VECCHI RECORD
      // =========================================================================================================================
      // Prima esegue una query che elimina dal file 'RighiPrv' i righi del documento
      // di cui si devono aggiornare i righi modificati e/o aggiunti.
      // NB: In modalità di fatturazione differita non esegue l'operazione perchè non necessaria ed inoltre
      // eliminerebbe i righi del documento emesso predentemente in quanto le variabili globali TipoDoc,
      // Registro, NumeroDoc, DataDoc contengono i dati del documento predente perchè quando viene chiamato
      // il salvataggio del documento non sono ancora stati aggiornati.
      // NB: Non elimina i righi vecchi  nemmeno se siamo in modalità di gestione di versioni multiple
      // dello stesso documento perchè altrimenti cancellerebbe i righi della vecchia versione del
      // documento che invece deve rimanere come era.
      if (Tag <> MODE_KIOSK) and (Tag <> MODE_FATTURAZIONE_DIFFERITA) and
        not(AbilitaGestioneVersioniDocumento and ((GestVerDoc_Mode = mfNuovaVersione) or (GestVerDoc_Mode = mfNuovoProtocollo))) then
      begin
        // --------------------------------------------------------------------
        // Elimina i vecchi righi documento
        // --------------------------------------------------------------------
        Qry.SQL.Add('DELETE');
        Qry.SQL.Add('FROM ' + RighiTable);
        Qry.SQL.Add('WHERE');
        // NB: Per eliminare i vecchi righi usa le variabili globali che indentificano il documento che
        // a questo punto contengono i valori identificativi non aggiornati (nel caso si fossero cambiati uno dei
        // dati della chiave del documento) e quindi permettono di eliminare i vecchi righi correttamente.
        Qry.SQL.Add('    TipoDocumento = ''' + TipoDoc + '''');
        Qry.SQL.Add('AND Registro = ''' + Registro + '''');
        Qry.SQL.Add('AND NumOrdPrev = ' + IntToStr(NumeroDoc));
        Qry.SQL.Add('AND DataDocumento = ''' + FormatDateTime('mm/dd/yyyy', DataDoc) + '''');
        Qry.ExecSQL;
        // --------------------------------------------------------------------
        // --------------------------------------------------------------------
        // Elimina i vecchi sottorighi manodopera del documento
        // --------------------------------------------------------------------
        Qry.SQL.Clear;
        Qry.SQL.Add('DELETE');
        Qry.SQL.Add('FROM RAPGIORNRIGHI');
        Qry.SQL.Add('WHERE');
        // NB: Per eliminare i vecchi righi usa le variabili globali che indentificano il documento che
        // a questo punto contengono i valori identificativi non aggiornati (nel caso si fossero cambiati uno dei
        // dati della chiave del documento) e quindi permettono di eliminare i vecchi righi correttamente.
        Qry.SQL.Add('    TIPODOC = ''' + TipoDoc + '''');
        Qry.SQL.Add('AND REGISTRO = ''' + Registro + '''');
        Qry.SQL.Add('AND NUMDOC = ' + IntToStr(NumeroDoc));
        Qry.SQL.Add('AND DATADOC = ''' + FormatDateTime('mm/dd/yyyy', DataDoc) + '''');
        Qry.ExecSQL;
        // --------------------------------------------------------------------
      end;
      // =========================================================================================================================

      // FASE DI INIZIALIZZAZIONE DEL FLAG "SAVED" A FALSE PER OGNI RIGO PRINCIPALE
      // =========================================================================================================================
      for i := 0 to DC.RecordCount - 1 do
      begin
        DC.Values[i, tvCorpoTODELETE.Index] := False;
      end;
      // =========================================================================================================================

      // Se non è abilitato l'accorpamento dei righi salva tutto in colpo
      if not AccorpaRighi then
      begin

        // SALVATAGGIO RIGHI NORMALE
        // =========================================================================================================================
        // Poi cicla per tutti i righi dell'elenco del materiale e salva rigo per rigo
        for i := 0 to DC.RecordCount - 1 do
        begin
          // Se il rigo non è già stato salvato
          if not DC.Values[i, tvCorpoTODELETE.Index] then
          begin
            // Aggiorna lo schermo
            DM1.ShowWait('', 'Salvataggio rigo ' + IntToStr(i));
            // Inizializzazione ProgRigo
            ProgRigo := DC.Values[i, tvCorpoORDER.Index];
            // Salva il rigo principale attuale (NB: I righi principali hanno sempre ProgRigo2 := -1)
            SalvaRigo(TipoDocumento, Reg, NumDoc, DocData, Soggetto, i, ProgRigo, -1, DC);
            // Inizio sezione per il salvataggio dei sottorighi
            // --------------------------------------------------------
            // Se il rigo principale è espandibile, salva anche i sottorighi altrimenti no
            if DM1.CheckIfExpandable(DC, i, True) then
            begin
              // Se il rigo principale è un rigo di manodopera provede a salvare il sottorigo
              // di manodopera nei righi dei rapporti giornalieri.
              // Se invece è un sottorigo di un articolo composto lo salva come tale
              IsManodopera := DM1.CodiceIsManodopera(DC.Values[i, tvCorpoCODICEARTICOLO.Index]);
              // Se il rigo principale è un rigo di manodopera provede a salvare il sottorigo
              // di manodopera nei righi dei rapporti giornalieri.
              if IsManodopera then
              begin
                // Ora DC Punta al DetailDataController del record corrente
                DDC := DC.GetDetailDataController(i, RELATION_IDX_SOTTORIGHI_ORE);
                // Cicla per tutti i sottorighi
                for ProgRigo2 := 0 to DDC.RecordCount - 1 do
                begin
                  // Salva il sottorigo di manodopera
                  CodPrat := QryDocumentoPRATICA.AsInteger;
                  if (not QryDocumentoDATAPRATICA1.IsNull) then
                    DataPrat := QryDocumentoDATAPRATICA1.AsString
                  else
                    DataPrat := '';
                  SalvaRigoManodopera(TipoDocumento, Reg, NumDoc, DocData, Soggetto, CodPrat, DataPrat, ProgRigo2, ProgRigo, ProgRigo2, DDC);
                end;
                // Se invece è un sottorigo di un articolo composto lo salva come tale
              end
              else
              begin
                // Ora DC Punta al DetailDataController del record corrente
                DDC := DC.GetDetailDataController(i, RELATION_IDX_SOTTORIGHI_NORMALI);
                // Cicla per tutti i sottorighi
                for ii := 0 to DDC.RecordCount - 1 do
                begin
                  // Inizializzazione ProgRigo
                  ProgRigo2 := DDC.Values[ii, tvCorpoORDER.Index];
                  // Salva il sottorigo attuale (NB: I Sottorighi hanno sempre ProgRigo = a quello del relativo rigoMaster
                  // e ProgRigo2 progressivo con base 0);
                  SalvaRigo(TipoDocumento, Reg, NumDoc, DocData, Soggetto, ii, ProgRigo, ProgRigo2, DDC);
                end;
              end;
            end;
            // --------------------------------------------------------
          end;
        end;
        // =========================================================================================================================

        // Se invece è attivo l'accorpamento dei righi...
      end
      else
      begin

        // SALVATAGGIO RIGHI CON ACCORPAMENTO
        // =========================================================================================================================
        // Prima di tutto salva tutti gli eventuali righi di riferimenti in alto all'inizio del documento
        for i := 0 to DC.RecordCount - 1 do
        begin
          // Se è un rigo di riferimento (Codice IVA = -9)
          // E se il rigo non è già stato salvato
          if (DM1.NoNullIntValue(DC, i, tvCorpoCODICEIVA.Index) = -9) and not DC.Values[i, tvCorpoTODELETE.Index] then
          begin
            // Inizializzazione ProgRigo
            // NB: Siccome volevo mettere prima i righi di riferimento ma volevo anche evitare di avere ProgRigo negativi
            // (perchè poi non possono venire riordinati come faccio quando sposto i righi con il Drag&Drop che rimetterebbe
            // tutto a posto) perchèavrebbe potuto dare problemi allora ho deciso che i righi di riferimento vengono salvati
            // salvati con il loro ProgRigo originario così rimango nella stessa posizione reciproca (tra righi di riferimento)
            // all'inizio del documento mentre poi i righi successivi (righi normali) vengono salvati anch'essi con il loro
            // ProgRigo originario ma aggiungendogli un numero alto (sicuramente superiore al numero dei righi di riferimento)
            // in questo modo rimangono nella loro posizione reciproca pur potendo fare l'accorpamento.
            // L'UNICO LATO NEGATIVO DI QUESTO METODO E' CHE I NUMERI DEI RIGHI SUL DB NON SARANNO TUTTI CONSEQUENZIALI MA
            // CI SARANNO DEI BUCHI.
            ProgRigo := DC.Values[i, tvCorpoORDER.Index];
            // I righi di riferimento sono sempre principali
            ProgRigo2 := -1;
            // Salva il rigo attuale
            SalvaRigo(TipoDocumento, Reg, NumDoc, DocData, Soggetto, i, ProgRigo, ProgRigo2, DC);
          end;
        end;

        // Ora Cicla di nuovo per tutti i righi per salvare
        for i := 0 to DC.RecordCount - 1 do
        begin
          // Controlla che il rigo corrente non sia già marcato per l'eliminazione
          // e che non sia un rigo di riferimento
          if (not DC.Values[i, tvCorpoTODELETE.Index]) and (DM1.NoNullIntValue(DC, i, tvCorpoCODICEIVA.Index) <> -9) then
          begin
            // Inizializzazione ProgRigo
            // NB: Siccome volevo mettere prima i righi di riferimento ma volevo anche evitare di avere ProgRigo negativi
            // (perchè poi non possono venire riordinati come faccio quando sposto i righi con il Drag&Drop che rimetterebbe
            // tutto a posto) perchèavrebbe potuto dare problemi allora ho deciso che i righi di riferimento vengono salvati
            // salvati con il loro ProgRigo originario così rimango nella stessa posizione reciproca (tra righi di riferimento)
            // all'inizio del documento mentre poi i righi successivi (righi normali) vengono salvati anch'essi con il loro
            // ProgRigo originario ma aggiungendogli un numero alto (sicuramente superiore al numero dei righi di riferimento)
            // in questo modo rimangono nella loro posizione reciproca pur potendo fare l'accorpamento.
            // L'UNICO LATO NEGATIVO DI QUESTO METODO E' CHE I NUMERI DEI RIGHI SUL DB NON SARANNO TUTTI CONSEQUENZIALI MA
            // CI SARANNO DEI BUCHI.
            ProgRigo := DC.Values[i, tvCorpoORDER.Index] + 1000;
            // Se il rigo attuale NON contiene un articolo composto...
            if not(DM1.CheckIfExpandable(DC, i, True)) then
            begin
              // Richiama la procedura che salva il rigo corrente insieme a tutti gli altri righi che hanno lo stesso
              // codice articolo, PrezzoUnitario, Sconti 1,2 e 3 e COdice IVA accorpandoli in un unico rigo.
              SalvaRighiAccorpatiInUnUnicoRigo(TipoDocumento, Reg, NumDoc, DocData, Soggetto, i, ProgRigo);
              // Se invece il rigo attuale contiene un articolo composto...
            end
            else
            begin
              // Salva il rigo principale attuale (NB: I righi principali hanno sempre ProgRigo2 := -1)
              SalvaRigo(TipoDocumento, Reg, NumDoc, DocData, Soggetto, i, ProgRigo, -1, DC);
              // Inizio sezione per il salvataggio dei sottorighi
              // --------------------------------------------------------
              // Se il rigo principale è un rigo di manodopera provede a salvare il sottorigo
              // di manodopera nei righi dei rapporti giornalieri.
              // Se invece è un sottorigo di un articolo composto lo salva come tale
              IsManodopera := DM1.CodiceIsManodopera(DC.Values[i, tvCorpoCODICEARTICOLO.Index]);
              // Se il rigo principale è un rigo di manodopera provede a salvare il sottorigo
              // di manodopera nei righi dei rapporti giornalieri.
              if IsManodopera then
              begin
                // Ora DC Punta al DetailDataController del record corrente
                DDC := DC.GetDetailDataController(i, RELATION_IDX_SOTTORIGHI_ORE);
                // Cicla per tutti i sottorighi
                for ProgRigo2 := 0 to DDC.RecordCount - 1 do
                begin
                  // Salva il sottorigo di manodopera
                  CodPrat := QryDocumentoPRATICA.AsInteger;
                  if (not QryDocumentoDATAPRATICA1.IsNull) then
                    DataPrat := QryDocumentoDATAPRATICA1.AsString
                  else
                    DataPrat := '';
                  SalvaRigoManodopera(TipoDocumento, Reg, NumDoc, DocData, Soggetto, CodPrat, DataPrat, ProgRigo2, ProgRigo, ProgRigo2, DDC);
                end;
                // Se invece è un sottorigo di un articolo composto lo salva come tale
              end
              else
              begin
                // Ora DC Punta al DetailDataController del record corrente
                DDC := DC.GetDetailDataController(i, RELATION_IDX_SOTTORIGHI_NORMALI);
                // Cicla per tutti i sottorighi
                for ii := 0 to DDC.RecordCount - 1 do
                begin
                  // Inizializzazione ProgRigo
                  ProgRigo2 := DDC.Values[ii, tvCorpoORDER.Index];
                  // Salva il sottorigo attuale (NB: I Sottorighi hanno sempre ProgRigo = a quello del relativo rigoMaster
                  // e ProgRigo2 progressivo con base 0);
                  SalvaRigo(TipoDocumento, Reg, NumDoc, DocData, Soggetto, ii, ProgRigo, ProgRigo2, DDC);
                end;
              end;
              // --------------------------------------------------------
            end;
          end;
        end;
        // =========================================================================================================================

        // Elimina tutti i righi che dopo l'accorpamento sono marcati per l'eliminazione
        for i := (DC.RecordCount - 1) downto 0 do
        begin
          if DC.Values[i, tvCorpoTODELETE.Index] then
            DC.DeleteRecord(i);
        end;
      end;
      // Se arriva qui tutto è andato bene e conferma la transazione
      // NB: Provo a toglierlo perchè ho messo la transazione alla conferma del documento
      // DM1.DBAzienda.Commit;
    except
      // Se invece c'è stato un errore annulla tutto
      // NB: Provo a toglierlo perchè ho messo la transazione alla conferma del documento
      // DM1.DBAzienda.Rollback;
      // Re-raise dell'eccezione.
      raise;
    end;
  finally
    // Distrugge l'oggetto Qry
    Qry.Free;
    // Riabilita l'aggiornamento dello schermo
    DC.EndFullUpdate;
  end;
end;

// Procedura che carica tutti i sottorighi relativi ad un rigo principale di manodopera
procedure TPreventiviOrdiniForm.CaricaSottorighiManodopera(DocTipo, Registro: String; DocNum: Integer; DocData: TDate; ProgRigo, MasterRowIndex: Integer;
  MDC: TcxCustomDataController);
var
  Qry: TIB_Cursor;
  DC: TcxCustomDataController;
  DetRowIndex: Integer;
begin
  // Crea l'oggetto query e lo imposta per trovare tutti i righi del documento
  Qry := TIB_Cursor.Create(Self);
  try
    // Imposta ed apre la query che preleverà tutti i sottorighi
    Qry.DatabaseName := DM1.ArcDBFile;
    Qry.IB_Connection := DM1.DBAzienda;
    Qry.SQL.Add('SELECT * FROM RAPGIORNRIGHI WHERE');
    Qry.SQL.Add('  TIPODOC = ''' + DocTipo + '''');
    Qry.SQL.Add('  AND NUMDOC = ' + IntToStr(DocNum));
    Qry.SQL.Add('  AND DATADOC = ''' + FormatDateTime('mm/dd/yyyy', DocData) + '''');
    Qry.SQL.Add('  AND REGISTRO = ''' + Registro + '''');
    Qry.SQL.Add('  AND NUMRIGO = ' + IntToStr(ProgRigo));
    Qry.SQL.Add('ORDER BY NUMRIGO2');
    Qry.Open;
    // Ricava il DataController dettaglio
    DC := MDC.GetDetailDataController(MasterRowIndex, RELATION_IDX_SOTTORIGHI_ORE);
    // Cicla per tutti i records trovati e li carica
    while not Qry.Eof do
    begin
      DetRowIndex := DC.AppendRecord;
      if not Qry.FieldByName('CODDIPENDENTE').IsNull then
        DC.Values[DetRowIndex, tvOreCODDIPENDENTE.Index] := Qry.FieldByName('CODDIPENDENTE').AsInteger;
      if not Qry.FieldByName('DESCRIZDIPENDENTE').IsNull then
        DC.Values[DetRowIndex, tvOreDESCRIZDIPENDENTE.Index] := Qry.FieldByName('DESCRIZDIPENDENTE').AsString;
      if not Qry.FieldByName('COSTOORARIO').IsNull then
        DC.Values[DetRowIndex, tvOreCOSTOORARIO.Index] := Qry.FieldByName('COSTOORARIO').AsFloat;
      if not Qry.FieldByName('QTA').IsNull then
        DC.Values[DetRowIndex, tvOreQTA.Index] := Qry.FieldByName('QTA').AsFloat;
      if not Qry.FieldByName('IMPORTOCOSTOORARIO').IsNull then
        DC.Values[DetRowIndex, tvOreIMPORTOCOSTOORARIO.Index] := Qry.FieldByName('IMPORTOCOSTOORARIO').AsFloat;
      if not Qry.FieldByName('NOTE').IsNull then
        DC.Values[DetRowIndex, tvOreNOTE.Index] := Qry.FieldByName('NOTE').AsString;

      if not Qry.FieldByName('TIPOORE1').IsNull then
        DC.Values[DetRowIndex, tvOreTIPOORE1.Index] := Qry.FieldByName('TIPOORE1').AsString;
      if not Qry.FieldByName('TIPOORE2').IsNull then
        DC.Values[DetRowIndex, tvOreTIPOORE2.Index] := Qry.FieldByName('TIPOORE2').AsString;
      if not Qry.FieldByName('TIPOORE3').IsNull then
        DC.Values[DetRowIndex, tvOreTIPOORE3.Index] := Qry.FieldByName('TIPOORE3').AsString;

      if not Qry.FieldByName('TIPO1').IsNull then
        DC.Values[DetRowIndex, tvOreTIPO1.Index] := Qry.FieldByName('TIPO1').AsString;
      if not Qry.FieldByName('TIPO2').IsNull then
        DC.Values[DetRowIndex, tvOreTIPO2.Index] := Qry.FieldByName('TIPO2').AsString;
      if not Qry.FieldByName('TIPO3').IsNull then
        DC.Values[DetRowIndex, tvOreTIPO3.Index] := Qry.FieldByName('TIPO3').AsString;
      if not Qry.FieldByName('TIPO4').IsNull then
        DC.Values[DetRowIndex, tvOreTIPO4.Index] := Qry.FieldByName('TIPO4').AsString;
      if not Qry.FieldByName('TIPO5').IsNull then
        DC.Values[DetRowIndex, tvOreTIPO5.Index] := Qry.FieldByName('TIPO5').AsString;
      if not Qry.FieldByName('TIPO6').IsNull then
        DC.Values[DetRowIndex, tvOreTIPO6.Index] := Qry.FieldByName('TIPO6').AsString;

      if not Qry.FieldByName('OPERAINDEX').IsNull then
        DC.Values[DetRowIndex, tvOreOPERAINDEX.Index] := Qry.FieldByName('OPERAINDEX').AsInteger;
      if not Qry.FieldByName('PRZVEND').IsNull then
        DC.Values[DetRowIndex, tvOrePRZUNITVEND.Index] := Qry.FieldByName('PRZVEND').AsFloat;
      if not Qry.FieldByName('IMPORTOVEND').IsNull then
        DC.Values[DetRowIndex, tvOreIMPORTOVEND.Index] := Qry.FieldByName('IMPORTOVEND').AsFloat;

      if not Qry.FieldByName('SOTTOCANTIERE1').IsNull then
        DC.Values[DetRowIndex, tvOreSOTTOCANTIERE1.Index] := Qry.FieldByName('SOTTOCANTIERE1').Value;
      if not Qry.FieldByName('SOTTOCANTIERE2').IsNull then
        DC.Values[DetRowIndex, tvOreSOTTOCANTIERE2.Index] := Qry.FieldByName('SOTTOCANTIERE2').Value;
      if not Qry.FieldByName('SOTTOCANTIERE3').IsNull then
        DC.Values[DetRowIndex, tvOreSOTTOCANTIERE3.Index] := Qry.FieldByName('SOTTOCANTIERE3').Value;

      if not Qry.FieldByName('GC_COSTONETTOUNITARIO_MOD').IsNull then
        DC.Values[DetRowIndex, tvOreGC_COSTONETTOUNITARIO_MOD.Index] := Qry.FieldByName('GC_COSTONETTOUNITARIO_MOD').AsString;
      if not Qry.FieldByName('GC_COSTONETTOUNITARIO').IsNull then
        DC.Values[DetRowIndex, tvOreGC_COSTONETTOUNITARIO.Index] := Qry.FieldByName('GC_COSTONETTOUNITARIO').AsFloat;
      if not Qry.FieldByName('GC_RICARICO_MOD').IsNull then
        DC.Values[DetRowIndex, tvOreGC_RICARICO_MOD.Index] := Qry.FieldByName('GC_RICARICO_MOD').AsString;
      if not Qry.FieldByName('GC_RICARICO').IsNull then
        DC.Values[DetRowIndex, tvOreGC_RICARICO.Index] := Qry.FieldByName('GC_RICARICO').AsFloat;
      if not Qry.FieldByName('GC_QTA_MOD').IsNull then
        DC.Values[DetRowIndex, tvOreGC_QTA_MOD.Index] := Qry.FieldByName('GC_QTA_MOD').AsString;
      if not Qry.FieldByName('GC_QTA').IsNull then
        DC.Values[DetRowIndex, tvOreGC_QTA.Index] := Qry.FieldByName('GC_QTA').AsFloat;
      if not Qry.FieldByName('GC_DESCRIZIONE_MOD').IsNull then
        DC.Values[DetRowIndex, tvOreGC_DESCRIZIONE_MOD.Index] := Qry.FieldByName('GC_DESCRIZIONE_MOD').AsString;
      if not Qry.FieldByName('GC_DESCRIZIONE').IsNull then
        DC.Values[DetRowIndex, tvOreGC_DESCRIZIONE.Index] := Qry.FieldByName('GC_DESCRIZIONE').AsString;
      if not Qry.FieldByName('GUID').IsNull then
        DC.Values[DetRowIndex, tvOreGUID.Index] := Qry.FieldByName('GUID').AsString;
      if not Qry.FieldByName('GUID_REF').IsNull then
        DC.Values[DetRowIndex, tvOreGUID_REF.Index] := Qry.FieldByName('GUID_REF').AsString;
      if not Qry.FieldByName('GUID_ANCESTOR').IsNull then
        DC.Values[DetRowIndex, tvOreGUID_ANCESTOR.Index] := Qry.FieldByName('GUID_ANCESTOR').AsString;

      Qry.Next;
    end;
  finally
    if Qry.Active then
      Qry.Close;
    Qry.Free;
  end;
end;

procedure TPreventiviOrdiniForm.CaricaRighiDocumento(DocTipo, Registro: String; DocNum: Longint; DocData: TDate);
var
  Qry: TIB_Cursor;
  Y, yy: Integer;
  MDC, DC: TcxCustomDataController;
begin
  // Inizializzazione DC (punta al datacontroller della TableView principale
  MDC := tvCorpo.DataController;
  // Crea l'oggetto query e lo imposta per trovare tutti i righi del documento
  Qry := TIB_Cursor.Create(Self);
  Qry.DatabaseName := DM1.ArcDBFile;
  Qry.IB_Connection := DM1.DBAzienda;
  // Svuota la TableView
  MDC.RecordCount := 0;
  // Inizia l'aggiornamento della griglia
  MDC.BeginFullUpdate;
  // Avvia il sistema che determina se deve essere attivata la visualizzazione raggruppata
  // per sezione oppure no.
  TSectionGrouped.StartCheck;
  try
    DM1.ShowWait('Documento', 'Carica rigo ');
    // Imposta la query che richiama i righi del documento ordinandoli per PROGRIGO in modo da scongiurare
    // pericoli di rimescolamento dei righi
    Qry.SQL.Add('SELECT *');
    Qry.SQL.Add('FROM ' + RighiTable);
    Qry.SQL.Add('WHERE');
    Qry.SQL.Add('    TipoDocumento = ''' + DocTipo + '''');
    Qry.SQL.Add('AND Registro = ''' + Registro + '''');
    Qry.SQL.Add('AND NumOrdPrev = ' + IntToStr(DocNum));
    Qry.SQL.Add('AND DataDocumento = ''' + FormatDateTime('mm/dd/yyyy', DocData) + '''');
    Qry.SQL.Add('ORDER BY PROGRIGO, PROGRIGO2');
    Qry.Open;
    // Cicla per tutti i records trovati dalla query
    while not Qry.Eof do
    begin
      // Effettua l'append del rigo da importare
      Y := MDC.AppendRecord;
      // Aggiorna lo schermo
      DM1.ShowWait('', 'Carica rigo ' + IntToStr(Y));
      // Carica il campo che determinerà l'ordine di visualizzazione delle righe
      MDC.Values[Y, tvCorpoORDER.Index] := (Y + 1);
      // Carica il rigo
      MDC.Values[Y, tvCorpoCODICEMAGAZZINO.Index] := Qry.FieldByName('CodiceMagazzino').Value;
      MDC.Values[Y, tvCorpoCODICEMAGAZZINO2.Index] := Qry.FieldByName('CodiceMagazzino2').Value;
      MDC.Values[Y, tvCorpoMOVMAG.Index] := Qry.FieldByName('MovMag').Value;
      MDC.Values[Y, tvCorpoCODICEARTICOLO.Index] := Qry.FieldByName('CodiceArticolo').Value;
      MDC.Values[Y, tvCorpoCODICEARTICOLOSTM.Index] := Qry.FieldByName('CodiceArticoloStm').Value;
      MDC.Values[Y, tvCorpoDESCRIZIONE.Index] := Qry.FieldByName('Descrizione').Value;
      MDC.Values[Y, tvCorpoPREZZOUNITARIO.Index] := Qry.FieldByName('PrezzoUnitario').Value;
      MDC.Values[Y, tvCorpoPREZZOUNITARIOIVACOMPRESA.Index] := Qry.FieldByName('PrezzoUnitarioIVACompresa').Value;
      MDC.Values[Y, tvCorpoUNITADIMISURA.Index] := Qry.FieldByName('UnitaDiMisura').Value;
      MDC.Values[Y, tvCorpoQTA.Index] := Qry.FieldByName('QTA').Value;
      MDC.Values[Y, tvCorpoQTAEVASA.Index] := Qry.FieldByName('QTAEVASA').Value;
      MDC.Values[Y, tvCorpoSCONTORIGO.Index] := Qry.FieldByName('ScontoRigo').Value;
      MDC.Values[Y, tvCorpoSCONTORIGO2.Index] := Qry.FieldByName('ScontoRigo2').Value;
      MDC.Values[Y, tvCorpoSCONTORIGO3.Index] := Qry.FieldByName('ScontoRigo3').Value;
      MDC.Values[Y, tvCorpoIMPORTORIGO.Index] := Qry.FieldByName('ImportoRigo').Value;
      MDC.Values[Y, tvCorpoIMPORTORIGOIVACOMPRESA.Index] := Qry.FieldByName('ImportoRigoIVACompresa').Value;
      MDC.Values[Y, tvCorpoCODICEIVA.Index] := Qry.FieldByName('CodiceIVA').Value;
      MDC.Values[Y, tvCorpoDESCRIZIONEIVA.Index] := Qry.FieldByName('DescrizioneIVA').Value;
      MDC.Values[Y, tvCorpoALIQUOTAIVA.Index] := Qry.FieldByName('AliquotaIVA').Value;
      MDC.Values[Y, tvCorpoNOTERIGO.Index] := Qry.FieldByName('NoteRigo').Value;
      MDC.Values[Y, tvCorpoMARGINE.Index] := Qry.FieldByName('Margine').Value;
      MDC.Values[Y, tvCorpoIMPORTOMARGINE.Index] := Qry.FieldByName('ImportoMargine').Value;
      MDC.Values[Y, tvCorpoPREZZOACQUISTOARTICOLO.Index] := Qry.FieldByName('PrezzoAcquistoArticolo').Value;
      MDC.Values[Y, tvCorpoIMPORTOCOSTO.Index] := Qry.FieldByName('IMPORTOCOSTO').Value;

      MDC.Values[Y, tvCorpoQTAOPERAUNIT.Index] := Qry.FieldByName('QtaOperaUnit').Value;
      MDC.Values[Y, tvCorpoOPERAUNIT.Index] := Qry.FieldByName('OperaUnit').Value;
      MDC.Values[Y, tvCorpoCOMPONENTIUNIT.Index] := Qry.FieldByName('ComponentiUnit').Value;
      MDC.Values[Y, tvCorpoCOSTOOPERAUNIT.Index] := Qry.FieldByName('CostoOperaUnit').Value;
      MDC.Values[Y, tvCorpoCOSTOCOMPONENTIUNIT.Index] := Qry.FieldByName('CostoComponentiUnit').Value;

      MDC.Values[Y, tvCorpoQTAOPERA.Index] := Qry.FieldByName('QtaOpera').Value;
      MDC.Values[Y, tvCorpoIMPORTOOPERA.Index] := Qry.FieldByName('ImportoOpera').Value;
      MDC.Values[Y, tvCorpoIMPORTOCOMPONENTI.Index] := Qry.FieldByName('ImportoComponenti').Value;
      MDC.Values[Y, tvCorpoIMPORTOCOSTOOPERA.Index] := Qry.FieldByName('ImportoCostoOpera').Value;
      MDC.Values[Y, tvCorpoIMPORTOCOSTOCOMPONENTI.Index] := Qry.FieldByName('ImportoCostoComponenti').Value;
      MDC.Values[Y, tvCorpoIMPORTOMARGINECOMPONENTI.Index] := Qry.FieldByName('ImportoMargineComponenti').Value;
      MDC.Values[Y, tvCorpoIMPORTOMARGINEOPERA.Index] := Qry.FieldByName('ImportoMargineOpera').Value;
      MDC.Values[Y, tvCorpoPERCMARGINECOMPONENTI.Index] := Qry.FieldByName('MargineComponenti').Value;
      MDC.Values[Y, tvCorpoPERCMARGINEOPERA.Index] := Qry.FieldByName('MargineOpera').Value;

      MDC.Values[Y, tvCorpoSELEZIONATO.Index] := Qry.FieldByName('SELEZIONATO').Value;
      MDC.Values[Y, tvCorpoMINUTIPREVISTI.Index] := Qry.FieldByName('MINUTIPREVISTI').Value;

      // Prima il caricamento dei TipiRighi era qui
      MDC.Values[Y, tvCorpoGC_COSTONETTOUNITARIO_MOD.Index] := Qry.FieldByName('GC_COSTONETTOUNITARIO_MOD').Value;
      MDC.Values[Y, tvCorpoGC_COSTONETTOUNITARIO.Index] := Qry.FieldByName('GC_COSTONETTOUNITARIO').Value;
      MDC.Values[Y, tvCorpoGC_RICARICO_MOD.Index] := Qry.FieldByName('GC_RICARICO_MOD').Value;
      MDC.Values[Y, tvCorpoGC_RICARICO.Index] := Qry.FieldByName('GC_RICARICO').Value;
      MDC.Values[Y, tvCorpoGC_QTA_MOD.Index] := Qry.FieldByName('GC_QTA_MOD').Value;
      MDC.Values[Y, tvCorpoGC_QTA.Index] := Qry.FieldByName('GC_QTA').Value;
      MDC.Values[Y, tvCorpoGC_DESCRIZIONE_MOD.Index] := Qry.FieldByName('GC_DESCRIZIONE_MOD').Value;
      MDC.Values[Y, tvCorpoGC_DESCRIZIONE.Index] := Qry.FieldByName('GC_DESCRIZIONE').Value;
      MDC.Values[Y, tvCorpoGUID.Index] := Qry.FieldByName('GUID').Value;
      MDC.Values[Y, tvCorpoGUID_REF.Index] := Qry.FieldByName('GUID_REF').Value;
      MDC.Values[Y, tvCorpoGUID_ANCESTOR.Index] := Qry.FieldByName('GUID_ANCESTOR').Value;
      MDC.Values[Y, tvCorpoIDAPPARECCHIO.Index] := Qry.FieldByName('IDAPPARECCHIOPRAT').Value;
      MDC.Values[Y, tvCorpoIDOPIMPEGNO.Index] := Qry.FieldByName('IDOPIMPEGNO').Value;
      // Se il rigo attuale è un rigo di manodopera provvede al caricamento degli eventuali
      // sottorighi di manodopera
      // NB: Però solo se non è una distinta base (in cui non ci possono essere sottorighi)
      if DM1.CodiceIsManodopera(Qry.FieldByName('CODICEARTICOLO').AsString) and not DistintaBase then
        CaricaSottorighiManodopera(DocTipo, Registro, DocNum, DocData, Qry.FieldByName('PROGRIGO').AsInteger, Y, MDC);
      // Sottocantieri
      MDC.Values[Y, tvCorpoSOTTOCANTIERE1.Index] := Qry.FieldByName('SOTTOCANTIERE1').Value;
      MDC.Values[Y, tvCorpoSOTTOCANTIERE2.Index] := Qry.FieldByName('SOTTOCANTIERE2').Value;
      MDC.Values[Y, tvCorpoSOTTOCANTIERE3.Index] := Qry.FieldByName('SOTTOCANTIERE3').Value;
      MDC.Values[Y, tvCorpoSOTTOCANTIERE4.Index] := Qry.FieldByName('SOTTOCANTIERE4').Value;
      MDC.Values[Y, tvCorpoSOTTOCANTIERE5.Index] := Qry.FieldByName('SOTTOCANTIERE5').Value;
      MDC.Values[Y, tvCorpoSOTTOCANTIERE6.Index] := Qry.FieldByName('SOTTOCANTIERE6').Value;
      // TipiRighi
      MDC.Values[Y, tvCorpoTIPO1.Index] := Qry.FieldByName('TIPO1').Value;
      MDC.Values[Y, tvCorpoTIPO2.Index] := Qry.FieldByName('TIPO2').Value;
      MDC.Values[Y, tvCorpoTIPO3.Index] := Qry.FieldByName('TIPO3').Value;
      MDC.Values[Y, tvCorpoTIPO4.Index] := Qry.FieldByName('TIPO4').Value;
      MDC.Values[Y, tvCorpoTIPO5.Index] := Qry.FieldByName('TIPO5').Value;
      MDC.Values[Y, tvCorpoTIPO6.Index] := Qry.FieldByName('TIPO6').Value;
      // Righi aggiunti alla ristrutturazione dei righi composti e altro
      MDC.Values[Y, tvCorpoPREZZOUNITARIOAUTOCALC.Index] := Qry.FieldByName('PrezzoUnitarioAutocalc').Value;
      MDC.Values[Y, tvCorpoROWTYPE.Index] := Qry.FieldByName('RowType').Value;
      MDC.Values[Y, tvCorpoROWPRINTPRICES.Index] := Qry.FieldByName('RowPrintPrices').Value;
      MDC.Values[Y, tvCorpoROWSECTION.Index] := Qry.FieldByName('RowSection').AsString;
      // AltriDatiGestionali
      MDC.Values[Y, tvCorpoADG1_TIPODATO.Index] := Qry.FieldByName('ADG1_TIPODATO').Value;
      MDC.Values[Y, tvCorpoADG1_RIFERIMENTOTESTO.Index] := Qry.FieldByName('ADG1_RIFERIMENTOTESTO').Value;
      MDC.Values[Y, tvCorpoADG1_RIFERIMENTONUMERO.Index] := Qry.FieldByName('ADG1_RIFERIMENTONUMERO').Value;
      MDC.Values[Y, tvCorpoADG1_RIFERIMENTODATA.Index] := Qry.FieldByName('ADG1_RIFERIMENTODATA').Value;

      // Check del sistema che determina se deve essere attivata la visualizzazione raggruppata
      // per sezione oppure no.
      TSectionGrouped.CheckRow(MDC, Y);

      // Và al prossimo record
      Qry.Next;
      // Se esistono sottorighi li carica
      if (Qry.FieldByName('PROGRIGO2').AsInteger <> -1) and (not Qry.Eof) then
      begin
        // Inizio caricamento sottorighi
        // ------------------------------------------------------------------------------------------------
        // DC Punta al DetailDataController relativo e azzera il contenuto
        DC := MDC.GetDetailDataController(Y, RELATION_IDX_SOTTORIGHI_NORMALI);
        DC.BeginFullUpdate;
        // Cicla per tutti i righi che continuano ad avere lo stessop valore nel campo ProgRigo
        // (In questo modo cicla per tutti i sottorighi del rigo stesso)
        // Praticamente il rigo principale ha il campo ProgRigo2 = 0 e i suoi sottorighi
        // hanno valore > 1 ma ProgRigo = al Progrigo del rigo principale.
        while (Qry.FieldByName('PROGRIGO2').AsInteger <> -1) and (not Qry.Eof) do
        begin
          // Effettua l'append del rigo da importare
          yy := DC.AppendRecord;
          // Carica il campo che determinerà l'ordine di visualizzazione delle righe
          DC.Values[yy, tvCorpoORDER.Index] := (yy + 1);
          // Carica il rigo
          DC.Values[yy, tvCorpoCODICEMAGAZZINO.Index] := Qry.FieldByName('CodiceMagazzino').Value;
          DC.Values[yy, tvCorpoCODICEMAGAZZINO2.Index] := Qry.FieldByName('CodiceMagazzino2').Value;
          DC.Values[yy, tvCorpoMOVMAG.Index] := Qry.FieldByName('MovMag').Value;
          DC.Values[yy, tvCorpoCODICEARTICOLO.Index] := Qry.FieldByName('CodiceArticolo').Value;
          DC.Values[yy, tvCorpoCODICEARTICOLOSTM.Index] := Qry.FieldByName('CodiceArticoloStm').Value;
          DC.Values[yy, tvCorpoDESCRIZIONE.Index] := Qry.FieldByName('Descrizione').Value;
          DC.Values[yy, tvCorpoPREZZOUNITARIO.Index] := Qry.FieldByName('PrezzoUnitario').Value;
          DC.Values[yy, tvCorpoPREZZOUNITARIOIVACOMPRESA.Index] := Qry.FieldByName('PrezzoUnitarioIVACompresa').Value;
          DC.Values[yy, tvCorpoUNITADIMISURA.Index] := Qry.FieldByName('UnitaDiMisura').Value;
          DC.Values[yy, tvCorpoQTA.Index] := Qry.FieldByName('QTA').Value;
          DC.Values[yy, tvCorpoQTAEVASA.Index] := Qry.FieldByName('QTAEVASA').Value;
          DC.Values[yy, tvCorpoSCONTORIGO.Index] := Qry.FieldByName('ScontoRigo').Value;
          DC.Values[yy, tvCorpoSCONTORIGO2.Index] := Qry.FieldByName('ScontoRigo2').Value;
          DC.Values[yy, tvCorpoSCONTORIGO3.Index] := Qry.FieldByName('ScontoRigo3').Value;
          DC.Values[yy, tvCorpoIMPORTORIGO.Index] := Qry.FieldByName('ImportoRigo').Value;
          DC.Values[yy, tvCorpoIMPORTORIGOIVACOMPRESA.Index] := Qry.FieldByName('ImportoRigoIVACompresa').Value;
          DC.Values[yy, tvCorpoCODICEIVA.Index] := Qry.FieldByName('CodiceIVA').Value;
          DC.Values[yy, tvCorpoDESCRIZIONEIVA.Index] := Qry.FieldByName('DescrizioneIVA').Value;
          DC.Values[yy, tvCorpoALIQUOTAIVA.Index] := Qry.FieldByName('AliquotaIVA').Value;
          DC.Values[yy, tvCorpoNOTERIGO.Index] := Qry.FieldByName('NoteRigo').Value;
          DC.Values[yy, tvCorpoMARGINE.Index] := Qry.FieldByName('Margine').Value;
          DC.Values[yy, tvCorpoIMPORTOMARGINE.Index] := Qry.FieldByName('ImportoMargine').Value;
          DC.Values[yy, tvCorpoPREZZOACQUISTOARTICOLO.Index] := Qry.FieldByName('PrezzoAcquistoArticolo').Value;
          DC.Values[yy, tvCorpoIMPORTOCOSTO.Index] := Qry.FieldByName('IMPORTOCOSTO').Value;

          DC.Values[yy, tvCorpoQTAOPERAUNIT.Index] := Qry.FieldByName('QtaOperaUnit').Value;
          DC.Values[yy, tvCorpoOPERAUNIT.Index] := Qry.FieldByName('OperaUnit').Value;
          DC.Values[yy, tvCorpoCOMPONENTIUNIT.Index] := Qry.FieldByName('ComponentiUnit').Value;
          DC.Values[yy, tvCorpoCOSTOOPERAUNIT.Index] := Qry.FieldByName('CostoOperaUnit').Value;
          DC.Values[yy, tvCorpoCOSTOCOMPONENTIUNIT.Index] := Qry.FieldByName('CostoComponentiUnit').Value;

          DC.Values[yy, tvCorpoQTAOPERA.Index] := Qry.FieldByName('QtaOpera').Value;
          DC.Values[yy, tvCorpoIMPORTOOPERA.Index] := Qry.FieldByName('ImportoOpera').Value;
          DC.Values[yy, tvCorpoIMPORTOCOMPONENTI.Index] := Qry.FieldByName('ImportoComponenti').Value;
          DC.Values[yy, tvCorpoIMPORTOCOSTOOPERA.Index] := Qry.FieldByName('ImportoCostoOpera').Value;
          DC.Values[yy, tvCorpoIMPORTOCOSTOCOMPONENTI.Index] := Qry.FieldByName('ImportoCostoComponenti').Value;
          DC.Values[yy, tvCorpoIMPORTOMARGINECOMPONENTI.Index] := Qry.FieldByName('ImportoMargineComponenti').Value;
          DC.Values[yy, tvCorpoIMPORTOMARGINEOPERA.Index] := Qry.FieldByName('ImportoMargineOpera').Value;
          DC.Values[yy, tvCorpoPERCMARGINECOMPONENTI.Index] := Qry.FieldByName('MargineComponenti').Value;
          DC.Values[yy, tvCorpoPERCMARGINEOPERA.Index] := Qry.FieldByName('MargineOpera').Value;

          DC.Values[yy, tvCorpoSELEZIONATO.Index] := Qry.FieldByName('SELEZIONATO').Value;
          DC.Values[yy, tvCorpoMINUTIPREVISTI.Index] := Qry.FieldByName('MINUTIPREVISTI').Value;

          DC.Values[yy, tvCorpoSOTTOCANTIERE1.Index] := Qry.FieldByName('SOTTOCANTIERE1').Value;
          DC.Values[yy, tvCorpoSOTTOCANTIERE2.Index] := Qry.FieldByName('SOTTOCANTIERE2').Value;
          DC.Values[yy, tvCorpoSOTTOCANTIERE3.Index] := Qry.FieldByName('SOTTOCANTIERE3').Value;
          DC.Values[yy, tvCorpoSOTTOCANTIERE4.Index] := Qry.FieldByName('SOTTOCANTIERE4').Value;
          DC.Values[yy, tvCorpoSOTTOCANTIERE5.Index] := Qry.FieldByName('SOTTOCANTIERE5').Value;
          DC.Values[yy, tvCorpoSOTTOCANTIERE6.Index] := Qry.FieldByName('SOTTOCANTIERE6').Value;

          DC.Values[yy, tvCorpoTIPO1.Index] := Qry.FieldByName('TIPO1').Value;
          DC.Values[yy, tvCorpoTIPO2.Index] := Qry.FieldByName('TIPO2').Value;
          DC.Values[yy, tvCorpoTIPO3.Index] := Qry.FieldByName('TIPO3').Value;
          DC.Values[yy, tvCorpoTIPO4.Index] := Qry.FieldByName('TIPO4').Value;
          DC.Values[yy, tvCorpoTIPO5.Index] := Qry.FieldByName('TIPO5').Value;
          DC.Values[yy, tvCorpoTIPO6.Index] := Qry.FieldByName('TIPO6').Value;

          // Righi aggiunti alla ristrutturazione dei righi composti e altro
          DC.Values[yy, tvCorpoPREZZOUNITARIOAUTOCALC.Index] := Qry.FieldByName('PrezzoUnitarioAutocalc').Value;
          DC.Values[yy, tvCorpoROWTYPE.Index] := Qry.FieldByName('RowType').Value;
          DC.Values[yy, tvCorpoROWPRINTPRICES.Index] := Qry.FieldByName('RowPrintPrices').Value;
          DC.Values[yy, tvCorpoROWSECTION.Index] := Qry.FieldByName('RowSection').Value;

          DC.Values[yy, tvCorpoGC_COSTONETTOUNITARIO_MOD.Index] := Qry.FieldByName('GC_COSTONETTOUNITARIO_MOD').Value;
          DC.Values[yy, tvCorpoGC_COSTONETTOUNITARIO.Index] := Qry.FieldByName('GC_COSTONETTOUNITARIO').Value;
          DC.Values[yy, tvCorpoGC_RICARICO_MOD.Index] := Qry.FieldByName('GC_RICARICO_MOD').Value;
          DC.Values[yy, tvCorpoGC_RICARICO.Index] := Qry.FieldByName('GC_RICARICO').Value;
          DC.Values[yy, tvCorpoGC_QTA_MOD.Index] := Qry.FieldByName('GC_QTA_MOD').Value;
          DC.Values[yy, tvCorpoGC_QTA.Index] := Qry.FieldByName('GC_QTA').Value;
          DC.Values[yy, tvCorpoGC_DESCRIZIONE_MOD.Index] := Qry.FieldByName('GC_DESCRIZIONE_MOD').Value;
          DC.Values[yy, tvCorpoGC_DESCRIZIONE.Index] := Qry.FieldByName('GC_DESCRIZIONE').Value;
          DC.Values[yy, tvCorpoGUID.Index] := Qry.FieldByName('GUID').Value;
          DC.Values[yy, tvCorpoGUID_REF.Index] := Qry.FieldByName('GUID_REF').Value;
          DC.Values[yy, tvCorpoGUID_ANCESTOR.Index] := Qry.FieldByName('GUID_ANCESTOR').Value;
          DC.Values[yy, tvCorpoIDAPPARECCHIO.Index] := Qry.FieldByName('IDAPPARECCHIOPRAT').Value;
          DC.Values[yy, tvCorpoIDOPIMPEGNO.Index] := Qry.FieldByName('IDOPIMPEGNO').Value;

          // Và al prossimo record
          Qry.Next;
        end;
        // Se si è appena terminato di inserire dei sottorighi ripristina la variabile DC
        // facendo in modo che punti ora al suo MasterDataController
        DC.EndFullUpdate;
      end;
    end;
  finally
    // Termina il sistema che determina se deve essere attivata la visualizzazione raggruppata
    // per sezione oppure no.
    TSectionGrouped.EndCheck;
    // Termina l'aggiornamento della griglia
    MDC.EndFullUpdate;
    // Chiude gli eventuali messaggi di attesa
    DM1.CloseWait;
    // Distrugge Qry
    Qry.Free;
  end;
end;

// Salva i righi dei DOcumentiCorrelati (fattura elettronica PA)
procedure TPreventiviOrdiniForm.SalvaDocumentiCorrelatiPA(const TipoDocumento, Reg: String; const NumDoc: Longint; const DocData: TDate);
var
  Qry: TIB_Cursor;
  i: Integer;
  DC: TcxCustomDataController;
begin
  // Se NON sono stati caricati i documenti correlati allora esce
  if TabDocumentiCorrelati.Tag <> 1 then
    Exit;
  // Crea l'oggetto Qry
  Qry := TIB_Cursor.Create(Self);
  Qry.DatabaseName := DM1.ArcDBFile;
  Qry.IB_Connection := DM1.DBAzienda;
  try
    // Elimina i righi vecchi
    // NB: Per eliminare i vecchi righi usa le variabili globali che indentificano il documento che
    // a questo punto contengono i valori identificativi non aggiornati (nel caso si fossero cambiati uno dei
    // dati della chiave del documento) e quindi permettono di eliminare i vecchi righi correttamente.
    Qry.SQL.Add('DELETE FROM PRVORDCL_DOCCORRELATI WHERE');
    Qry.SQL.Add('    TipoDocumento = ''' + TipoDoc + '''');
    Qry.SQL.Add('AND Registro = ''' + Registro + '''');
    Qry.SQL.Add('AND NumOrdPrev = ' + IntToStr(NumeroDoc));
    Qry.SQL.Add('AND DataDocumento = ''' + FormatDateTime('mm/dd/yyyy', DataDoc) + '''');
    Qry.ExecSQL;
    // Imposta la query per il salvataggio dei nuovi righi
    Qry.SQL.Clear;
    Qry.SQL.Add
      ('insert into PRVORDCL_DOCCORRELATI (TipoDocumento, Registro, NumOrdPrev, DataDocumento, ID, Tipo, RiferimentoNumeroLinea, IdDocumento, Data, NumItem, CodiceCommessaConvenzione, CodiceCUP, CodiceCIG)');
    Qry.SQL.Add
      ('values (:P_TipoDocumento, :P_Registro, :P_NumOrdPrev, :P_DataDocumento, :P_ID, :P_Tipo, :P_RiferimentoNumeroLinea, :P_IdDocumento, :P_Data, :P_NumItem, :P_CodiceCommessaConvenzione, :P_CodiceCUP, :P_CodiceCIG)');
    Qry.Prepare;
    // Salvataggio righi documento correlati
    DC := TableViewDocCorr.DataController;
    DC.BeginFullUpdate;
    try
      for i := 0 to DC.RecordCount - 1 do
      begin
        Qry.ParamValues['P_TipoDocumento'] := TipoDocumento;
        Qry.ParamValues['P_Registro'] := Reg;
        Qry.ParamValues['P_NumOrdPrev'] := NumDoc;
        Qry.ParamValues['P_DataDocumento'] := DocData;
        Qry.ParamValues['P_ID'] := DC.Values[i, TableViewDocCorr_ID.Index];
        Qry.ParamValues['P_Tipo'] := DC.Values[i, TableViewDocCorr_Tipo.Index];
        Qry.ParamValues['P_RiferimentoNumeroLinea'] := DC.Values[i, TableViewDocCorr_RifNumLinea.Index];
        Qry.ParamValues['P_IdDocumento'] := DC.Values[i, TableViewDocCorr_IDDoc.Index];
        Qry.ParamValues['P_Data'] := DC.Values[i, TableViewDocCorr_Data.Index];
        Qry.ParamValues['P_NumItem'] := DC.Values[i, TableViewDocCorr_NumItem.Index];
        Qry.ParamValues['P_CodiceCommessaConvenzione'] := DC.Values[i, TableViewDocCorr_CodCommConv.Index];
        Qry.ParamValues['P_CodiceCUP'] := DC.Values[i, TableViewDocCorr_CUP.Index];
        Qry.ParamValues['P_CodiceCIG'] := DC.Values[i, TableViewDocCorr_CIG.Index];
        Qry.ExecSQL;
      end;
    finally
      DC.EndFullUpdate;
    end;
    // Salvataggio DDT correlati
    DC := TableViewDDTCorr.DataController;
    DC.BeginFullUpdate;
    try
      for i := 0 to DC.RecordCount - 1 do
      begin
        Qry.ParamValues['P_TipoDocumento'] := TipoDocumento;
        Qry.ParamValues['P_Registro'] := Reg;
        Qry.ParamValues['P_NumOrdPrev'] := NumDoc;
        Qry.ParamValues['P_DataDocumento'] := DocData;
        Qry.ParamValues['P_ID'] := DC.Values[i, TableViewDDTCorr_ID.Index];
        Qry.ParamValues['P_Tipo'] := 'D.D.T.';
        Qry.ParamValues['P_RiferimentoNumeroLinea'] := DC.Values[i, TableViewDDTCorr_RifNumLinea.Index];
        Qry.ParamValues['P_IdDocumento'] := DC.Values[i, TableViewDDTCorr_Numero.Index];
        Qry.ParamValues['P_Data'] := DC.Values[i, TableViewDDTCorr_Data.Index];
        Qry.ExecSQL;
      end;
    finally
      DC.EndFullUpdate;
    end;
  finally
    // Distrugge l'oggetto Qry
    Qry.Free;
  end;
end;

// Carica i righi dei DOcumentiCorrelati (fattura elettronica PA)
procedure TPreventiviOrdiniForm.CaricaDocumentiCorrelatiPA;
var
  Qry: TIB_Cursor;
  i: Integer;
  DC, DCDDT: TcxCustomDataController;
begin
  // Se non sono stati già caricati carica i dati dei documento correlati
  if TabDocumentiCorrelati.Tag = 1 then
    Exit;
  // Inizializzazione
  DC := TableViewDocCorr.DataController;
  DCDDT := TableViewDDTCorr.DataController;
  // Crea l'oggetto Qry
  Qry := TIB_Cursor.Create(Self);
  Qry.DatabaseName := DM1.ArcDBFile;
  Qry.IB_Connection := DM1.DBAzienda;
  DM1.ShowWait('', 'Carico i dati dei documenti correlati (Fattura elettronica)');
  try
    DC.BeginFullUpdate;
    DCDDT.BeginFullUpdate;
    // Imposta la query
    Qry.SQL.Add('SELECT * FROM PRVORDCL_DOCCORRELATI WHERE');
    Qry.SQL.Add('    TipoDocumento = ''' + TipoDoc + '''');
    Qry.SQL.Add('AND Registro = ''' + Registro + '''');
    Qry.SQL.Add('AND NumOrdPrev = ' + IntToStr(NumeroDoc));
    Qry.SQL.Add('AND DataDocumento = ''' + FormatDateTime('mm/dd/yyyy', DataDoc) + '''');
    Qry.Open;
    // Cicla per tutti records trovati
    while not Qry.Eof do
    begin
      // Se è un riferimento a un DDT correlato
      if Qry.FieldByName('TIPO').AsString = 'D.D.T.' then
      begin
        i := DCDDT.AppendRecord;
        DCDDT.Values[i, TableViewDDTCorr_ID.Index] := Qry.FieldByName('ID').Value;
        DCDDT.Values[i, TableViewDDTCorr_RifNumLinea.Index] := Qry.FieldByName('RiferimentoNumeroLinea').Value;
        DCDDT.Values[i, TableViewDDTCorr_Numero.Index] := Qry.FieldByName('IdDocumento').Value;
        DCDDT.Values[i, TableViewDDTCorr_Data.Index] := Qry.FieldByName('Data').Value;
      end
      // Altrimenti è uno degli altri documenti correlati
      else
      begin
        i := DC.AppendRecord;
        DC.Values[i, TableViewDocCorr_ID.Index] := Qry.FieldByName('ID').Value;
        DC.Values[i, TableViewDocCorr_Tipo.Index] := Qry.FieldByName('Tipo').Value;
        DC.Values[i, TableViewDocCorr_RifNumLinea.Index] := Qry.FieldByName('RiferimentoNumeroLinea').Value;
        DC.Values[i, TableViewDocCorr_IDDoc.Index] := Qry.FieldByName('IdDocumento').Value;
        DC.Values[i, TableViewDocCorr_Data.Index] := Qry.FieldByName('Data').Value;
        DC.Values[i, TableViewDocCorr_NumItem.Index] := Qry.FieldByName('NumItem').Value;
        DC.Values[i, TableViewDocCorr_CodCommConv.Index] := Qry.FieldByName('CodiceCommessaConvenzione').Value;
        DC.Values[i, TableViewDocCorr_CUP.Index] := Qry.FieldByName('CodiceCUP').Value;
        DC.Values[i, TableViewDocCorr_CIG.Index] := Qry.FieldByName('CodiceCIG').Value;
      end;
      // Avanti il prossimo
      Qry.Next;
    end;
    // SI annota nel Tag del TabSheet che il caricamento è avvenuto
    TabDocumentiCorrelati.Tag := 1;
  finally
    DC.EndFullUpdate;
    DCDDT.EndFullUpdate;
    DM1.CloseWait;
    // Distrugge l'oggetto Qry
    Qry.Free;
  end;
end;

// Carica le caption dei vari campi
procedure TPreventiviOrdiniForm.CaricaTitoli;
var
  M: TMemIniFile;
  Sez: String;
begin
  Sez := 'TitoliDocumenti';
  M := TMemIniFile.Create(DM1.Repository_Menu.FullLocalFileName);
  try
    // =========================================================================
    // Imposta i tabs per spostarsi tra le varie sezini dell'intervento
    // -------------------------------------------------------------------------
    // IMpostazione Captions e Visibilità dei Tabs relativi all'appuntamento
    if Self.IsImpegno then
    begin
      TabControlPagineDocumento.Tabs[DOCTABIDX_APPUNTAMENTO].Caption := ImpegnoForm.TabControlPagineDocumento.Tabs[DOCTABIDX_APPUNTAMENTO].Caption;
      TabControlPagineDocumento.Tabs[DOCTABIDX_RICAMBIMANODOPERA].Caption := ImpegnoForm.TabControlPagineDocumento.Tabs[DOCTABIDX_RICAMBIMANODOPERA].Caption;
      TabControlPagineDocumento.Tabs[DOCTABIDX_OPERAZIONIPIANIFICATE].Caption := ImpegnoForm.TabControlPagineDocumento.Tabs
        [DOCTABIDX_OPERAZIONIPIANIFICATE].Caption;
      TabControlPagineDocumento.Tabs[DOCTABIDX_INTERVENTIPRECEDENTI].Caption := ImpegnoForm.TabControlPagineDocumento.Tabs
        [DOCTABIDX_INTERVENTIPRECEDENTI].Caption;
      TabControlPagineDocumento.Tabs[DOCTABIDX_ALLEGATI].Caption := ImpegnoForm.TabControlPagineDocumento.Tabs[DOCTABIDX_ALLEGATI].Caption;
      TabControlPagineDocumento.Tabs[DOCTABIDX_MAPPA].Caption := ImpegnoForm.TabControlPagineDocumento.Tabs[DOCTABIDX_MAPPA].Caption;

      TabControlPagineDocumento.Tabs[DOCTABIDX_APPUNTAMENTO].Visible := ImpegnoForm.TabControlPagineDocumento.Tabs[DOCTABIDX_APPUNTAMENTO].Visible;
      TabControlPagineDocumento.Tabs[DOCTABIDX_RICAMBIMANODOPERA].Visible := ImpegnoForm.TabControlPagineDocumento.Tabs[DOCTABIDX_RICAMBIMANODOPERA].Visible;
      TabControlPagineDocumento.Tabs[DOCTABIDX_OPERAZIONIPIANIFICATE].Visible := ImpegnoForm.TabControlPagineDocumento.Tabs
        [DOCTABIDX_OPERAZIONIPIANIFICATE].Visible;
      TabControlPagineDocumento.Tabs[DOCTABIDX_INTERVENTIPRECEDENTI].Visible := ImpegnoForm.TabControlPagineDocumento.Tabs
        [DOCTABIDX_INTERVENTIPRECEDENTI].Visible;
      TabControlPagineDocumento.Tabs[DOCTABIDX_ALLEGATI].Visible := ImpegnoForm.TabControlPagineDocumento.Tabs[DOCTABIDX_ALLEGATI].Visible;
      TabControlPagineDocumento.Tabs[DOCTABIDX_MAPPA].Visible := ImpegnoForm.TabControlPagineDocumento.Tabs[DOCTABIDX_MAPPA].Visible;

      TabControlPagineDocumento.Tabs[DOCTABIDX_APPUNTAMENTO].Enabled := ImpegnoForm.TabControlPagineDocumento.Tabs[DOCTABIDX_APPUNTAMENTO].Enabled;
      TabControlPagineDocumento.Tabs[DOCTABIDX_RICAMBIMANODOPERA].Enabled := ImpegnoForm.TabControlPagineDocumento.Tabs[DOCTABIDX_RICAMBIMANODOPERA].Enabled;
      TabControlPagineDocumento.Tabs[DOCTABIDX_OPERAZIONIPIANIFICATE].Enabled := ImpegnoForm.TabControlPagineDocumento.Tabs
        [DOCTABIDX_OPERAZIONIPIANIFICATE].Enabled;
      TabControlPagineDocumento.Tabs[DOCTABIDX_INTERVENTIPRECEDENTI].Enabled := ImpegnoForm.TabControlPagineDocumento.Tabs
        [DOCTABIDX_INTERVENTIPRECEDENTI].Enabled;
      TabControlPagineDocumento.Tabs[DOCTABIDX_ALLEGATI].Enabled := ImpegnoForm.TabControlPagineDocumento.Tabs[DOCTABIDX_ALLEGATI].Enabled;
      TabControlPagineDocumento.Tabs[DOCTABIDX_MAPPA].Enabled := ImpegnoForm.TabControlPagineDocumento.Tabs[DOCTABIDX_MAPPA].Enabled;
    end
    else
    begin
      TabControlPagineDocumento.Tabs[DOCTABIDX_APPUNTAMENTO].Visible := False;
      TabControlPagineDocumento.Tabs[DOCTABIDX_RICAMBIMANODOPERA].Visible := False;
      TabControlPagineDocumento.Tabs[DOCTABIDX_OPERAZIONIPIANIFICATE].Visible := False;
      TabControlPagineDocumento.Tabs[DOCTABIDX_INTERVENTIPRECEDENTI].Visible := False;
      TabControlPagineDocumento.Tabs[DOCTABIDX_ALLEGATI].Visible := False;
      TabControlPagineDocumento.Tabs[DOCTABIDX_MAPPA].Visible := False;
    end;
    // IMpostazione Captions e Visibilità dei Tabs relativi all'articolo composto
    TabControlPagineDocumento.Tabs[DOCTABIDX_ANAGRAFICAARTICOLO].Caption := M.ReadString(Sez, 'Tabs_AnagraficaArticolo', 'Anagrafica articolo');
    TabControlPagineDocumento.Tabs[DOCTABIDX_DISTINTABASE].Caption := M.ReadString(Sez, 'Tabs_DistintaBase', 'Distinta Base');
    TabControlPagineDocumento.Tabs[DOCTABIDX_ANAGRAFICAARTICOLO].Visible := Self.DistintaBase;
    TabControlPagineDocumento.Tabs[DOCTABIDX_DISTINTABASE].Visible := Self.DistintaBase;
    // =========================================================================
    // Dati documento
    LabelCantiere.Caption := DM1.DatiDocumento_LabelPratica;
    LabelAzioneCantiere.Caption := DM1.DatiDocumento_LabelAzionePratica;
    // Soggetto
    if DM1.IsDocumentoDiIngresso(QryDocumentoTIPODOCUMENTO.AsString) then
      MittenteDestinatario.Caption := ' ' + M.ReadString(Sez, 'Soggetto_PanelTitle_DocAcquisto', 'MITTENTE')
    else
      MittenteDestinatario.Caption := ' ' + M.ReadString(Sez, 'Soggetto_PanelTitle_DocVendita', 'DESTINATARIO');
    // Destinazione merce
    LabelPanelDestinazioneMerce.Caption := ' ' + M.ReadString(Sez, 'DestinazioneMerce_PanelTitle', 'DESTINAZIONE DELLA MERCE');
    // Agente
    LabelAgente.Caption := DM1.GridsColumnAgenteCaption;
    // Sottocantieri
    tvCorpoSOTTOCANTIERE1.Caption := M.ReadString(Sez, 'CorpoDoc_Column_Sottocantiere1', 'Sottocantiere 1');
    tvCorpoSOTTOCANTIERE2.Caption := M.ReadString(Sez, 'CorpoDoc_Column_Sottocantiere2', 'Sottocantiere 2');
    tvCorpoSOTTOCANTIERE3.Caption := M.ReadString(Sez, 'CorpoDoc_Column_Sottocantiere3', 'Sottocantiere 3');
    tvCorpoSOTTOCANTIERE4.Caption := M.ReadString(Sez, 'CorpoDoc_Column_Sottocantiere4', 'Sottocantiere 4');
    tvCorpoSOTTOCANTIERE5.Caption := M.ReadString(Sez, 'CorpoDoc_Column_Sottocantiere5', 'Sottocantiere 5');
    tvCorpoSOTTOCANTIERE6.Caption := M.ReadString(Sez, 'CorpoDoc_Column_Sottocantiere6', 'Sottocantiere 6');
    tvDiBaSOTTOCANTIERE1.Caption := tvCorpoSOTTOCANTIERE1.Caption;
    tvDiBaSOTTOCANTIERE2.Caption := tvCorpoSOTTOCANTIERE2.Caption;
    tvDiBaSOTTOCANTIERE3.Caption := tvCorpoSOTTOCANTIERE3.Caption;
    tvDiBaSOTTOCANTIERE4.Caption := tvCorpoSOTTOCANTIERE4.Caption;
    tvDiBaSOTTOCANTIERE5.Caption := tvCorpoSOTTOCANTIERE5.Caption;
    tvDiBaSOTTOCANTIERE6.Caption := tvCorpoSOTTOCANTIERE6.Caption;
    // Tipi
    tvCorpoTIPO1.Caption := M.ReadString(Sez, 'CorpoDoc_Column_Tipo1', 'Tipo 1');
    tvCorpoTIPO2.Caption := M.ReadString(Sez, 'CorpoDoc_Column_Tipo2', 'Tipo 2');
    tvCorpoTIPO3.Caption := M.ReadString(Sez, 'CorpoDoc_Column_Tipo3', 'Tipo 3');
    tvCorpoTIPO4.Caption := M.ReadString(Sez, 'CorpoDoc_Column_Tipo4', 'Tipo 4');
    tvCorpoTIPO5.Caption := M.ReadString(Sez, 'CorpoDoc_Column_Tipo5', 'Tipo 5');
    tvCorpoTIPO6.Caption := M.ReadString(Sez, 'CorpoDoc_Column_Tipo6', 'Tipo 6');
    tvDiBaTIPO1.Caption := tvCorpoTIPO1.Caption;
    tvDiBaTIPO2.Caption := tvCorpoTIPO2.Caption;
    tvDiBaTIPO3.Caption := tvCorpoTIPO3.Caption;
    tvDiBaTIPO4.Caption := tvCorpoTIPO4.Caption;
    tvDiBaTIPO5.Caption := tvCorpoTIPO5.Caption;
    tvDiBaTIPO6.Caption := tvCorpoTIPO6.Caption;
    // JolyNums
    LabelJollyNum1.Caption := DM1.DatiDocumento_LabelJollyNum1;
  finally
    M.Free;
  end;
end;

procedure TPreventiviOrdiniForm.CaricaLayoutDocumento; // Personale
const
  MARGIN_UP = 0;
var
  LO: TMemIniFile;
  Contatore, i, yy, Sep, SubYY: Integer;
  Sezione, DisplayFormat, TmpStr: String;
  LIsPreventivo: Boolean;
begin
  // IMposta i pulsanti per l'importazione dal terminale barcode
  ControllaAbilitazioneImportazionePalmare;
  // Inizializzazione della sezione del Layouts.ini da ciu bisogna leggere i parametri
  Sezione := TipoDoc;
  // Se è una distinta base forza il tipodocumento a DistintaBase invece di quello
  // indicato da TipoDoc che contiene in questo caso il codice articolo
  if DistintaBase then
    Sezione := 'DistintaBase';
  // Caricamento di alcuni valori di default da LOGHI.INI
  LO := TMemIniFile.Create(DM1.Repository_Loghi.FullLocalFileName);
  try
    // Carica il valore di default che decide se stampare o meno i loghi dei documenti
    fDefaultStampaLogoIntestazione := LO.ReadBool(Sezione, 'AbilitaStampaIntestazione', True);
  finally
    LO.Free;
  end;
  // Inizializza la variabile che contiene il valore della posizione attuale
  // del pennello di  visualizzazione tramite il quale ci si regola per la visualizzazione
  // dei componenti.
  yy := MARGIN_UP;
  // Apre il file che contiene i layouts di stampa e visualizzazione dei documenti.
  LO := TMemIniFile.Create(DM1.Repository_Layouts.FullLocalFileName);
  try
    // Abilita o meno la gestione dello SplitPayment per tipo di documento
    //  NB: IL QryDocumento.Refresh l'ho messo perchè altrimenti se aprivo una fattura esistente con
    //       lo SplitPayment l'importo dello stesso era a zero e poi tornava a posto se lo facevo ricalcolare
    //       in qualche modo. Questo accadeva perchè l'event handler OnCalclFields veniva eseguito prima che
    //       il parametro FSplitPayment venisse caricato. Facendo in questo modo in pratica forso il ricalcolo
    //       non appena ho caricato tale parametro e l'utente vede subito il TotaleSplitPayment corretto
    FSplitPayment := LO.ReadBool(Sezione, 'SplitPayment', ((TipoDoc = 'Fattura') or (TipoDoc = 'Nota_accre')));
    // Carica il flag che indica se, per questo tipo di documento, deve essere attivo o meno
    // il discorso dei beni significativi e non significativi automatico
    fRaggruppamentoSezioni := LO.ReadBool(Sezione, 'RaggruppamentoSezioni', (TipoDoc = 'Preventivo'));
    fCalcoloTotaliAutomatico := LO.ReadBool(Sezione, 'CalcoloTotaliAutomatico', True);
    fCalcoloTotaliACorpoAutomatico := LO.ReadBool(Sezione, 'CalcoloTotaliACorpoAutomatico', True);
    fCalcoloBeniSignificativiAutomatico := LO.ReadBool(Sezione, 'CalcoloBeniSignificativiAutomatico', (TipoDoc = 'Preventivo') or (TipoDoc = 'Fattura') or
      (TipoDoc = 'Fatt.R.F.'));
    // Flag che abilita o meno, alla conferma del documento, la richiesta
    // di creazione automatica delle scadenza
    fScadenzeCreazioneAutomatica := LO.ReadBool(Sezione, 'ScadenzeCreazioneAutomatica',
      ((TipoDoc = 'Fattura') or (TipoDoc = 'Fatt.R.F.') or (TipoDoc = 'Nota_accre'))); // or (TipoDoc = 'Fatt.acqui') or (TipoDoc = 'N.C.fornit')
    fScadenzeCreazioneAutomaticaSoloDocumento := LO.ReadBool(Sezione, 'ScadenzeCreazioneAutomaticaSoloDocumento', False); // Mascagni
    // Flag che abilita o meno l'aggiunta dell'anno al numero del documento in fase di stampa
    // (es: Fature 125/2013-)
    fNumDocUnivoco_ProgressivoInfinito := (DM1.TableProgressivi2NUMDOCUNIVOCO_ENABLED.AsString = 'T') and
      LO.ReadBool(Sezione, 'NumDocUnivoco_ProgressivoInfinito', False);

    // =======================================================================
    // Flag che indica se, quando dei documenti vengono importati nel documento corrente dalla bacheca
    // questi vengono marcati come "Fatturati" oppure no.
    // In pratica posso decidere questa cosa o meno separatamente per la Fattura e anche per
    // l'estratto conto.
    // -----------------------------------------------------------------------
    // Se il documento attuale è una fattura marca i documenti importati come fatturati di default
    if (Sezione = 'Fattura') or (Sezione = 'Ricev.fisc') or (Sezione = 'Fatt.R.F.') or (Sezione = 'Fatt.acqui') then
      DocImportati_SetFatturato := LO.ReadBool(Sezione, 'MarcaDocImportatiComeFatturati', True)
    else
      DocImportati_SetFatturato := LO.ReadBool(Sezione, 'MarcaDocImportatiComeFatturati', False);
    // Se il documento attuale è una fattura marca setta lo stato dei documenti importati come dopo fatturati
    // (Lo stato vero e proprio lo prende dal tipo di documento importato)
    if (Sezione = 'Fattura') or (Sezione = 'Ricev.fisc') or (Sezione = 'Fatt.R.F.') then
      DocImportati_SetStatoDopoFattura := LO.ReadBool(Sezione, 'DocImportati_SetStatoDopoFattura', True)
    else
      DocImportati_SetStatoDopoFattura := LO.ReadBool(Sezione, 'DocImportati_SetStatoDopoFattura', False);
    // Se il documento attuale è una estratto conto marca setta lo stato dei documenti importati come dopo Estratto_conto
    // (Lo stato vero e proprio lo prende dal tipo di documento importato)
    if (Sezione = 'Estratto_conto') then
      DocImportati_SetStatoDopoEstrattoConto := LO.ReadBool(Sezione, 'DocImportati_SetStatoDopoEstrattoConto', True)
    else
      DocImportati_SetStatoDopoEstrattoConto := LO.ReadBool(Sezione, 'DocImportati_SetStatoDopoEstrattoConto', False);
    // Se il documento attuale è una fattura e il documento importato fa riferimento ad un Documento (Ric.Fisc)
    // con CNP marca iil documento importato come con CNP chiuso.
    // (Lo stato vero e proprio lo prende dal tipo di documento importato)
    if (Sezione = 'Fattura') or (Sezione = 'Ricev.fisc') or (Sezione = 'Fatt.R.F.') then
      DocImportati_SetCorrispNoPagChiuso := LO.ReadBool(Sezione, 'DocImportati_SetCorrispNoPagChiuso', True)
    else
      DocImportati_SetCorrispNoPagChiuso := LO.ReadBool(Sezione, 'DocImportati_SetCorrispNoPagChiuso', False);
    // =======================================================================

    // Flag che indica se è abilita la gestione delle versioni multiple di uno stesso documento
    // utilizzando il campo Registro come numero di versione
    AbilitaGestioneVersioniDocumento := LO.ReadBool(Sezione, 'AbilitaGestioneVersioniDocumento', False);
    // Parametro che abilita o meno la finestrella di richiesta Qta quando si richiama un articolo
    // però separato per documento. Il parametro "RichiediQta" presente nella sezione
    // "FormAnagraficaArticoli" del layouts.ini (quindi generale per tutti i documenti) rimane come
    // interruttore generale e per le parti non facenti parte di un documento (ad es: quando si
    // esporta un articolo dall'elenco articoli alla bacheca).
    fRichiediQtaDoc := LO.ReadBool(Sezione, 'RichiediQtaDoc', True) and DM1.RichiediQta;
    // Parametro che abilita o meno la richiesta di conferma (se continuare o meno l'operazione)
    // nel caso si stia cercando di inserire un articolo che però è già presente all'interno
    // del documento.
    fConfermaNuovoRigoSeArticoloGiaPresente := LO.ReadBool(Sezione, 'RichiediConfermaSeArticoloGiaPresente', False);
    // Flag che abilita l'assegnazione automatica del protocollo alle fatture di acquisto
    // NB: In base a questo parametro rende anche visibile o meno nel riquadro del protocollo
    // la data di creazione/registrazione o meno
    ProtocolloAutomatico := LO.ReadBool(Sezione, 'ProtocolloAutomatico', False);
    ProtocolloAutomatico_Data := LO.ReadBool(Sezione, 'ProtocolloAutomatico_Data', False);
    ProtocolloAutomatico_DataRiferimento_FieldName := LO.ReadString(Sezione, 'ProtocolloAutomatico_DataRiferimento_FieldName', 'DATADOCUMENTO');
    DBEditProtocollo.Properties.ReadOnly := LO.ReadBool(Sezione, 'ProtocolloReadOnly', ProtocolloAutomatico);
    DBEditProtocolloData.Properties.ReadOnly := LO.ReadBool(Sezione, 'ProtocolloReadOnly_Data', ProtocolloAutomatico_Data);
    // Caricva il parametro che abilita o meno la presenza daella ragione sociale negli
    // eventuali righi di riferimenti.
    FAbilitaNumInterventoRiferimento := LO.ReadBool(Sezione, 'AbilitaNumInterventoRiferimento', True);
    FAbilitaDataInterventoRiferimento := LO.ReadBool(Sezione, 'AbilitaDataInterventoRiferimento', True);
    fAbilitaRagSocRiferimento := LO.ReadBool(Sezione, 'AbilitaRagSocRiferimento', True);
    fRagSocRIferimentoSoloDocAcq := LO.ReadBool(Sezione, 'RagSocRiferimentoSoloDocAcq', True);
    fAbilitaPraticaRiferimento := LO.ReadBool(Sezione, 'AbilitaPraticaRiferimento', False);
    // Carica il flag che indica se gli sconti devono funzionare al contrario
    // (fatto per la geotek per gestire le percentuali di avanzamento dei lavori)
    fScontiAlContrario := LO.ReadBool(Sezione, 'ScontiRighiAlContrario', False);
    // Carica il flag che abilita o meno l'evidenziazione dei righi in cui mancano la Qta
    // oppure il Prezzo UIntario
    EvidenziaRighiSenzaQtaPrzUnit := LO.ReadBool(Sezione, 'EvidenziaRighiSenzaQtaPrzUnit', True);
    // Carica il flag che abilita o meno il Tab dei dati aggiuntivi per la fattura elettronica PA
    // NB: Per default è abilitato nella fattura e nella nota di credito
    TabDocumentiCorrelati.TabVisible := DM1.IsFatturaEletronica(Sezione);
    TabNotifiche.TabVisible := DM1.IsFatturaEletronica(Sezione);
    // Carica il flag che abilita o meno il sistema delle preferenze di stampa
    // NB: Per default è disabilitato su tutti i tipi di documento tranne che sul preventivo su cui è abilitato
    fStmPref_Enabled := LO.ReadBool(Sezione, 'StmPref_Enabled', (Sezione = 'Preventivo'));
    TabStampa.TabVisible := fStmPref_Enabled;
    // Carica il parametro che indica che tipo di salvataggio deve essere utilizzato dal
    // sistema delle preferenze di stampa per questo documento:
    // NB: 0=Non salva mai nulla; 1=Salva solo il parametro diverso dal default; 2=Salva sempre tutto
    fStmPref_SaveMode := LO.ReadInteger(Sezione, 'StmPref_SaveMode', STMPREF_SAVEMODE_ALL);
    // Variabile che indica se stampare (di default) il documento con totali iva compresa o esclusa
    fStmPref_TotaliIvaEsclusa := LO.ReadBool(Sezione, 'StmPref_TotaliIvaEsclusa', False);
    // Carica il flag che indica se stampare i dettagli del castelletto IVA oppure no
    fStampaCastellettoIVA := LO.ReadBool(Sezione, 'CastellettoIVA', True);




    // Carica il flag che indica se ativare la numerazione automatica per questo
    // documento
    // NB: Se è un documento di ingresso il default := False altrimenti True
    if DM1.IsDocumentoDiIngresso(QryDocumentoTIPODOCUMENTO.AsString) and (QryDocumentoTIPODOCUMENTO.AsString <> 'Ord.fornit') then
      NumerazioneAutomatica := LO.ReadBool(Sezione, 'NumerazioneAutomatica', False)
    else
      NumerazioneAutomatica := LO.ReadBool(Sezione, 'NumerazioneAutomatica', True);
    // Parametro che indica se la "progressione" del numero documento rispetto alla data deve
    //  essere garantita (quindi blocca nel caso) oppure no (quindi avverte ma non blocca)
    fGarantisciProgressioneNumDoc := LO.ReadBool(Sezione, 'GarantisciProgressioneNumDoc', (TipoDoc='Fattura')or(TipoDoc='Nota_accre')or(TipoDoc='D.D.T.')or(TipoDoc='Fatt.R.F.'));
    // Caricamento della destinazione (riferita al magazzino e al cantiere) delle colonne
    // QTAEVASA e QTADAEVADERE
    DestMagQtaEvasa := Trim(LO.ReadString(Sezione, 'DestMagQtaEvasa', ''));
    DestMagQtaDaEvadere := Trim(LO.ReadString(Sezione, 'DestMagQtaDaEvadere', ''));
    DestGCQtaEvasa := Trim(LO.ReadString(Sezione, 'DestGCQtaEvasa', ''));
    DestGCQtaDaEvadere := Trim(LO.ReadString(Sezione, 'DestGCQtaDaEvadere', ''));
    // Carica il parametro che indica se i totali del documento vengono calcolati con lo scorporo IVA
    // oppure normalmente (nei documenti dove compaiono i prezzi IVA compresa si fà lo scorporo altrimenti no)
    if not CaricaLayoutDocumento_NotLoadColumnSettingsNextTime then
      DM1.ScorporoIVA := LO.ReadBool(Sezione, 'ScorporoIVA', False);
    // Carica il parametro che indica se, quando vengono importati dei righi di altri documenti, deve essere
    // generata automaticamente la riga di riferimento al documento dal quale i righi procengono oppure no
    // NB: 0=Riferimento disabilitato; 1=Riferimento abilitato ma se c'è un riferimento a un documento secondario
    // (es: Ricevute fiscali negli interventi, vedi campi RifDoc_XXX) mette solo il riferimento al documento
    // secondario (solo Ric.Fisc. non dell'intervento); 2=Riferimento abilitato e se c'è anche un riferimento
    // a un documento secondario (vedi sopra) li mette entrambi (sia rif. all'intervento che alla Ric.Fisc)
    RifEnabled := LO.ReadInteger(Sezione, 'RiferimentoImportazione', 1);
    // Carica il parametro che indica se, al salvataggio del documento, deve essere effettuato, la conversione
    // delle descrizioni degli articoli nella descrizione dei gruppi di appartenenza.
    AbilitaConversioneDescArtToDescGruppo := LO.ReadBool(Sezione, 'ConversioneDescArtToDescGruppo', False);
    // Carica il parametro che indica se, al salvataggio del documento, deve essere effettuato, l'accorpamento dei righi oppure no
    // C'è anche una variabile numerico che indica il tipo di raggruppamento secondo questo schema
    // 0 = Accorpamento righi disabilitato
    // 1 = Accorpamento righi che controlla tutti i campi del rigo documento e somma della Qtà dei righi assolutamente identici
    // 2 = Accorpamento righi che controlla solo il codice e la descrizione e somma gli importi del rigo e Qtà sempre = 1
    AbilitaAccorpamentoRighi := LO.ReadBool(Sezione, 'AccorpamentoRighi', False);
    TipoAccorpamentoRighi := LO.ReadInteger(Sezione, 'AccorpamentoRighi', 0);
    // Verifica che non siano contemporaneamente attivi le Condizioni di Vendita
    // e l'accorpamento dei righi del documento
    if AbilitaAccorpamentoRighi and (DM1.ModCtrl(MOD_CONDIZIONI_VENDITA) > 0) then
      DM1.Messaggi('ATTENZIONE !!!',
        'ACCORPAMENTO RIGHI e CONDIZIONI DI VENDITA/ACQUISTO attivi contemporaneamente.'#13#13'Questa combinazione POTREBBE CAUSARE DEI MALFUNZIONAMENTI dell''accorpamento.'#13#13'Si consiglia di disabilitare una delle due funzioni.'#13#13'Chiamare il centro di assistenza tecnica.',
        '', [mbOk], 0, nil);
    // Carica i parametri per l'aggiornamento automatico dei prezzi di acquisto
    // per quanto riguarda i documenti di ingresso/acquisto
    AggiornamentoAutomaticoPrezziDiAcquisto := LO.ReadBool(Sezione, 'AggiornamentoAutomaticoPrezziDiAcquisto', DM1.IsDocumentoDiIngresso(TipoDoc));
    RichiediConfermaAggiornamentoAutomaticoPrezziDiAcquisto := LO.ReadBool(Sezione, 'RichiediConfermaPerAggiornamentoAutomaticoPrezziDiAcquisto', True);
    // Abilita/disabilita caricamento automatico nuovi articoli
    FCaricamentoAutomaticoNuoviArticoli := LO.ReadBool(Sezione, 'CreazioneAutomaticaNuoviArticoli',
      (DM1.IsDocumentoDiIngresso(TipoDoc) and (TipoDoc <> 'Fatt.acqui') and (TipoDoc <> 'N.C.fornit')));
    // Carica il parametro che abilita il controllo se il documento attuale sta cercando di scaricare
    // degli articoli oltre il redisuo disponibile nel cantiere stesso
    VerificaSottoscortaCantiere := LO.ReadBool(Sezione, 'AvvertiSottoscortaCantiere', True);
    // Carica il flag che abilita o meno i caricamento delle spese di incasso.
    // In base al tipo di documento cambia il default.
    if (Sezione = 'Fattura') or (Sezione = 'Fatt.R.F.') or (Sezione = 'Fatt.acqui') then
      CaricaSpeseIncasso := LO.ReadBool(Sezione, 'CaricaSpeseIncasso', True)
    else
      CaricaSpeseIncasso := LO.ReadBool(Sezione, 'CaricaSpeseIncasso', False);
    // Carica alcuni flags
    ConfermaDocSoloConSoggettoSelezionato := LO.ReadBool(Sezione, 'ConfermaDocSoloConSoggettoSelezionato', False);
    ConfermaDocSoloConPraticaSelezionata := LO.ReadBool(Sezione, 'ConfermaDocSoloConPraticaSelezionata', False);
    ConfermaDocSoloSeStessoSoggettoDocEPratica := LO.ReadBool(Sezione, 'ConfermaDocSoloSeStessoSOggettoDocEPratica', False);
    ConfermaDocSoloConStatoSelezionato := LO.ReadBool(Sezione, 'ConfermaDocSoloConStatoSelezionato', False);
    // Carica la separazione verticale tra i componenti su una variabile locale per comodità
    Sep := LO.ReadInteger(Sezione, 'SeparazioneVerticale', 5) * 2;
    // Se 'True' quando si crea un nuovo documento pone il focus direttamente sulla ragione sociale del destinatario
    FocusDestinatario := LO.ReadBool(Sezione, 'FocusDestinatario', False);

    // ==================================
    // FINE CARICAMENTO FLAGS E PARAMETRI
    // NB: Dopo questa riga non si devono
    // più caricare flags e parametri
    // globali al documento.
    // ----------------------------------
    // if BodyScreenState = bssFullStretched then
    // Exit;
    if BodyScreenState <> bssFullStretched then
    begin
      // ==================================

      // ----- TABS PER TORNARE ALL'IMPEGNO O ALL'ANAGRAFICA ARTICOLO -----
      if (Self.DistintaBase or Self.IsImpegno) then
      begin
        // Posiziona e visualizza il panello dei TABS
        PanelTabs.Visible := True;
        // Se il PanelTabs è visibile sposta il pannello successivo più in basso di 10 pixels
        // altrimenti viene appiccicato
        Inc(yy, 10);
      end;

      // ------ DATI IDENTIFICATIVI DEL DOCUUMENTO OPPURE DATI DELL'ARTICOLO -----
      // NB: Questa parte, a seconda che si tratti di un documento oppure di una
      // distinta base visualizza o i dati identificativi del documento oppure
      // alcuni dati identificativi dell'articolo
      if Self.DistintaBase then
      begin
        // Dati articolo
        PanelDatiArticolo.Top := yy;
        PanelDatiArticolo.Visible := True;
        yy := yy + PanelDatiArticolo.Height;
      end
      else
      begin
        // Dati documento
        PanelNumDataDocumento.Top := yy;
        PanelNumDataDocumento.Visible := True;
        yy := yy + PanelNumDataDocumento.Height;
        // Se siamo in un impegno rende invisibili i dati del documento
        DatiPrincipaliDocumentoVisible := True;
        // Se siamo in un ordine rende invisibile il pannellino delle azioni del documento
        AzioniVisible := (TipoDoc <> 'Ord.fornit') and (TipoDoc <> 'Ordine');
      end;

      // ----- DATI DEL CANTIERE -----
      PanelCantiere.Tag := LO.ReadInteger(Sezione, 'V_Cantiere', 2);
      PanelCantiere.Visible := PanelCantiere.Tag > 0;

      // ----- DATI DESTINATARIO - LUOGO DI DESTINAZIONE -----
      PanelDestinatario.Tag := LO.ReadInteger(Sezione, 'V_Destinatario', 2);
      PanelLuogoDestinazione.Tag := LO.ReadInteger(Sezione, 'V_LuogoDestinazione', 0);
      if (PanelDestinatario.Tag > 0) or (PanelLuogoDestinazione.Tag > 0) then
      begin
        yy := yy + Sep;
        PanelDestinatario.Height := INTESTATARIO_CLOSE;
        PanelDestinatario.Top := yy;
        PanelDestinatario.Visible := (PanelDestinatario.Tag > 0);
        PanelLuogoDestinazione.Height := INTESTATARIO_CLOSE;
        PanelLuogoDestinazione.Top := yy;
        PanelLuogoDestinazione.Visible := (PanelLuogoDestinazione.Tag > 0);
        yy := yy + PanelDestinatario.Height;
      end;
      // Se è un impegno imposta il PanelLuogoDestinazione anche nell'impegno
      // if Self.IsImpegno then begin
      // ImpegnoForm.PanelLuogoDestinazione.Height   := PanelLuogoDestinazione.Height;
      // ImpegnoForm.PanelLuogoDestinazione.Top      := PanelLuogoDestinazione.Top;
      // ImpegnoForm.PanelLuogoDestinazione.Visible  := PanelLuogoDestinazione.Visible;
      // end;
      // ---------------------------------- MAIN PANEL OPZIONI (TIPO/NUM/DATA) ----------------------------------------
      // Se almeno uno dei sottopannelli è attivato, rende visibile il MainPanel
      if (LO.ReadBool(Sezione, 'V_TipoNumData', True)) or (LO.ReadBool(Sezione, 'V_AbilitaSubSogg', False)) or
        (LO.ReadBool(Sezione, 'V_MagazzinoDocumento', True)) or (LO.ReadBool(Sezione, 'V_MeseCompetenzaDocumento', False)) or
        (LO.ReadBool(Sezione, 'V_StatoDocumento', False)) or (LO.ReadBool(Sezione, 'V_Agente', False)) or
        (LO.ReadBool(Sezione, 'V_RifDoc', (Sezione = 'Intervento'))) then
      begin
        SubYY := SUBPANEL_TOP;
        // PANEL TIPO NUM DATA
        if LO.ReadBool(Sezione, 'V_TipoNumData', True) then
        begin
          PanelTipoNumData.Top := SubYY;
          PanelTipoNumData.Visible := True;
          SubYY := SubYY + PanelTipoNumData.Height;
        end
        else
          PanelTipoNumData.Visible := False;
        // PANEL STATO
        if (LO.ReadBool(Sezione, 'V_MagazzinoDocumento', True)) or (LO.ReadBool(Sezione, 'V_MeseCompetenzaDocumento', False)) or
          (LO.ReadBool(Sezione, 'V_StatoDocumento', False)) or (LO.ReadBool(Sezione, 'V_OrdineChiuso', False)) or (LO.ReadBool(Sezione, 'V_Agente', False)) then
        begin
          PanelStato.Top := SubYY;
          PanelStato.Visible := True;
          SubYY := SubYY + PanelStato.Height;
          // Visualizzazione Magazzino Documento
          LabelMagazzino.Visible := LO.ReadBool(Sezione, 'V_MagazzinoDocumento', False);
          DBEditMagazzino.Visible := LO.ReadBool(Sezione, 'V_MagazzinoDocumento', False);
          BitBtnMagazzino.Visible := LO.ReadBool(Sezione, 'V_MagazzinoDocumento', False);
          LabelMagazzino2.Visible := LO.ReadBool(Sezione, 'V_MagazzinoDocumento', False);
          DBEditMagazzino2.Visible := LO.ReadBool(Sezione, 'V_MagazzinoDocumento', False);
          BitBtnMagazzino2.Visible := LO.ReadBool(Sezione, 'V_MagazzinoDocumento', False);
          // Visualizzazione Agente
          LabelAgente.Visible := LO.ReadBool(Sezione, 'V_Agente', False);
          dbeAgente.Visible := LO.ReadBool(Sezione, 'V_Agente', False);
          if DM1.AgenteEditable then
            dbeAgente.Properties.DropDownListStyle := lsEditList
          else
            dbeAgente.Properties.DropDownListStyle := lsEditFixedList;
          // Visualizzazione Mese Competenza Documento
          LabelMeseCompetenza.Visible := LO.ReadBool(Sezione, 'V_MeseCompetenzaDocumento', False);
          dbeMeseCompetenza.Visible := LO.ReadBool(Sezione, 'V_MeseCompetenzaDocumento', False);
          // Visualizzazione il flag di OrdineChiuso
          DbeOrdineChiuso.Visible := LO.ReadBool(Sezione, 'V_OrdineChiuso', False);
          // Visualizzazione Stato Documento
          LabelStatoDocumento.Visible := LO.ReadBool(Sezione, 'V_StatoDocumento', False);
          DBEditStatoDocumento.Visible := LO.ReadBool(Sezione, 'V_StatoDocumento', False);
          BitBtnSelezioneStato.Visible := LO.ReadBool(Sezione, 'V_StatoDocumento', False);
        end
        else
          PanelStato.Visible := False;

        // PANEL AGENTI (Agente 2, 3, e 4)
        // SubPanel Agenti
        // Agente 2
        LabelAgente2.Caption := DM1.GridsColumnAgente2Caption;
        dbeAgente2.Visible := (DM1.GridsColumnAgente2Caption <> '');
        if DM1.Agente2Editable then
          dbeAgente2.Properties.DropDownListStyle := lsEditList
        else
          dbeAgente2.Properties.DropDownListStyle := lsEditFixedList;
        // Agente 3
        LabelAgente3.Caption := DM1.GridsColumnAgente3Caption;
        dbeAgente3.Visible := (DM1.GridsColumnAgente3Caption <> '');
        if DM1.Agente3Editable then
          dbeAgente3.Properties.DropDownListStyle := lsEditList
        else
          dbeAgente3.Properties.DropDownListStyle := lsEditFixedList;
        // Agente 4
        LabelAgente4.Caption := DM1.GridsColumnAgente4Caption;
        dbeAgente4.Visible := (DM1.GridsColumnAgente4Caption <> '');
        if DM1.Agente4Editable then
          dbeAgente4.Properties.DropDownListStyle := lsEditList
        else
          dbeAgente4.Properties.DropDownListStyle := lsEditFixedList;
        // Se almeno uno dei campi agente è attivo e se il pannello è autorizzato a visualizzarsi, si visualizza
        if (dbeAgente.Visible or dbeAgente2.Visible or dbeAgente3.Visible or dbeAgente4.Visible) and LO.ReadBool(Sezione, 'V_Agente', False) then
        begin
          PanelAgenti.Top := SubYY;
          PanelAgenti.Visible := True;
          SubYY := SubYY + PanelAgenti.Height;
        end
        else
          PanelAgenti.Visible := False;

        // PANEL SUBSOGG
        if LO.ReadBool(Sezione, 'V_AbilitaSubSogg', False) then
        begin
          if LO.ReadString(Sezione, 'V_SubSoggCampo1', '0') <> '0' then
          begin
            LabelSubSogg1.Caption := LO.ReadString(Sezione, 'V_SubSoggCampo1', '0') + ' ';
            LabelSubSogg1.Visible := True;
            DBESubSogg1.Visible := True;
          end;
          if LO.ReadString(Sezione, 'V_SubSoggCampo2', '0') <> '0' then
          begin
            LabelSubSogg2.Caption := LO.ReadString(Sezione, 'V_SubSoggCampo2', '0') + ' ';
            LabelSubSogg2.Visible := True;
            DBESubSogg2.Visible := True;
          end;
          if LO.ReadString(Sezione, 'V_SubSoggCampo3', '0') <> '0' then
          begin
            LabelSubSogg3.Caption := LO.ReadString(Sezione, 'V_SubSoggCampo3', '0') + ' ';
            LabelSubSogg3.Visible := True;
            DBESubSogg3.Visible := True;
          end;
          PanelSubSogg.Top := SubYY;
          PanelSubSogg.Visible := True;
          SubYY := SubYY + PanelSubSogg.Height;
        end
        else
          PanelSubSogg.Visible := False;
        // PANEL JOLLY NUMS
        if LO.ReadBool(Sezione, 'V_JollyNum1', False) then
        begin
          PanelJollyNums.Top := SubYY;
          PanelJollyNums.Visible := True;
          SubYY := SubYY + PanelJollyNums.Height;
        end
        else
          PanelRifDoc.Visible := False;
        // PANEL RIFDOC
        if LO.ReadBool(Sezione, 'V_RifDoc', (Sezione = 'Intervento')) then
        begin
          PanelRifDoc.Top := SubYY;
          PanelRifDoc.Visible := True;
          SubYY := SubYY + PanelRifDoc.Height;
        end
        else
          PanelRifDoc.Visible := False;
        // Attiva il MainPanel
        yy := yy + Sep;
        MainPanelOpzioni.Top := yy;
        MainPanelOpzioni.Visible := True;
        MainPanelOpzioni.Height := SubYY + SUBPANEL_FATTORE_CORREZIONE;
        yy := yy + MainPanelOpzioni.Height;
      end
      else
        MainPanelOpzioni.Visible := False;
      // ---------------------------------------------------------------------------------------------------

      // =======================================================================
      // DIMENSIONAMENTO DEL PANEL CHE COMPRENDE TUTTA LA PARTE SUPERIORE DEL
      // DOCUMENTO
      // -----------------------------------------------------------------------
      PanelUpper.Height := yy;
      // =======================================================================

      // ----- CORPO DOCUMENTO -----
      // NB: Se siamo in modalità BodyFullStreched non ricalcola nulla del
      // corpo documento altrimenti non si visualizza bene.
      yy := yy + Sep;
      PanelCorpoDoc.Top := yy;
      // Calcolo automatico dell'altezza del corpo documento
      PanelCorpoDoc.Height := DocClientArea.ClientHeight - PanelCorpoDoc.Top;
      if BodyScreenState <> bssFullStretched then
      begin
        if DistintaBase then
          PanelCorpoDoc.Height := PanelCorpoDoc.Height - PanelNote.Height - 36
        else
          PanelCorpoDoc.Height := PanelCorpoDoc.Height - PanelPiede1.Height - 7;
      end;
      yy := yy + PanelCorpoDoc.Height;

      // =======================================================================
      // POSIZIONAMENTO DEL PANEL CHE COMPRENDE TUTTA LA PARTE INFERIORE DEL
      // DOCUMENTO
      // -----------------------------------------------------------------------
      PanelLower.Top := yy;
      // =======================================================================

      // ----- PIEDE -----
      PanelPiede1.Visible := False;
      PanelPiede2.Visible := False;
      PanelPiede3.Visible := False;
      case LO.ReadInteger(Sezione, 'V_PiedeTipo', 3) of
        1:
          begin
            PanelPiede1.Top := yy - PanelLower.Top;
            PanelPiede1.Visible := True;
            yy := yy + PanelPiede1.Height;
            // Arrotondamento visibile (abbuono) se è una fattura di acquisto
            if DM1.IsDocumentoDiIngresso(Sezione) then
            begin
              LabelAbbuonoPerc.Visible := False;
              LabelAbbuonoPerc2.Visible := False;
              dbeAbbuonoPerc.Visible := False;
              RGAbbuono.Visible := False;
              LabelAbbuono.Caption := 'Arrotondam.';
            end
            else
            begin
              LabelAbbuonoPerc.Visible := True;
              LabelAbbuonoPerc2.Visible := True;
              dbeAbbuonoPerc.Visible := True;
              RGAbbuono.Visible := True;
              LabelAbbuono.Caption := 'Sc. importo';
            end;
          end;
        2:
          begin
            PanelPiede2.Top := yy - PanelLower.Top;
            PanelPiede2.Visible := True;
            yy := yy + PanelPiede2.Height;
          end;
        3:
          begin
            PanelPiede3.Top := yy - PanelLower.Top;
            PanelPiede3.Visible := True;
            yy := yy + PanelPiede3.Height;
          end;
      end;
      // Inizializza a visibile/invisibile il campo AbbuonoPerc in base alla situazione
      RGAbbuonoPropertiesChange(RGAbbuono);
      // Sposta il PannelloTotaliMargini sul piede attualmente attivo
      AssegnaPanelTotaliMarginiAlPiedeCorrente;
      // ----- RIF. ALTRI SOGGETTI -----
      PanelAltriSoggetti.Tag := LO.ReadInteger(Sezione, 'V_AltriSoggetti', 0);
      if PanelAltriSoggetti.Tag > 0 then
      begin
        yy := yy + Sep;
        PanelAltriSoggetti.Top := yy - PanelLower.Top;
        PanelAltriSoggetti.Visible := True;
        yy := yy + PanelAltriSoggetti.Height;
      end
      else
        PanelAltriSoggetti.Visible := False;
      // ---------------------------------- MAIN PANEL PAGAMENTO ----------------------------------------
      PanelPagamento.Tag := LO.ReadInteger(Sezione, 'V_Pagamento', 2);
      PanelBanca.Tag := LO.ReadInteger(Sezione, 'V_Banca', 2);
      PanelScadenze.Tag := LO.ReadInteger(Sezione, 'V_Scadenze', 2);
      // Se almeno uno dei sottopannelli è attivato, rende visibile il MainPanel
      if (PanelPagamento.Tag > 0) or (PanelBanca.Tag > 0) or (PanelScadenze.Tag > 0) then
      begin
        SubYY := SUBPANEL_TOP;
        // PANEL PAGAMENTO
        if PanelPagamento.Tag > 0 then
        begin
          PanelPagamento.Top := SubYY;
          PanelPagamento.Visible := True;
          SubYY := SubYY + PanelPagamento.Height;
        end
        else
          PanelPagamento.Visible := False;
        // PANEL BANCA
        if PanelBanca.Tag > 0 then
        begin
          PanelBanca.Top := SubYY;
          PanelBanca.Visible := True;
          SubYY := SubYY + PanelBanca.Height;
        end
        else
          PanelBanca.Visible := False;
        // PANEL SCADENZE
        if PanelScadenze.Tag > 0 then
        begin
          PanelScadenze.Top := SubYY;
          PanelScadenze.Visible := True;
          SubYY := SubYY + PanelScadenze.Height;
        end
        else
          PanelScadenze.Visible := False;
        // Attiva il MainPanel
        yy := yy + Sep;
        MainPanelPagamento.Top := yy - PanelLower.Top;
        MainPanelPagamento.Visible := True;
        MainPanelPagamento.Height := SubYY + SUBPANEL_FATTORE_CORREZIONE;
        yy := yy + MainPanelPagamento.Height;
      end
      else
        MainPanelPagamento.Visible := False;
      // ---------------------------------------------------------------------------------------------------
      // ---------------------------------- MAIN PANEL TRASPORTO ----------------------------------------
      PanelTrasporto.Tag := LO.ReadInteger(Sezione, 'V_Trasporto', 2);
      PanelColli.Tag := LO.ReadInteger(Sezione, 'V_Colli', 2);
      // Se almeno uno dei sottopannelli è attivato, rende visibile il MainPanel
      if PanelTrasporto.Tag > 0 then
      begin
        SubYY := SUBPANEL_TOP;
        // SUB-PANEL NOTE
        if PanelTrasporto.Tag > 0 then
        begin
          PanelTrasporto.Top := SubYY;
          PanelTrasporto.Visible := True;
          Inc(SubYY, PanelTrasporto.Height);
        end
        else
          PanelTrasporto.Visible := False;
        // SUB-PANEL ARGOMENTO
        if PanelColli.Tag > 0 then
        begin
          PanelColli.Top := SubYY;
          PanelColli.Visible := True;
          SubYY := SubYY + PanelColli.Height;
        end
        else
          PanelColli.Visible := False;
        // Attiva il MainPanel
        yy := yy + Sep;
        MainPanelTrasporto.Top := yy - PanelLower.Top;
        MainPanelTrasporto.Visible := True;
        MainPanelTrasporto.Height := SubYY + SUBPANEL_FATTORE_CORREZIONE;
        yy := yy + MainPanelTrasporto.Height;
      end
      else
        MainPanelTrasporto.Visible := False;
      // ---------------------------------------------------------------------------------------------------
      // ---------------------------------- MAIN PANEL ANNOTAZIONI ----------------------------------------
      PanelNote.Tag := LO.ReadInteger(Sezione, 'V_Note', 2);
      PanelMessaggi.Tag := LO.ReadInteger(Sezione, 'V_Messaggi', 2);
      PanelArgomento.Tag := LO.ReadInteger(Sezione, 'V_Argomento', 1);
      // Se almeno uno dei sottopannelli è attivato, rende visibile il MainPanel
      if (PanelNote.Tag > 0) or (PanelMessaggi.Tag > 0) or (PanelArgomento.Tag > 0) then
      begin
        SubYY := SUBPANEL_TOP;
        // SUB-PANEL NOTE e SUB-PANEL MESSAGGI
        if PanelNote.Tag > 0 then
        begin
          // SubPanel Note
          PanelNote.Top := SubYY;
          PanelNote.Visible := True;
          Inc(SubYY, PanelNote.Height);
        end
        else
          PanelNote.Visible := False;
        // SUB-PANEL MESSAGGI
        if PanelMessaggi.Tag > 0 then
        begin
          PanelMessaggi.Top := SubYY;
          PanelMessaggi.Visible := True;
          SubYY := SubYY + PanelMessaggi.Height;
        end
        else
          PanelMessaggi.Visible := False;
        // SUB-PANEL ARGOMENTO
        if PanelArgomento.Tag > 0 then
        begin
          PanelArgomento.Top := SubYY;
          PanelArgomento.Visible := True;
          SubYY := SubYY + PanelArgomento.Height;
        end
        else
          PanelArgomento.Visible := False;
        // Attiva il MainPanel
        yy := yy + Sep;
        PanelAnnotazioni.Top := yy - PanelLower.Top;
        PanelAnnotazioni.Visible := True;
        PanelAnnotazioni.Height := SubYY + SUBPANEL_FATTORE_CORREZIONE;
        yy := yy + PanelAnnotazioni.Height;
      end
      else
        PanelAnnotazioni.Visible := False;
      // ---------------------------------------------------------------------------------------------------
      // ----- PANEL OPERATORE -----
      PanelOperatore.Tag := LO.ReadInteger(Sezione, 'V_Operatore', 2);
      if PanelOperatore.Tag > 0 then
      begin
        yy := yy + Sep;
        PanelOperatore.Top := yy - PanelLower.Top;
        PanelOperatore.Visible := True;
        yy := yy + PanelOperatore.Height;
      end
      else
        PanelOperatore.Visible := False;
      // ----- PANEL PRATICHE -----
      PanelPratiche.Visible := False;
      if LO.ReadBool(Sezione, 'V_Pratiche', False) then
      begin
        yy := yy + Sep;
        PanelPratiche.Top := yy - PanelLower.Top;
        PanelPratiche.Visible := True;
        yy := yy + PanelPratiche.Height;
      end
      else
        PanelPratiche.Visible := False;
      // ----- TESTI -----
      if (TipoDoc = 'Preventivo') and ((DM1.TableProgressiviABILITASTARTPREVENTIVO.AsString = 'T') or (DM1.TableProgressiviABILITAENDPREVENTIVO.AsString = 'T'))
      then
      begin
        yy := yy + Sep;
        PanelTesti.Top := yy - PanelLower.Top;
        PanelTesti.Visible := True;
        yy := yy + PanelTesti.Height;
        DBMStartPreventivo.Enabled := DM1.TableProgressiviABILITASTARTPREVENTIVO.AsString = 'T';
        DBMEndPreventivo.Enabled := DM1.TableProgressiviABILITAENDPREVENTIVO.AsString = 'T';
      end
      else
      begin
        DBMStartPreventivo.Enabled := False;
        DBMEndPreventivo.Enabled := False;
        PanelTesti.Visible := False;
      end;

      // Carica il parametro che indica il tipo di chiusura da effettuare
      fChiusuraTipo := LO.ReadInteger(TipoDoc, 'S_ChiusuraTipo', 0);

      // Imposta il range della scrollbar verticale
      DocClientArea.VertScrollBar.Range := yy + 3;
      DocClientArea.VertScrollBar.Position := 0;

      // =======================================================================
      // DIMENSIONAMENTO DEL PANEL CHE COMPRENDE TUTTA LA PARTE INFERIORE DEL
      // DOCUMENTO
      // -----------------------------------------------------------------------
      PanelLower.Height := yy - PanelLower.Top;
      // =======================================================================

      // =======================================================================
      // ABILITAZIONE O MENO DEL BOTTONE PER RENDERE I RICHI RIGHI COMPOSTI
      // E PER LA SCELTA DELLA BODYVIEW (Preventivi)
      // -----------------------------------------------------------------------
      // LIsPreventivo := (TipoDoc = 'Preventivo') or (TipoDoc = 'Intervento');
      LIsPreventivo := not DistintaBase;
      // Sempre visibili su qualunque tipo di documento (scelto insieme ad Andrea il 15/01/2019)
      spRigoComposto.Visible := LO.ReadBool(Sezione, 'V_ButtonCreaRighiComposti', LIsPreventivo);
      cbBodyView.Visible := LO.ReadBool(Sezione, 'V_BodyViewSelection', LIsPreventivo);
      LabelBodyView.Visible := cbBodyView.Visible;
      // =======================================================================

      // Imposta la BodyView predefinita
      if fFirstCaricaLayoutDocumento then
      begin
        fFirstCaricaLayoutDocumento := False;
        if DistintaBase then
          BodyView := TBodyView(LO.ReadInteger(Sezione, 'V_DefaultBodyView', Ord(TBodyView.vacExt2)))
        else
          BodyView := TBodyView(LO.ReadInteger(Sezione, 'V_DefaultBodyView', Ord(TBodyView.vacNormale)));
      end;

    end;

    // Proprietà che se messa a True fa in modo che alla prossima chiamata della procedure
    // CaricaLayoutDocumento  non vengano rielaborate le impostazioni delle colonne del documento
    // in modo da velocizzare un pò l'esecuzione.
    if CaricaLayoutDocumento_NotLoadColumnSettingsNextTime then
      Exit;

    // Il valore di default per StmSezTotaliDoc viene caricato direttamente dal file ini invece
    // che dedotto dall'abilitazione o meno dei piedi del documento. Quindi è stato spostato qui
    StmSezTotaliDoc.Checked := LO.ReadBool(Sezione, 'V_StampaTotali', True);

    // -------------------------------------------------------------------------------------------
    // -------------------------------------------------------------------------------------------
    // IMPOSTAZIONE COLONNE
    // -------------------------------------------------------------------------------------------
    // Prima carica le dimensioni delle colonne
    // DM1.RipristinaDevExpress(GridCorpo, TipoDoc, False);
    DM1.RipristinaDevExpPropertiesStore(PropertiesStore, 'CorpoDoc_' + TipoDoc, False);

    tvCorpo.DataController.BeginUpdate;
    try
      // NB: Uso la proprietà 'Tag' della colonna per memorizzarci il tipo di abilitazione
      // della colonna e per poi vedere se deve visualizzarne il titolo della colonna stessa
      // su sfondo diverso in base a se sarà una colonna che andrà anche in stampa oppure no.
      if DM1.TableProgressiviDOCCOLONNAIMPEXP.AsString = 'F' then
        tvCorpoMOVMAG.Tag := 0
      else
        tvCorpoMOVMAG.Tag := 1;
      tvCorpoCODICEMAGAZZINO.Tag := LO.ReadInteger(Sezione, 'Col_CodiceMagazzino_New', 0);
      tvCorpoCODICEMAGAZZINO2.Tag := LO.ReadInteger(Sezione, 'Col_CodiceMagazzino_New', 0);

      // NB: Per il codice articolo principale la visualizzazione o meno dipende dalla proprietà
      // Checked del MenuItem che determina se tale colonna deve essere visibile o meno
      // NB: Il default però lo da il valore dell'apposito check nei parametri e progressivi
      if DM1.TableProgressiviDOCGESTARTFORNSECONDARI.AsString = 'T' then
        tvCorpoCODICEARTICOLO.Tag := 1
      else
        tvCorpoCODICEARTICOLO.Tag := 0;
      Mostralacolonnadelcodicearticoloreale1.Checked := (tvCorpoCODICEARTICOLO.Tag <> 0);

      tvCorpoCODICEARTICOLOSTM.Tag := LO.ReadInteger(Sezione, 'Col_CodiceArticolo', 2);
      tvCorpoDESCRIZIONE.Tag := LO.ReadInteger(Sezione, 'Col_Descrizione', 2);
      tvCorpoPREZZOUNITARIO.Tag := LO.ReadInteger(Sezione, 'Col_PrezzoUnitario', 2);
      tvCorpoPREZZOUNITARIOIVACOMPRESA.Tag := LO.ReadInteger(Sezione, 'Col_PrezzoUnitarioIVACompresa', 0);
      tvCorpoPRZUNITNETTO.Tag := LO.ReadInteger(Sezione, 'Col_PrzUnitNetto', 0);
      tvCorpoUNITADIMISURA.Tag := LO.ReadInteger(Sezione, 'Col_UnitaDiMisura', 2);
      tvCorpoQTA.Tag := LO.ReadInteger(Sezione, 'Col_QTA', 2);
      tvCorpoQTAINEVASIONE.Tag := LO.ReadInteger(Sezione, 'Col_QTAInEvasione', IfThen(  Leftstr(Sezione,3) = 'Ord'  , 1, 0));
      tvCorpoQTAEVASA.Tag := LO.ReadInteger(Sezione, 'Col_QTAEvasa', IfThen(  Leftstr(Sezione,3) = 'Ord'  , 1, 0));
      tvCorpoQTADAEVADERE.Tag := LO.ReadInteger(Sezione, 'Col_QTADaEvadere', IfThen(  Leftstr(Sezione,3) = 'Ord'  , 1, 0));
      tvCorpoSCONTORIGO.Tag := LO.ReadInteger(Sezione, 'Col_ScontoRigo1', 2);
      tvCorpoSCONTORIGO2.Tag := LO.ReadInteger(Sezione, 'Col_ScontoRigo2', 2);
      tvCorpoSCONTORIGO3.Tag := LO.ReadInteger(Sezione, 'Col_ScontoRigo3', 2);
      tvCorpoIMPORTORIGO.Tag := LO.ReadInteger(Sezione, 'Col_ImportoRigo', 2);
      tvCorpoIMPORTORIGOIVACOMPRESA.Tag := LO.ReadInteger(Sezione, 'Col_ImportoRigoIVACompresa', 0);
      tvCorpoDESCRIZIONEIVA.Tag := LO.ReadInteger(Sezione, 'Col_DescrizioneIVA', 2);
      tvCorpoNOTERIGO.Tag := LO.ReadInteger(Sezione, 'Col_NoteRigo', 0);
      tvCorpoPREZZOACQUISTOARTICOLO.Tag := LO.ReadInteger(Sezione, 'Col_PrezzoAcquistoArticolo', 1);
      tvCorpoIMPORTOMARGINE.Tag := LO.ReadInteger(Sezione, 'Col_ImportoMargine', 1);
      tvCorpoMARGINE.Tag := LO.ReadInteger(Sezione, 'Col_Margine', 1);
      tvCorpoSELEZIONATO.Tag := LO.ReadInteger(Sezione, 'Col_Selezionato', 0);
      tvCorpoSOTTOCANTIERE1.Tag := LO.ReadInteger(Sezione, 'Col_Sottocantiere1', 0);
      tvCorpoSOTTOCANTIERE2.Tag := LO.ReadInteger(Sezione, 'Col_Sottocantiere2', 0);
      tvCorpoSOTTOCANTIERE3.Tag := LO.ReadInteger(Sezione, 'Col_Sottocantiere3', 0);
      tvCorpoSOTTOCANTIERE4.Tag := LO.ReadInteger(Sezione, 'Col_Sottocantiere4', 0);
      tvCorpoSOTTOCANTIERE5.Tag := LO.ReadInteger(Sezione, 'Col_Sottocantiere5', 0);
      tvCorpoSOTTOCANTIERE6.Tag := LO.ReadInteger(Sezione, 'Col_Sottocantiere6', 0);
      tvCorpoTIPO1.Tag := LO.ReadInteger(Sezione, 'Col_Tipo1', 0);
      tvCorpoTIPO2.Tag := LO.ReadInteger(Sezione, 'Col_Tipo2', 0);
      tvCorpoTIPO3.Tag := LO.ReadInteger(Sezione, 'Col_Tipo3', 0);
      tvCorpoTIPO4.Tag := LO.ReadInteger(Sezione, 'Col_Tipo4', 0);
      tvCorpoTIPO5.Tag := LO.ReadInteger(Sezione, 'Col_Tipo5', 0);
      tvCorpoTIPO6.Tag := LO.ReadInteger(Sezione, 'Col_Tipo6', 0);
      tvCorpoIDAPPARECCHIO.Tag := LO.ReadInteger(Sezione, 'Col_IdApparecchio', 0);
      tvCorpoIDOPIMPEGNO.Tag := LO.ReadInteger(Sezione, 'Col_IdOpImpegno', 0);
      tvCorpoPREZZOUNITARIOAUTOCALC.Tag := LO.ReadInteger(Sezione, 'Col_PrezzoUnitarioAutoCalc', 1);
      tvCorpoROWTYPE.Tag := LO.ReadInteger(Sezione, 'Col_RowType', 1);
      tvCorpoROWPRINTPRICES.Tag := LO.ReadInteger(Sezione, 'Col_RowPrintPrices', 1);
      tvCorpoROWSECTION.Tag := LO.ReadInteger(Sezione, 'Col_RowSection', 1);
      tvCorpoADG1_TIPODATO.Tag := LO.ReadInteger(Sezione, 'Col_ADG1_TipoDato', IfThen(  DM1.IsFatturaEletronica(Sezione)  , 1, 0));
      tvCorpoADG1_RIFERIMENTOTESTO.Tag := LO.ReadInteger(Sezione, 'Col_ADG1_RiferimentoTesto', IfThen(  DM1.IsFatturaEletronica(Sezione)  , 1, 0));
      tvCorpoADG1_RIFERIMENTONUMERO.Tag := LO.ReadInteger(Sezione, 'Col_ADG1_RiferimentoNumero', IfThen(  DM1.IsFatturaEletronica(Sezione)  , 1, 0));
      tvCorpoADG1_RIFERIMENTODATA.Tag := LO.ReadInteger(Sezione, 'Col_ADG1_RiferimentoData', IfThen(  DM1.IsFatturaEletronica(Sezione)  , 1, 0));
      // Se è una distinta base forza alcune colonne all'invisibilità
      if DistintaBase then
      begin
        tvCorpoROWSECTION.Tag := 0;
        tvCorpoROWTYPE.Tag := 0;
        tvCorpoROWPRINTPRICES.Tag := 0;
        tvCorpoPREZZOUNITARIOAUTOCALC.Tag := 0;
      end;

      // Cicla per tutte le colonne meno l'ultima (-2) perchè è la colonna SAVED che è solo un flag
      // indica se la colonna è stata salvata oppure no e viene usata solo dirante il salvataggio
      // dei righi del documento.
      // NB: La colonna SAVED deve rimanere sempre l'ultima
      for Contatore := 0 to tvCorpo.ItemCount - 1 do
      begin
        // Se la colonna è abilitata la rende visibile
        if tvCorpo.Items[Contatore].Tag > 0 then
        begin
          tvCorpo.Items[Contatore].Visible := True;
          tvDiBa.Items[Contatore].Visible := True;
          // Per le colonne textEdit imposta la lunghezza massima editabile
          if tvCorpo.Items[Contatore].Properties is TcxTextEditProperties then
          begin
            TmpStr := tvCorpo.Items[Contatore].Name;
            TmpStr := RightStr(TmpStr, Length(TmpStr) - 7); // Elimina "tvCorpo"
            TcxTextEditProperties(tvCorpo.Items[Contatore].Properties).MaxLength := WidthRighi.FieldByName(TmpStr).DisplayWidth;
            TcxTextEditProperties(tvDiBa.Items[Contatore].Properties).MaxLength := WidthRighi.FieldByName(TmpStr).DisplayWidth;
          end;
          // Se la colonna non è abilitata ad essere stampata la fà comparire grigio scuro, altrimenti normale
          // if tvCorpo.Items[Contatore].Tag < 2 then tvCorpo.Columns[Contatore].Styles.Content := DM1.tvGrayContent else tvCorpo.Items[Contatore].Styles.Content := nil;
        end
        else
        begin
          // Se la colonna non è abilitata la rende invisibile
          tvCorpo.Items[Contatore].Visible := False;
          tvDiBa.Items[Contatore].Visible := False;
        end;
      end;
      // La descrizione è particolare perchè si può cmq impostare una lunghezza massima nei parametri
      // che prende il sopravvento rispetto alla linghezza del campo nel DB
      if DM1.LunghezzaMaxDescrizioneArticolo = 0 then
        TcxTextEditProperties(tvCorpoDESCRIZIONE.Properties).MaxLength := WidthRighiDESCRIZIONE.DisplayWidth
      else
        TcxTextEditProperties(tvCorpoDESCRIZIONE.Properties).MaxLength := DM1.LunghezzaMaxDescrizioneArticolo;
      TcxTextEditProperties(tvDiBaDESCRIZIONE.Properties).MaxLength := TcxTextEditProperties(tvCorpoDESCRIZIONE.Properties).MaxLength;
      // Fà in modo che i sottorighi ereditino le stesse impostazioni delle colonne della MasterView
      RefreshImpostazioniColonne;
    finally
      tvCorpo.DataController.EndUpdate;
      // Apre la form a sx che contiene i dati del rigo corrente
      // NB: Solo se non siamo in una Distinta Base
      if not DistintaBase then
        OpenDatiRigoForm;
      // Abilita o disabilita i campi dei dati rigo nella form laterale
      EnableDisableDatiFormFields;
    end;
    // -------------------------------------------------------------------------------------------
  finally
    LO.Free;
    // Proprietà che se messa a True fa in modo che alla prossima chiamata della procedure
    // CaricaLayoutDocumento non vengano rielaborate le impostazioni delle colonne del documento
    // in modo da velocizzare un pò l'esecuzione.
    if not CaricaLayoutDocumento_NotLoadColumnSettingsNextTime then
    begin
      // Resetta il flag
      CaricaLayoutDocumento_NotLoadColumnSettingsNextTime := False;
      // Se siamo in fatturazione differita non carica le preferenze di stampa perchè
      // altrimenti da un errore Dataset is closed
      if Self.Tag <> MODE_FATTURAZIONE_DIFFERITA then
      begin
        // Inizializzazione pannello delle preferenze di stampa
        StmPref_Initialize;
        // Carica le preferenze precedentemente salvate
        StmPref_LoadPreferences;
      end;
    end;
  end;
end;

procedure TPreventiviOrdiniForm.CaricaNotificheFE;
var
  Qry: TIB_Cursor;
  i: Integer;
  DC: TcxCustomDataController;
  LResponseType: String;
  LBlobStream: TStream;
  LStringStream: TStringStream;
begin
  // Se non sono stati già caricati carica i dati dei documento correlati
  // if TabNotifiche.Tag = 1 then
  // Exit;
  // Inizializzazione
  DC := btvNotifiche.DataController;
  DC.RecordCount := 0;
  // Crea l'oggetto Qry
  Qry := TIB_Cursor.Create(Self);
  Qry.DatabaseName := DM1.ArcDBFile;
  Qry.IB_Connection := DM1.DBAzienda;
  DM1.ShowWait('', 'Carico le notifiche (fattura elettronica)');
  try
    DC.BeginFullUpdate;
    // Imposta la query
    Qry.SQL.Add('SELECT FE.*, C.TIPOPERSONA FROM PRVORDCL_FE FE');
    Qry.SQL.Add
      ('LEFT OUTER JOIN PRVORDCL T ON (T.TIPODOCUMENTO=FE.TIPODOC AND T.REGISTRO=FE.REGDOC AND T.NUMORDPREV=FE.NUMDOC AND T.DATADOCUMENTO=FE.DATADOC)');
    Qry.SQL.Add('LEFT OUTER JOIN CLIENTI C ON (C.CODICE=T.CODICECLIENTE)');
    Qry.SQL.Add('WHERE FE.TipoDoc = ''' + TipoDoc + '''');
    Qry.SQL.Add('AND FE.RegDoc = ''' + Registro + '''');
    Qry.SQL.Add('AND FE.NumDoc = ' + IntToStr(NumeroDoc));
    Qry.SQL.Add('AND FE.DataDoc = ''' + FormatDateTime('mm/dd/yyyy', DataDoc) + '''');
    Qry.Open;
    // Cicla per tutti records trovati
    while not Qry.Eof do
    begin
      i := DC.AppendRecord;
      DC.Values[i, btvNotificheID.Index] := Qry.FieldByName('ID').Value;
      DC.Values[i, btvNotificheResponseDate.Index] := Qry.FieldByName('RESPONSEDATE').Value;
      DC.Values[i, btvNotificheNotificationDate.Index] := Qry.FieldByName('NOTIFICATIONDATE').Value;
      DC.Values[i, btvNotificheFileName.Index] := Qry.FieldByName('FILENAME').Value;
      DC.Values[i, btvNotificheMsgCode.Index] := Qry.FieldByName('MSGCODE').Value;
      DC.Values[i, btvNotificheMsgText.Index] := Qry.FieldByName('MSGTEXT').Value;
      // ===========================================================================================
      // BLOCCO PER IL CARICAMENTO DEL MSGRAW, L'HO MESSO CON GLI STREAM E CON ENCODING UTF-8 PER SICUREZZA
      // -------------------------------------------------------------------------------------------
      // DC.Values[i, btvNotificheMsgRAW.Index] := Qry.FieldByName('MSGRAW').Value;  // OLD CODE
      try
        LBlobStream := Qry.CreateBlobStream(Qry.FieldByName('MSGRAW'), TIB_BlobStreamMode.bsmRead);
        LStringStream := TStringStream.Create('', TeiUTFEncodingWithoutBOM.Create);
        LStringStream.CopyFrom(LBlobStream, 0);
        DC.Values[i, btvNotificheMsgRAW.Index] := LStringStream.DataString;
      finally
        if Assigned(LBlobStream) then
          LBlobStream.Free;
        if Assigned(LStringStream) then
          LStringStream.Free;
      end;
      // ===========================================================================================
      DC.Values[i, btvNotificheDone.Index] := Qry.FieldByName('DONE').Value;
      DC.Values[i, btvNotificheHide.Index] := Qry.FieldByName('HIDE').Value;
      // Determina il tipo di respnse (lo stato della fattura in base anche al tipo cliente (PA oppure no)
      LResponseType := Qry.FieldByName('RESPONSETYPE').AsString;
      if (Qry.FieldByName('TIPOPERSONA').AsString = 'P') and ((LResponseType = 'rtSDIMessageRC') or (LResponseType = 'rtSDIMessageMC')) then
        LResponseType := LResponseType + '_PA';
      DC.Values[i, btvNotificheTipo.Index] := LResponseType;
      // Avanti il prossimo
      Qry.Next;
    end;
    // SI annota nel Tag del TabSheet che il caricamento è avvenuto
    // TabNotifiche.Tag := 1;
  finally
    DC.EndFullUpdate;
    DM1.CloseWait;
    // Distrugge l'oggetto Qry
    Qry.Free;
  end;
end;

// Abilita/Disabilita i campi della form laterale contenente i dati del rigo
// in base all'attivazione o meno delle colonne nel corpo documento.
procedure TPreventiviOrdiniForm.EnableDisableDatiFormFields;
begin
  if not Assigned(DatiRigoForm) then
    Exit;
  DatiRigoForm.iCodiceArticolo.Visible := tvCorpoCODICEARTICOLOSTM.Visible;
  DatiRigoForm.iDescrizione.Visible := tvCorpoDESCRIZIONE.Visible;
  DatiRigoForm.iPrezzoUnitario.Visible := tvCorpoPREZZOUNITARIO.Visible;
  DatiRigoForm.iPrzUnitIvaComp.Visible := tvCorpoPREZZOUNITARIOIVACOMPRESA.Visible;
  DatiRigoForm.iSconto1.Visible := tvCorpoSCONTORIGO.Visible;
  DatiRigoForm.iSconto2.Visible := tvCorpoSCONTORIGO2.Visible;
  DatiRigoForm.iSconto3.Visible := tvCorpoSCONTORIGO3.Visible;
  DatiRigoForm.iUM.Visible := tvCorpoUNITADIMISURA.Visible;
  DatiRigoForm.iQta.Visible := tvCorpoQTA.Visible;
  DatiRigoForm.iImportoRigo.Visible := tvCorpoIMPORTORIGO.Visible;
  DatiRigoForm.iImportoRigoIvaComp.Visible := tvCorpoIMPORTORIGOIVACOMPRESA.Visible;
  DatiRigoForm.iDescrizioneIVA.Visible := tvCorpoDESCRIZIONEIVA.Visible;
  DatiRigoForm.iCostoUnitario.Visible := tvCorpoPREZZOACQUISTOARTICOLO.Visible;
  DatiRigoForm.iRicarico.Visible := tvCorpoMARGINE.Visible;
  DatiRigoForm.iRicaricoImporto.Visible := tvCorpoIMPORTOMARGINE.Visible;

  DatiRigoForm.iIdApparecchio.Visible := tvCorpoIDAPPARECCHIO.Visible;

  DatiRigoForm.iSottocantiere1.Visible := tvCorpoSOTTOCANTIERE1.Visible;
  DatiRigoForm.iSottocantiere2.Visible := tvCorpoSOTTOCANTIERE2.Visible;
  DatiRigoForm.iSottocantiere3.Visible := tvCorpoSOTTOCANTIERE3.Visible;
  DatiRigoForm.iSottocantiere4.Visible := tvCorpoSOTTOCANTIERE4.Visible;
  DatiRigoForm.iSottocantiere5.Visible := tvCorpoSOTTOCANTIERE5.Visible;
  DatiRigoForm.iSottocantiere6.Visible := tvCorpoSOTTOCANTIERE6.Visible;

  DatiRigoForm.iTipo1.Visible := tvCorpoTIPO1.Visible;
  DatiRigoForm.iTipo2.Visible := tvCorpoTIPO2.Visible;
  DatiRigoForm.iTipo3.Visible := tvCorpoTIPO3.Visible;
  DatiRigoForm.iTipo4.Visible := tvCorpoTIPO4.Visible;
  DatiRigoForm.iTipo5.Visible := tvCorpoTIPO5.Visible;
  DatiRigoForm.iTipo6.Visible := tvCorpoTIPO6.Visible;

  DatiRigoForm.iNoteRigo.Visible := tvCorpoNOTERIGO.Visible;

  DatiRigoForm.iRowSection.Visible := tvCorpoROWSECTION.Visible;
  DatiRigoForm.iRowType.Visible := tvCorpoROWTYPE.Visible;
  DatiRigoForm.iPrezzoUnitarioAutocalc.Visible := tvCorpoPREZZOUNITARIOAUTOCALC.Visible;
  DatiRigoForm.iRowPrintPrices.Visible := tvCorpoROWPRINTPRICES.Visible;

  DatiRigoForm.iADG_TipoDato.Visible := tvCorpoADG1_TIPODATO.Visible;
  DatiRigoForm.iADG_RiferimentoTesto.Visible := tvCorpoADG1_RIFERIMENTOTESTO.Visible;
  DatiRigoForm.iADG_RiferimentoNumero.Visible := tvCorpoADG1_RIFERIMENTONUMERO.Visible;
  DatiRigoForm.iADG_RiferimentoData.Visible := tvCorpoADG1_RIFERIMENTODATA.Visible;

  // Carica alcune etichette personalizzabili
  DatiRigoForm.iSottocantiere1.Caption := tvCorpoSOTTOCANTIERE1.Caption;
  DatiRigoForm.iSottocantiere2.Caption := tvCorpoSOTTOCANTIERE2.Caption;
  DatiRigoForm.iSottocantiere3.Caption := tvCorpoSOTTOCANTIERE3.Caption;
  DatiRigoForm.iSottocantiere4.Caption := tvCorpoSOTTOCANTIERE4.Caption;
  DatiRigoForm.iSottocantiere5.Caption := tvCorpoSOTTOCANTIERE5.Caption;
  DatiRigoForm.iSottocantiere6.Caption := tvCorpoSOTTOCANTIERE6.Caption;
  DatiRigoForm.iTipo1.Caption := tvCorpoTIPO1.Caption;
  DatiRigoForm.iTipo2.Caption := tvCorpoTIPO2.Caption;
  DatiRigoForm.iTipo3.Caption := tvCorpoTIPO3.Caption;
  DatiRigoForm.iTipo4.Caption := tvCorpoTIPO4.Caption;
  DatiRigoForm.iTipo5.Caption := tvCorpoTIPO5.Caption;
  DatiRigoForm.iTipo6.Caption := tvCorpoTIPO6.Caption;

  // Imposta le lunghezze massime dei campi
  DatiRigoForm.eCodiceArticolo.Properties.MaxLength := (tvCorpoCODICEARTICOLO.Properties as TcxCustomTextEditProperties).MaxLength;
  DatiRigoForm.eDescrizione.Properties.MaxLength := (tvCorpoDESCRIZIONE.Properties as TcxCustomMemoProperties).MaxLength;
  DatiRigoForm.eUM.Properties.MaxLength := (tvCorpoUNITADIMISURA.Properties as TcxCustomTextEditProperties).MaxLength;
  DatiRigoForm.eNoteRigo.Properties.MaxLength := (tvCorpoNOTERIGO.Properties as TcxCustomTextEditProperties).MaxLength;
  DatiRigoForm.eADG_TipoDato.Properties.MaxLength := (tvCorpoADG1_TIPODATO.Properties as TcxCustomTextEditProperties).MaxLength;
  DatiRigoForm.eADG_Riferimentotesto.Properties.MaxLength := (tvCorpoADG1_RIFERIMENTOTESTO.Properties as TcxCustomTextEditProperties).MaxLength;

  // Ne imposta anche il DisplayFormat
  DatiRigoForm.ePrezzoUnitario.Properties.DisplayFormat := DM1.DisplayFormat;
  DatiRigoForm.ePrzUnitIvaComp.Properties.DisplayFormat := DM1.DisplayFormat;
  DatiRigoForm.eImportoRigo.Properties.DisplayFormat := DM1.DisplayFormat;
  DatiRigoForm.eImportoRigoIvaComp.Properties.DisplayFormat := DM1.DisplayFormat;
  DatiRigoForm.eCostoUNitario.Properties.DisplayFormat := DM1.DisplayFormat;
  DatiRigoForm.eRicaricoImporto.Properties.DisplayFormat := DM1.DisplayFormat;
  // IMposta il numero dei decimali dei campi Currency
  DatiRigoForm.ePrezzoUnitario.Properties.DecimalPlaces := DM1.DecMicroPrz;
  DatiRigoForm.ePrzUnitIvaComp.Properties.DecimalPlaces := DM1.DecMicroPrz;
  DatiRigoForm.eImportoRigo.Properties.DecimalPlaces := DM1.DecMicroPrz;
  DatiRigoForm.eImportoRigoIvaComp.Properties.DecimalPlaces := DM1.DecMicroPrz;
  DatiRigoForm.eCostoUNitario.Properties.DecimalPlaces := DM1.DecMicroPrz;
  DatiRigoForm.eRicaricoImporto.Properties.DecimalPlaces := DM1.DecMicroPrz;
end;

procedure TPreventiviOrdiniForm.BeginUpdate;
begin
  tvCorpo.DataController.BeginUpdate;;
  FSospendiCalcoloTotali := True;
  fModificandoDaDatiRigoForm := True;
end;

procedure TPreventiviOrdiniForm.EndUpdate;
begin
  FSospendiCalcoloTotali := False;
  fModificandoDaDatiRigoForm := False;
  CalcolaTotali(False);
  tvCorpo.DataController.EndUpdate;;
  AggiornaDatiRigoForm(QryDocumento);
end;

procedure TPreventiviOrdiniForm.LoadDetailRows(MasterRow: Longint; MasterCodArt: String; CodMag: String);
var
  DetDataController, DCT: TcxCustomDataController;
  DetCodArt, DetCodArtStm: String;
  Y, yy: Integer;
  Qry, Qry2: TIB_Cursor;
  ManIndex: Byte;
begin
  // DetDataController punta alla TableView Detail del rigo
  DetDataController := tvCorpo.DataController.GetDetailDataController(MasterRow, RELATION_IDX_SOTTORIGHI_NORMALI);
  // Blocca il painting della griglia sullo schermo per velocizzare l'esecuzione dei calcoli
  DetDataController.BeginUpdate;
  try
    // Crea Qry
    Qry := TIB_Cursor.Create(Self);
    Qry.DatabaseName := DM1.ArcDBFile;
    Qry.IB_Connection := DM1.DBAzienda;
    Qry2 := TIB_Cursor.Create(Self);
    Qry2.DatabaseName := DM1.ArcDBFile;
    Qry2.IB_Connection := DM1.DBAzienda;
    // IMposta la query che ricerca i righi che fanno parte della DistintaBase dell'articolo Master
    Qry.SQL.Add('SELECT R.CodiceArticolo, R.CodiceArticoloStm, R.Descrizione, R.UnitaDiMisura, R.Qta, R.PrezzoUnitario, R.PrezzoAcquistoArticolo, R.Margine,');
    Qry.SQL.Add(' A.PrezzoDiVendita, A.PrezzoDiVendita2, A.PrezzoDiVendita3, A.PrezzoDiVendita4, A.CodiceIVA, A.ScortaMinima, A.AbilitaMovMag,');
    Qry.SQL.Add(' A.Ricarico, A.Ricarico2, A.Ricarico3, A.Ricarico4, A.MinutiPrevisti,');
    Qry.SQL.Add(' (SELECT SUM(DISPONIBILE)   FROM MAGAZZINI WHERE CODICEARTICOLO = R.CodiceArticolo AND CODICEMAGAZZINO = ' + CodMag + ') AS DISPONIBILE');
    Qry.SQL.Add('FROM DIBARIGHI R');
    Qry.SQL.Add('LEFT JOIN ARTICOLI A ON (A.CODICEARTICOLO = R.CODICEARTICOLO)');
    Qry.SQL.Add('WHERE R.TIPODOCUMENTO = ''' + MasterCodArt + '''');
    Qry.Open;
    // Azzera il contenuto della View
    DetDataController.RecordCount := 0;
    // Cicla per tutti i righi distinta trovati
    while not Qry.Eof do
    begin
      // Carica i codici articolo del sottoarticolo attuale in alcune variabili per comodità
      DetCodArt := Qry.FieldByName('CODICEARTICOLO').AsString;
      DetCodArtStm := Qry.FieldByName('CODICEARTICOLOSTM').AsString;
      // Verifica e adattamento dei codici articolo
      if (DetCodArtStm = '') and (DetCodArt <> '') then
        DetCodArtStm := DetCodArt;
      // IMposta ed apre la query che ricava i costi di acquisto e gli sconti dell'articolo (o del sottoarticolo di un fornitore secondario)
      Qry2.Close;
      Qry2.SQL.Clear;
      Qry2.SQL.Add('SELECT PREZZODILISTINO, SCONTODIACQUISTO, SCONTODIACQUISTO2, SCONTODIACQUISTO3, COSTOREALE, ULTIMOPRZACQUISTO');
      Qry2.SQL.Add('FROM DOC_NUOVO_RIGO_DOCUMENTO(' + QuotedStr(DetCodArt) + ',' + QuotedStr(DetCodArtStm) + ',' + '''F'')');
      Qry2.Open;
      // Esegue l'append di un nuovo rigo
      Y := DetDataController.AppendRecord;
      // Imposta l'ORDER del nuovo sottorigo
      DetDataController.Values[Y, tvCorpoORDER.Index] := Y + 1;
      // Prima di tutto imposta il magazzino che il rigo deve movimentare
      DetDataController.Values[Y, tvCorpoCODICEMAGAZZINO.Index] := QryDocumentoCODICEMAGAZZINO.AsString;
      // Inizia ad importare l'articolo
      DetDataController.Values[Y, tvCorpoCODICEARTICOLO.Index] := Qry.FieldByName('CodiceArticolo').AsString;
      DetDataController.Values[Y, tvCorpoCODICEARTICOLOSTM.Index] := Qry.FieldByName('CodiceArticoloStm').AsString;
      DetDataController.Values[Y, tvCorpoDESCRIZIONE.Index] := Qry.FieldByName('Descrizione').AsString;
      DetDataController.Values[Y, tvCorpoUNITADIMISURA.Index] := Qry.FieldByName('UnitaDiMisura').AsString;
      DetDataController.Values[Y, tvCorpoQTA.Index] := Qry.FieldByName('Qta').AsFloat;
      DetDataController.Values[Y, tvCorpoMINUTIPREVISTI.Index] := Qry.FieldByName('MinutiPrevisti').AsFloat;

      // Se è un rigo di manodopera ne carica i prezzi e il costo attuale
      if DM1.CodiceIsManodopera(DetCodArt) then
      begin
        // Ricava l'indice del tipo di manodopera a cui il rigo fa riferimento
        ManIndex := DM1.CodiceToIndexManodopera(DetCodArt);
        // Assegna il prezzo della manodopera appropriata
        // NB: Se è un documento di acquisto carica il costo come prezzo unitario
        if DM1.IsDocumentoDiIngresso(TipoDoc) then
        begin
          DetDataController.Values[Y, tvCorpoPREZZOUNITARIO.Index] := QryDocumentoCOSTOUNITOPERA.AsCurrency;
          DetDataController.Values[Y, tvCorpoPREZZOACQUISTOARTICOLO.Index] := QryDocumentoCOSTOUNITOPERA.AsCurrency;
        end
        else
        begin
          case ManIndex of
            0:
              begin
                DetDataController.Values[Y, tvCorpoPREZZOUNITARIO.Index] := QryDocumentoPRZUNITOPERA.AsCurrency;
                DetDataController.Values[Y, tvCorpoPREZZOACQUISTOARTICOLO.Index] := QryDocumentoCOSTOUNITOPERA.AsCurrency;
              end;
            1:
              begin
                DetDataController.Values[Y, tvCorpoPREZZOUNITARIO.Index] := QryDocumentoPRZUNITOPERA1.AsCurrency;
                DetDataController.Values[Y, tvCorpoPREZZOACQUISTOARTICOLO.Index] := QryDocumentoCOSTOUNITOPERA1.AsCurrency;
              end;
            2:
              begin
                DetDataController.Values[Y, tvCorpoPREZZOUNITARIO.Index] := QryDocumentoPRZUNITOPERA2.AsCurrency;
                DetDataController.Values[Y, tvCorpoPREZZOACQUISTOARTICOLO.Index] := QryDocumentoCOSTOUNITOPERA2.AsCurrency;
              end;
            3:
              begin
                DetDataController.Values[Y, tvCorpoPREZZOUNITARIO.Index] := QryDocumentoPRZUNITOPERA3.AsCurrency;
                DetDataController.Values[Y, tvCorpoPREZZOACQUISTOARTICOLO.Index] := QryDocumentoCOSTOUNITOPERA3.AsCurrency;
              end;
            4:
              begin
                DetDataController.Values[Y, tvCorpoPREZZOUNITARIO.Index] := QryDocumentoPRZUNITOPERA4.AsCurrency;
                DetDataController.Values[Y, tvCorpoPREZZOACQUISTOARTICOLO.Index] := QryDocumentoCOSTOUNITOPERA4.AsCurrency;
              end;
          else
            DetDataController.Values[Y, tvCorpoPREZZOUNITARIO.Index] := QryDocumentoPRZUNITOPERA.AsCurrency;
            DetDataController.Values[Y, tvCorpoPREZZOACQUISTOARTICOLO.Index] := QryDocumentoCOSTOUNITOPERA.AsCurrency;
          end;
        end;
      end
      else
        // Se invece non è un rigo di manodopera e
        // si tratta di un rigo aggiunto manualmente (quindi non c'è alcun articolo nell'archivio articoli)
        // inseirà il prezzo unitario impostato manualmente nella distintabase.
        if Qry2.FieldByName('COSTOREALE').AsFloat > 0 then
        begin
          // Carica i dati dell'articolo
          // Carica il prezzo di acquisto dell'articolo
          DetDataController.Values[Y, tvCorpoPREZZOACQUISTOARTICOLO.Index] := Qry2.FieldByName('COSTOREALE').AsFloat;
          // Se è una bolla di entrata merci oppure una fattura di acquisto importa il prezzo
          // di acquisto (prechè si tratta appunto di acquisti e quindi di carico di magazzino),
          // altrimenti si tratta di documenti di vendita e quinti importa il prezzo di vendita
          // appropriato in base al listino.
          if DM1.IsDocumentoDiIngresso(TipoDoc) then
          begin
            // SePrezziAcquistoNetti = True inserisce direttamente il prezzo netto nel documento altrimenti inserisce
            // Importa il prezzo di acquisto netto altrimenti inserisce il prezzo listino - gli sconti di acquisto.
            if DM1.PrezziAcquistoNetti then
              DetDataController.Values[Y, tvCorpoPREZZOUNITARIO.Index] := DM1.Arrotonda(Qry2.FieldByName('CostoReale').AsFloat, DM1.DecMicroPrz)
            else
            begin
              DetDataController.Values[Y, tvCorpoPREZZOUNITARIO.Index] := DM1.Arrotonda(Qry2.FieldByName('PrezzoDiListino').AsFloat, DM1.DecMicroPrz);
              DetDataController.Values[Y, tvCorpoSCONTORIGO.Index] := Qry2.FieldByName('ScontoDiAcquisto').AsFloat;
              DetDataController.Values[Y, tvCorpoSCONTORIGO2.Index] := Qry2.FieldByName('ScontoDiAcquisto2').AsFloat;
              DetDataController.Values[Y, tvCorpoSCONTORIGO3.Index] := Qry2.FieldByName('ScontoDiAcquisto3').AsFloat;
            end;
          end
          else
          begin
            // In base al listino selezionato importa il prezzo di vendita giusto (Default := Listino1).
            case QryDocumentoLISTINO.AsInteger of
              2:
                DetDataController.Values[Y, tvCorpoPREZZOUNITARIO.Index] := Qry.FieldByName('PrezzoDiVendita2').AsFloat;
              3:
                DetDataController.Values[Y, tvCorpoPREZZOUNITARIO.Index] := Qry.FieldByName('PrezzoDiVendita3').AsFloat;
              4:
                DetDataController.Values[Y, tvCorpoPREZZOUNITARIO.Index] := Qry.FieldByName('PrezzoDiVendita4').AsFloat;
            else
              DetDataController.Values[Y, tvCorpoPREZZOUNITARIO.Index] := Qry.FieldByName('PrezzoDiVendita').AsFloat;
            end;
          end;
        end
        else
        begin
          // Se invece l'articolo non è presente nell'archivio articoli importa i prezzi della Distinta Base
          DetDataController.Values[Y, tvCorpoPREZZOACQUISTOARTICOLO.Index] := Qry.FieldByName('PrezzoAcquistoArticolo').AsFloat;
          DetDataController.Values[Y, tvCorpoPREZZOUNITARIO.Index] := Qry.FieldByName('PrezzoUnitario').AsFloat;
          DetDataController.Values[Y, tvCorpoMARGINE.Index] := Qry.FieldByName('Margine').AsFloat;
        end;
      // Se il codice IVA assegnato nell'anagrafica clienti non è nullo, assegna al
      // rigo la stessa aliquota IVA altrimenti quella dell'anagrafica articoli.
      if DocIvaDefault.IsDefault then
        AssegnaAliquotaIVA(Qry.FieldByName('CodiceIVA').AsInteger, Y, DetDataController)
      else
        AssegnaAliquotaIVA(DocIvaDefault.Codice, Y, DetDataController);
      // Se si è in modalità di scorporo IVA (Quindi emettiamo documenti che devono indicare i prezzi IVA compresa)
      // Calcola subito il prezzo unitario iva compresa, altrimenti appare il rigo senza il prezzo.
      if DM1.ScorporoIVA then
        DetDataController.Values[Y, tvCorpoPREZZOUNITARIOIVACOMPRESA.Index] := DetDataController.Values[Y, tvCorpoPREZZOUNITARIO.Index] +
          DM1.Arrotonda((DetDataController.Values[Y, tvCorpoPREZZOUNITARIO.Index] * DetDataController.Values[Y, tvCorpoALIQUOTAIVA.Index] / 100),
          DM1.DecMicroPrz);
      // Esegue alcuni calcoli per calcolare anche i campi dei totali, margine ecc.
      if DM1.ScorporoIVA then
        CalcolaPerModificaPrezzoUnitarioIVACompresa(Y, DetDataController)
      else
        CalcolaPerModificaPrezzoUnitario(Y, DetDataController);
      CalcolaImportoRigo(DetDataController, Y);
      // Si sposta sul prossimo record
      Qry.Next;
    end;
    Qry.Close;
  finally
    if Assigned(Qry) then
      Qry.Free;
    if Assigned(Qry2) then
      Qry2.Free;
    // Riabilita il painting del componente forzando così l'aggiornamento dello schermo
    DetDataController.EndUpdate;
  end;
end;

// Questa funzione controlla se il codice ricevuto è relativo alla mano d'opera
// e se lo è carica il rigo con i dati della mano d'opera e ritorna True
// altrimenti non fa nulla e ritorna False
function TPreventiviOrdiniForm.NuovoRigoManodopera(CodArt: String; Mode: TAddArtMode): Boolean;
var
  Y, LPrecRowIndex: Integer;
  DC: TcxCustomDataController;
  CurrView: TcxGridTableView;
  ManIndex: Integer;
  Qta: Double;
  LCurrSection: String;
  LCurrOrder: Double;
begin
  // Inizializzazione
  Result := False;
  CodArt := Uppercase(CodArt);
  // Controlla se il cpdice ricevuto è della manodopera e se non lo è esce subito
  if not DM1.CodiceIsManodopera(CodArt) then
    Exit;

  try
    // Se invece continua significa che il codice era proprio della manodopera
    // e quindi continua il carimento dei dati della manodopera
    // --------------------------------------------------------------------------
    // CArica nella variabile l'indice della manodopera voluta
    ManIndex := DM1.CodiceToIndexManodopera(CodArt);

    // DC Punta al DataController che attualmente ha il focus
    CurrView := GridCorpo.FocusedView as TcxGridTableView;
    DC := CurrView.DataController;

    // Y contiene la coordinata Y della cella selezionata
    Y := DC.FocusedRecordIndex;
    // Inoltre se c'è un record selezionato ne estrae la sezione corrente
    // altrimenti no
    if (CurrView = tvCorpo) and (Y <> -1) then
    begin
      LCurrSection := VarToStrDef(DC.Values[Y, tvCorpoROWSECTION.Index], '');
      LCurrOrder := DC.Values[Y, tvCorpoORDER.Index];
    end
    else
    begin
      LCurrSection := '';
      LCurrOrder := 0;
    end;
    // Salva il FocusedRecordIndex corrente per poi ripristinarlo alla fine
    LPrecRowIndex := CurrView.Controller.FocusedRowIndex;

    // Se non c'è alcun record selezionato forza l'Append del nuovo rigo
    // altrimenti dà un errore.
    if DC.FocusedRecordIndex = -1 then
      Mode := AM_Append;

    // In base alla modalità modifica il rigo corrente oppure fà un append o un isert.
    case Mode of
      TAddArtMode.AM_Insert:
        Y := DC.InsertRecord(Y);
      TAddArtMode.AM_Append:
        Y := DC.AppendRecord;
    end;

    // Assegna la sezione corrente
    DC.Values[Y, tvCorpoROWSECTION.Index] := LCurrSection;

    // Dopo aver inserito un nuovo record imposta il valore di ORDER per fargli mantenere la posizione
    // e rigenera i valori di ORDER in modo da avere solo numeri interi
    // NB: Dopo avere fatto le "sezioni" lo metto fisso ad un numero altissimo in modo che
    // vada sempre alla fine del gruppo
    // if CurrView = tvCorpo then
    // begin
    case Mode of
      TAddArtMode.AM_Insert:
        DC.Values[Y, tvCorpoORDER.Index] := LCurrOrder - 0.00001;
      TAddArtMode.AM_Append:
        DC.Values[Y, tvCorpoORDER.Index] := 999999;
    end;
    RefreshOrderValues(CurrView);
    // end;

    // Inizia ad importare l'articolo
    DC.Values[Y, tvCorpoCODICEARTICOLO.Index] := DM1.Manodopera[ManIndex].Codice;
    DC.Values[Y, tvCorpoCODICEARTICOLOSTM.Index] := DM1.Manodopera[ManIndex].Codice;
    DC.Values[Y, tvCorpoDESCRIZIONE.Index] := DM1.Manodopera[ManIndex].Descrizione;
    DC.Values[Y, tvCorpoUNITADIMISURA.Index] := DM1.Manodopera[ManIndex].UM;
    // Se il codice IVA assegnato nell'anagrafica clienti non è nullo, assegna al
    // rigo la stessa aliquota IVA altrimenti quella dell'anagrafica articoli.
    // NB: La manodopera ha sempre codice IVA = 1
    if DocIvaDefault.IsDefault then
      AssegnaAliquotaIVA(1, Y, DC)
    else
      AssegnaAliquotaIVA(DocIvaDefault.Codice, Y, DC);

    // Importa sul documento i prezzi dei vari tipi di manodopera
    // NB: Se è un documento di acquisto carica il costo come prezzo unitario
    if DM1.IsDocumentoDiIngresso(TipoDoc) then
    begin
      DC.Values[Y, tvCorpoPREZZOUNITARIO.Index] := QryDocumentoCOSTOUNITOPERA.AsCurrency;
      DC.Values[Y, tvCorpoPREZZOACQUISTOARTICOLO.Index] := QryDocumentoCOSTOUNITOPERA.AsCurrency;
    end
    else
    begin
      case ManIndex of
        0:
          begin
            DC.Values[Y, tvCorpoPREZZOUNITARIO.Index] := QryDocumentoPRZUNITOPERA.AsCurrency;
            DC.Values[Y, tvCorpoPREZZOACQUISTOARTICOLO.Index] := QryDocumentoCOSTOUNITOPERA.AsCurrency;
          end;
        1:
          begin
            DC.Values[Y, tvCorpoPREZZOUNITARIO.Index] := QryDocumentoPRZUNITOPERA1.AsCurrency;
            DC.Values[Y, tvCorpoPREZZOACQUISTOARTICOLO.Index] := QryDocumentoCOSTOUNITOPERA1.AsCurrency;
          end;
        2:
          begin
            DC.Values[Y, tvCorpoPREZZOUNITARIO.Index] := QryDocumentoPRZUNITOPERA2.AsCurrency;
            DC.Values[Y, tvCorpoPREZZOACQUISTOARTICOLO.Index] := QryDocumentoCOSTOUNITOPERA2.AsCurrency;
          end;
        3:
          begin
            DC.Values[Y, tvCorpoPREZZOUNITARIO.Index] := QryDocumentoPRZUNITOPERA3.AsCurrency;
            DC.Values[Y, tvCorpoPREZZOACQUISTOARTICOLO.Index] := QryDocumentoCOSTOUNITOPERA3.AsCurrency;
          end;
        4:
          begin
            DC.Values[Y, tvCorpoPREZZOUNITARIO.Index] := QryDocumentoPRZUNITOPERA4.AsCurrency;
            DC.Values[Y, tvCorpoPREZZOACQUISTOARTICOLO.Index] := QryDocumentoCOSTOUNITOPERA4.AsCurrency;
          end;
      end;
    end;
    // Se si è in modalità di scorporo IVA (Quindi emettiamo documenti che devono indicare i prezzi IVA compresa)
    // Calcola subito il prezzo unitario iva compresa, altrimenti appare il rigo senza il prezzo.
    DC.Values[Y, tvCorpoPREZZOUNITARIOIVACOMPRESA.Index] := DC.Values[Y, tvCorpoPREZZOUNITARIO.Index] +
      DM1.Arrotonda((DC.Values[Y, tvCorpoPREZZOUNITARIO.Index] * DC.Values[Y, tvCorpoALIQUOTAIVA.Index] / 100), DM1.DecMicroPrz);

    // Richiedi Qtà se impostato
    // if DM1.RichiediQta then begin
    if fRichiediQtaDoc then
    begin
      Qta := 1; // Default Qty
      Qta := DM1.ChiediQtaArticolo(DM1.Manodopera[ManIndex].Codice, LeftStr(DM1.Manodopera[ManIndex].Descrizione, 60), DM1.Manodopera[ManIndex].UM, Qta);
      // Se a questo punto la Qta è zero allora la imposta a NULL perchè era
      // brutto lo zero visibile
      if Qta <> 0 then
        DC.Values[Y, tvCorpoQTA.Index] := Qta
      else
        DC.Values[Y, tvCorpoQTA.Index] := NULL;
    end;

    // ========================================================================
    // TIPI RIGHI (CONTI, SOTTOCONTI ECC.)
    // ------------------------------------------------------------------------
    // Parte che carica i tipi di righi (conti) di default
    DC.Values[Y, tvCorpoTIPO1.Index] := DM1.TableProgressiviTIPO1.AsString;
    DC.Values[Y, tvCorpoTIPO2.Index] := DM1.TableProgressiviTIPO2.AsString;
    DC.Values[Y, tvCorpoTIPO3.Index] := DM1.TableProgressiviTIPO3.AsString;
    DC.Values[Y, tvCorpoTIPO4.Index] := DM1.TableProgressiviTIPO4.AsString;
    DC.Values[Y, tvCorpoTIPO5.Index] := DM1.TableProgressiviTIPO5.AsString;
    DC.Values[Y, tvCorpoTIPO6.Index] := DM1.TableProgressiviTIPO6.AsString;
    // ========================================================================

    // Esegue il ricalcolo per variazione del prezzo unitario perchè altrimenti il Margine % rimaneva vuoto
    CalcolaPerModificaPrezzoUnitario(Y, DC);
    // Effettua il calcolo dei totali del rigo
    CalcolaImportoRigo(DC, Y);

  finally
    // Salva il FocusedRecordIndex corrente per poi ripristinarlo alla fine
    CurrView.Controller.FocusedRowIndex := LPrecRowIndex;
    // Se abilitato e necessario ricalcola i totali del documento
    CalcolaTotali(False);
    // Ritorna True
    Result := True;
  end;
end;

// Questa funzione ritorna True se il rigo principale di manodopera
// possiede sottorighi validi.
function TPreventiviOrdiniForm.SottorighiManodoperaPresenti(MDC: TcxCustomDataController; Y: Integer): Boolean;
begin
  Result := (MDC.GetDetailDataController(Y, RELATION_IDX_SOTTORIGHI_ORE).RecordCount > 0);
end;

// Visualizza un avvertimento se si inserisce un nuovo rigo nel documento con un CodiceArticolo
// che è già presente in un altro rigo inserito precedentemente
function TPreventiviOrdiniForm.ArticoloGiaPresente(const ACodArt, ADescrizione: String): Boolean;
var
  Idx: Integer;
  DC: TcxCustomDataController;
  LModalResult: TModalResult;
  LPresente: Boolean;
begin
  Result := False;
  if Trim(ACodArt) = '' then
    Exit;
  // DC Punta al DataController che attualmente ha il focus
  DC := GridCorpo.FocusedView.DataController;
  // Cicla per tutti i righi
  for Idx := 0 to DC.RecordCount - 1 do
  begin
    if DC.Values[Idx, tvCorpoCODICEARTICOLO.Index] = ACodArt then
    begin
      LPresente := True;
      break;
    end;
  end;
  // Se a questo punto Result = True significa che l'articolo era già
  // presente quindi avvisa l'utente
  if LPresente then
  begin
    LModalResult := DM1.Messaggi('Codice articolo già presente', Format('L''articolo "%s-%s" è già presente nel documento (riga %d).'#13#13'Continuare?',
      [ACodArt, ADescrizione, Idx + 1]), '', [mbYes, mbNo], 0, nil);
    case LModalResult of
      mrYes:
        Exit(False);
      mrNo:
        Exit(True);
    end;
  end;
end;

// Procedure che riceve i codici articolo da caricare come nuovo rigo di documento
procedure TPreventiviOrdiniForm.InserisciNuovoRigoDocumento(CodArt, StmCodArt: String; CodMag: String; Mode: TAddArtMode; Qta: Double = 0;
  RicalcoloTotali: Boolean = True);
var
  Y, LPrecRowIndex: Integer;
  Qry: TIBOQuery;
  DC: TcxCustomDataController;
  CurrView: TcxGridTableView;
  GoRichiediQta: Boolean;
  LDescrizioneArticolo, LCurrSection: String;
  LCurrOrder: Double;
begin
  // Verifica dei parametri ricevuti
  if CodArt = '' then
    raise Exception.Create('Codice articolo non valido.');
  // DC Punta al DataController che attualmente ha il focus
  CurrView := GridCorpo.FocusedView as TcxGridTableView;
  DC := CurrView.DataController;

  // Y contiene la coordinata Y della cella selezionata
  Y := DC.FocusedRecordIndex;
  // Salva il FocusedRecordIndex corrente per poi ripristinarlo alla fine
  LPrecRowIndex := CurrView.Controller.FocusedRowIndex;

  // Crea Qry
  Qry := TIBOQuery.Create(Self);
  DM1.ShowWait('Levante', 'Operazione in corso...');
  try
    Qry.DatabaseName := DM1.ArcDBFile;
    Qry.IB_Connection := DM1.DBAzienda;
    // Imposta la query che caricherà i dati dell'articol
    Qry.SQL.Add('SELECT * FROM DOC_NUOVO_RIGO_DOCUMENTO(:P_MAINCODART, :P_STMCODART)');
    // Imposta i parametri della query
    Qry.Prepare;
    Qry.Params.ParamByName('P_MAINCODART').AsString := CodArt;
    if StmCodArt <> '' then
      Qry.Params.ParamByName('P_STMCODART').AsString := StmCodArt;
    // Apre la query
    Qry.Open;

    // Ovviamente se non trova l'articolo l'operazione non può continuare
    if Qry.Eof then
      raise Exception.Create('Codice articolo non trovato!');

    // Carica la descrizione dell'articolo
    // NB: Se è impostato un limite per la lunghezza della descrizione...
    if DM1.LunghezzaMaxDescrizioneArticolo <> 0 then
      LDescrizioneArticolo := LeftStr(Qry.FieldByName('Descrizione').AsString, DM1.LunghezzaMaxDescrizioneArticolo)
    else
      LDescrizioneArticolo := Qry.FieldByName('Descrizione').AsString;

    // Verifica se l'articolo che si sta inserendo è già presente nel documento
    // nel qual caso informa l'utente e chiede il da farsi
    if fConfermaNuovoRigoSeArticoloGiaPresente and ArticoloGiaPresente(CodArt, LeftStr(LDescrizioneArticolo, 25)) then
      Exit;

    // Blocca il painting della griglia sullo schermo per velocizzare l'esecuzione dei calcoli
    // NB. Tolto perchè altrimenti dava problemi
    // DC.BeginUpdate;

    // Se non c'è alcun record selezionato forza l'Append del nuovo rigo
    // altrimenti dà un errore.
    if DC.FocusedRecordIndex = -1 then
      Mode := AM_Append;
    // Y contiene la coordinata Y della cella selezionata
    Y := DC.FocusedRecordIndex;
    // Inoltre se c'è un record selezionato ne estrae la sezione corrente
    // altrimenti no
    if (CurrView = tvCorpo) and (Y <> -1) then
      LCurrSection := VarToStrDef(DC.Values[Y, tvCorpoROWSECTION.Index], '')
    else
      LCurrSection := '';
    // Estrae l'ORDER corrente
    LCurrOrder := DM1.NoNullFloatValue(DC, Y, tvCorpoORDER.Index);
    // Questa riga è stata aggiunta per risolvere alcuni problemi.
    // Non ho ben capito perchè funziona però funziona quindi non toglierla.
    // Il problema accadeva quando ad esempio avevo un documento con 1 riga
    // e quando io aggiungevo un articolo con il codice dopo aver aver modificato
    // un campo del rigo già esistente il nuovo articolo appariva prima del rigo
    // e non in fondo. Così va tutto bene.
    DC.FocusedRecordIndex := -1;
    // In base alla modalità modifica il rigo corrente oppure fà un append o un insert.
    case Mode of
      TAddArtMode.AM_Insert:
        Y := DC.InsertRecord(Y);
      TAddArtMode.AM_Append:
        Y := DC.AppendRecord;
    end;
    // Assegna la sezione corrente
    DC.Values[Y, tvCorpoROWSECTION.Index] := LCurrSection;

    // Dopo aver inserito un nuovo record imposta il valore di ORDER per fargli mantenere la posizione
    // e rigenera i valori di ORDER in modo da avere solo numeri interi
    // NB: Dopo avere fatto le "sezioni" lo metto fisso ad un numero altissimo in modo che
    // vada sempre alla fine del gruppo
    // if CurrView = tvCorpo then
    // begin
    case Mode of
      TAddArtMode.AM_Insert:
        DC.Values[Y, tvCorpoORDER.Index] := LCurrOrder - 0.00001;
      TAddArtMode.AM_Append:
        DC.Values[Y, tvCorpoORDER.Index] := 999999;
    end;
    RefreshOrderValues(CurrView);
    // end;

    // Prima di tutto imposta il magazzino che il rigo deve movimentare
    DC.Values[Y, tvCorpoCODICEMAGAZZINO.Index] := QryDocumentoCODICEMAGAZZINO.AsInteger;
    // NB: Prima era AsString non so perchè
    if not QryDocumentoCODICEMAGAZZINO2.IsNull then
      DC.Values[Y, tvCorpoCODICEMAGAZZINO2.Index] := QryDocumentoCODICEMAGAZZINO2.AsInteger;
    // Inizia ad importare l'articolo
    DC.Values[Y, tvCorpoCODICEARTICOLO.Index] := Qry.FieldByName('CodiceArticolo').AsString;
    DC.Values[Y, tvCorpoCODICEARTICOLOSTM.Index] := Qry.FieldByName('CodiceArticoloStm').AsString;
    DC.Values[Y, tvCorpoDESCRIZIONE.Index] := LDescrizioneArticolo;
    // Continua con il caricamento dell'articolo
    DC.Values[Y, tvCorpoUNITADIMISURA.Index] := Qry.FieldByName('UnitaDiMisura').AsString;
    DC.Values[Y, tvCorpoPREZZOACQUISTOARTICOLO.Index] := DM1.Arrotonda(Qry.FieldByName('CostoReale').AsFloat, DM1.DecMicroPrz);
    DC.Values[Y, tvCorpoQTAOPERA.Index] := Qry.FieldByName('QtaOpera').AsFloat;
    DC.Values[Y, tvCorpoMINUTIPREVISTI.Index] := Qry.FieldByName('MinutiPrevisti').AsFloat;

    // ========================================================================
    // TIPI RIGHI (CONTI, SOTTOCONTI ECC.)
    // ------------------------------------------------------------------------
    // Parte che carica i tipi di righi (conti) di default
    if (not Qry.FieldByName('TIPO1').IsNull) and (Trim(Qry.FieldByName('TIPO1').AsString) <> '') then
      DC.Values[Y, tvCorpoTIPO1.Index] := Qry.FieldByName('TIPO1').AsString
    else
      DC.Values[Y, tvCorpoTIPO1.Index] := DM1.TableProgressiviTIPO1.AsString;
    if (not Qry.FieldByName('TIPO2').IsNull) and (Trim(Qry.FieldByName('TIPO2').AsString) <> '') then
      DC.Values[Y, tvCorpoTIPO2.Index] := Qry.FieldByName('TIPO2').AsString
    else
      DC.Values[Y, tvCorpoTIPO2.Index] := DM1.TableProgressiviTIPO2.AsString;
    if (not Qry.FieldByName('TIPO3').IsNull) and (Trim(Qry.FieldByName('TIPO3').AsString) <> '') then
      DC.Values[Y, tvCorpoTIPO3.Index] := Qry.FieldByName('TIPO3').AsString
    else
      DC.Values[Y, tvCorpoTIPO3.Index] := DM1.TableProgressiviTIPO3.AsString;
    if (not Qry.FieldByName('TIPO4').IsNull) and (Trim(Qry.FieldByName('TIPO4').AsString) <> '') then
      DC.Values[Y, tvCorpoTIPO4.Index] := Qry.FieldByName('TIPO4').AsString
    else
      DC.Values[Y, tvCorpoTIPO4.Index] := DM1.TableProgressiviTIPO4.AsString;
    if (not Qry.FieldByName('TIPO5').IsNull) and (Trim(Qry.FieldByName('TIPO5').AsString) <> '') then
      DC.Values[Y, tvCorpoTIPO5.Index] := Qry.FieldByName('TIPO5').AsString
    else
      DC.Values[Y, tvCorpoTIPO5.Index] := DM1.TableProgressiviTIPO5.AsString;
    if (not Qry.FieldByName('TIPO6').IsNull) and (Trim(Qry.FieldByName('TIPO6').AsString) <> '') then
      DC.Values[Y, tvCorpoTIPO6.Index] := Qry.FieldByName('TIPO6').AsString
    else
      DC.Values[Y, tvCorpoTIPO6.Index] := DM1.TableProgressiviTIPO6.AsString;
    // ========================================================================



    // NB: ##### PRIMA LA RICHIESTA QTA O EDITOR VIAGGI PER AZIENDE DI TRASPORTO ERA QUI #####

    // ========================================================================
    // CARICAMENTO ALIQUOTA IVA
    // ------------------------------------------------------------------------
    // Se il codice IVA assegnato nell'anagrafica clienti non è nullo, assegna al
    // rigo la stessa aliquota IVA altrimenti quella dell'anagrafica articoli.
    if DocIvaDefault.IsDefault then
      AssegnaAliquotaIVA(Qry.FieldByName('CodiceIVA').AsInteger, Y, DC)
    else
      AssegnaAliquotaIVA(DocIvaDefault.Codice, Y, DC);
    // ========================================================================

    // ========================================================================
    // CARICAMENTO PREZZO
    // ------------------------------------------------------------------------
    // Se è una bolla di entrata merci oppure una fattura di acquisto importa il prezzo
    // di acquisto (prechè si tratta appunto di acquisti e quindi di carico di magazzino),
    // altrimenti si tratta di documenti di vendita e quinti importa il prezzo di vendita
    // appropriato in base al listino.
    if DM1.IsDocumentoDiIngresso(TipoDoc) then
    begin
      // SePrezziAcquistoNetti = True inserisce direttamente il prezzo netto nel documento altrimenti inserisce
      // Importa il prezzo di acquisto netto altrimenti inserisce il prezzo listino - gli sconti di acquisto.
      if DM1.PrezziAcquistoNetti then
        DC.Values[Y, tvCorpoPREZZOUNITARIO.Index] := DM1.Arrotonda(Qry.FieldByName('CostoReale').AsFloat, DM1.DecMicroPrz)
      else
      begin
        DC.Values[Y, tvCorpoPREZZOUNITARIO.Index] := DM1.Arrotonda(Qry.FieldByName('PrezzoDiListino').AsFloat, DM1.DecMicroPrz);
        DC.Values[Y, tvCorpoSCONTORIGO.Index] := Qry.FieldByName('ScontoDiAcquisto').AsFloat;
        DC.Values[Y, tvCorpoSCONTORIGO2.Index] := Qry.FieldByName('ScontoDiAcquisto2').AsFloat;
        DC.Values[Y, tvCorpoSCONTORIGO3.Index] := Qry.FieldByName('ScontoDiAcquisto3').AsFloat;
      end;
    end
    else
    begin
      // Se PrezziNetti = True inserisce direttamente i prezzi netti come prezzo unitario
      // NB: Anche se siamo in una distinta base forza l'uso dei prezzi netti.
      // NB: Forza i prezzi netti anche se stiamo inserendo un articolo composto
      if DM1.PrezziNetti or (Qry.FieldByName('ARTICOLOCOMPOSTO').AsString = 'T') or (DistintaBase) then
      begin
        // In base al listino selezionato importa il prezzo di vendita giusto (Default := Listino1).
        case QryDocumentoLISTINO.AsInteger of
          1:
            DC.Values[Y, tvCorpoPREZZOUNITARIO.Index] := DM1.Arrotonda(Qry.FieldByName('PrezzoDiVendita').AsFloat, DM1.DecMicroPrz);
          2:
            DC.Values[Y, tvCorpoPREZZOUNITARIO.Index] := DM1.Arrotonda(Qry.FieldByName('PrezzoDiVendita2').AsFloat, DM1.DecMicroPrz);
          3:
            DC.Values[Y, tvCorpoPREZZOUNITARIO.Index] := DM1.Arrotonda(Qry.FieldByName('PrezzoDiVendita3').AsFloat, DM1.DecMicroPrz);
          4:
            DC.Values[Y, tvCorpoPREZZOUNITARIO.Index] := DM1.Arrotonda(Qry.FieldByName('PrezzoDiVendita4').AsFloat, DM1.DecMicroPrz);
        else
          DC.Values[Y, tvCorpoPREZZOUNITARIO.Index] := DM1.Arrotonda(Qry.FieldByName('PrezzoDiListino').AsFloat, DM1.DecMicroPrz);
        end;
        // se è un articolo composto e il listino del documento = 0 (zero) c'è il problema che non esiste un
        // prezzi di listino (con il listino 0 caricherebbe quello) quindi gli caricare cmq il prezzo del
        // listino 1
        if (Qry.FieldByName('ARTICOLOCOMPOSTO').AsString = 'T') and (QryDocumentoLISTINO.AsInteger = 0) then
          DC.Values[Y, tvCorpoPREZZOUNITARIO.Index] := DM1.Arrotonda(Qry.FieldByName('PrezzoDiVendita').AsFloat, DM1.DecMicroPrz);
      end
      // Se invece PrezziNetti = false inserisce il PrezzoDiListino come prezzo unitario + lo sconto
      else
      begin
        // Imposta il PrezzoDiListino come prezzoUnitario
        DC.Values[Y, tvCorpoPREZZOUNITARIO.Index] := DM1.Arrotonda(Qry.FieldByName('PrezzoDiListino').AsFloat, DM1.DecMicroPrz);
        // In base al listino selezionato importa lo sconto giusto (Default := Listino1).
        case QryDocumentoLISTINO.AsInteger of
          1:
            DC.Values[Y, tvCorpoSCONTORIGO.Index] := Qry.FieldByName('ScontoListino1').AsFloat;
          2:
            DC.Values[Y, tvCorpoSCONTORIGO.Index] := Qry.FieldByName('ScontoListino2').AsFloat;
          3:
            DC.Values[Y, tvCorpoSCONTORIGO.Index] := Qry.FieldByName('ScontoListino3').AsFloat;
          4:
            DC.Values[Y, tvCorpoSCONTORIGO.Index] := Qry.FieldByName('ScontoListino4').AsFloat;
        else
          DC.Values[Y, tvCorpoSCONTORIGO.Index] := 0;
        end;
      end;
      // Se si è in modalità di scorporo IVA (Quindi emettiamo documenti che devono indicare i prezzi IVA compresa)
      // Calcola subito il prezzo unitario iva compresa, altrimenti appare il rigo senza il prezzo.
      DC.Values[Y, tvCorpoPREZZOUNITARIOIVACOMPRESA.Index] := DC.Values[Y, tvCorpoPREZZOUNITARIO.Index] +
        DM1.Arrotonda((DC.Values[Y, tvCorpoPREZZOUNITARIO.Index] * DC.Values[Y, tvCorpoALIQUOTAIVA.Index] / 100), DM1.DecMicroPrz);
      // Nel caso sia imopstato il flag che indica di caricare l'eventuale sconto presente
      // nell'anagrafica articolo...
      if DM1.TableProgressiviSCONTOSOGGNELRIGO.AsString = 'T' then
      begin
        if VarIsNull(DC.Values[Y, tvCorpoSCONTORIGO.Index]) then
          DC.Values[Y, tvCorpoSCONTORIGO.Index] := ScontoSoggetto
        else
          DC.Values[Y, tvCorpoSCONTORIGO.Index] := DC.Values[Y, tvCorpoSCONTORIGO.Index] + ScontoSoggetto;
      end;
      // Esegue il ricalcolo per variazione del prezzo unitario perchè altrimenti il Margine % rimaneva vuoto
      CalcolaPerModificaPrezzoUnitario(Y, DC);
    end;
    // ========================================================================

    // ========================================================================
    // RICHIEDI QTA / EDITOR VIAGGI PER AZIENDE DI TRASPORTO
    // NB: Spostato qui dopo il caricamento del prezzo perchè se è attivo l'editor
    // dei viaggi e l'utente specificava un prezzo poi il programma ne
    // caricava un altro.
    // ------------------------------------------------------------------------
    // Se l'apposito flag indica che è abilitato l'editor dei viaggi per le aziende di trasporto
    // visualizza quello altrimenti se è abilitato il richiediQta continua normalmente con quello
    // NB: l'Editor per i viaggi è solo per i documenti di vendita
    // NB: l'Editor per i viaggicomparirà automaticamente solo per gli articoli il cui
    // codice inizia con "VG."
    if DM1.ViaggioEditorEnabled and (not DM1.IsDocumentoDiIngresso(TipoDoc)) and (Uppercase(LeftStr(Qry.FieldByName('CodiceArticolo').AsString, 3)) = 'VG.')
    then
    begin
      // Imposta il focus sul rigo
      DC.FocusedRecordIndex := Y;
      // Visualiza l'editor dei viaggi per le aziende di trasporto.
      VisualizzaEditorViaggio;
      // Se non abilitato l'Editor per i viaggi delle aziende di trasporto ed è abilitato
      // il richiedi Qtà...
    end
    else
    begin
      // Se il parametro Qta = 0 allora si defaultizza al valore indicato dal campo
      // QtaAutomatica nell'amagrafica dell'articolo stesso, oppure se il flag
      // apposito abilita alla richiesta immediata della qta all'operatore...
      GoRichiediQta := (Qta = 0);
      if Qta = 0 then
      begin
        if Qry.FieldByName('QuantitaAutomatica').IsNull then
          Qta := 1
        else
          Qta := Qry.FieldByName('QuantitaAutomatica').AsFloat;
      end;
      // if DM1.RichiediQta and GoRichiediQta then begin
      if fRichiediQtaDoc and GoRichiediQta then
        Qta := DM1.ChiediQtaArticolo(Qry.FieldByName('CodiceArticolo').AsString, LeftStr(Qry.FieldByName('Descrizione').AsString, 60),
          Qry.FieldByName('UnitaDiMisura').AsString, Qta);
      // Se a questo punto la Qta è zero allora la imposta a NULL perchè era
      // brutto lo zero visibile
      if Qta <> 0 then
        DC.Values[Y, tvCorpoQTA.Index] := Qta
      else
        DC.Values[Y, tvCorpoQTA.Index] := NULL;
    end;
    // ========================================================================

    // ========================================================================
    // CONDIZIONI DI VENDITA  E CARICAMENTO SOTTORIGHI
    // ------------------------------------------------------------------------
    // Se il rigo attuale è un sottorigo oppure è una DistintaBase non considerà le condizioni di Vendita/Acquisto
    // NB: Anche se è abilitato il flag di caricamento dello sconto soggetto nei righi
    if DC.IsDetailMode or DistintaBase or (DM1.TableProgressiviSCONTOSOGGNELRIGO.AsString = 'T') then
    begin
      // Effettua il calcolo dei totali del rigo
      CalcolaImportoRigo(DC, Y);
      // Se invece è un Rigo Master normale provvede a considerare le Condizioni di Vendita/Acquisto e a caricare i
      // sottorighi
    end
    else
    begin
      // Se è un articolo composto richiama la funzione che inserirà i sottorighi
      if (Qry.FieldByName('ARTICOLOCOMPOSTO').AsString = 'T') then
      begin
        // I righi composti hanno il flag PrzUnitAutocalc a True per default
        if Qry.FieldByName('FissaPrzVend').AsString = 'T' then
          DC.Values[Y, tvCorpoPREZZOUNITARIOAUTOCALC.Index] := 'F'
        else
          DC.Values[Y, tvCorpoPREZZOUNITARIOAUTOCALC.Index] := 'T';
        LoadDetailRows(Y, CodArt, CodMag);
        CalcolaTotaliSottorighi(tvCorpo.DataController, Y);
      end
      else
      begin
        // Le condizioni di vendita posso essere applicate solo ai righi normale (Non composti)
        // IMpora l'importo oppure gli sconti in base alle eventuali condizioni di vendita
        AggiornaCondVendArticolo(CodArt, QryDocumentoCODICECLIENTE.AsInteger, TipoDoc, Y);
      end;
    end;
    // ========================================================================

    // Controlla la disponibilità di magazzino
    if (Qry.FieldByName('AbilitaMovMag').AsString = 'T') and (not VarIsNull(DC.Values[Y, tvCorpoQTA.Index])) and
      (not VarIsNull(DC.Values[Y, tvCorpoCODICEMAGAZZINO.Index])) then
      ControlloSottoscortaArticolo(CodArt, DC.Values[Y, tvCorpoQTA.Index], DC.Values[Y, tvCorpoCODICEMAGAZZINO.Index], QryDocumentoSEGNOOPERAZIONE.AsString);

    // Sposta il focus sul record appena aggiunto
    DC.FocusedRowIndex := Y;

    // ====================================================================
    // Ho rimesso il caricamento dei campi DESCRIZIONE2,3,4,5 perchè
    // alcuni clienti avevano difficoltà con se descrizioni lunghe suprattutto
    // con la stampa di documenti su stampanti ad aghi.
    // NB: SOLO SE ABILITATO DALL'APPOSITO FLAG.
    // --------------------------------------------------------------------
    if DM1.AbilitaDescrizioni2345 then
    begin
      if (not Qry.FieldByName('Descrizione2').IsNull) and (Qry.FieldByName('Descrizione2').AsString <> '') and (Mode <> AM_Edit) then
      begin
        // Aggiunge o appende un rigo alla griglia
        case Mode of
          AM_Append:
            Y := tvCorpo.DataController.AppendRecord;
          AM_Insert:
            Y := tvCorpo.DataController.InsertRecord(Y + 1);
        end;
        // Inserisce la descrizione
        tvCorpo.DataController.Values[Y, tvCorpoDESCRIZIONE.Index] := Qry.FieldByName('Descrizione2').AsString;
        // Sposta il focus sul record appena aggiunto (Altrimenti non mette il codice Magazzino nel rigo)
        DC.FocusedRowIndex := Y;
      end;
      if (not Qry.FieldByName('Descrizione3').IsNull) and (Qry.FieldByName('Descrizione3').AsString <> '') and (Mode <> AM_Edit) then
      begin
        // Aggiunge o appende un rigo alla griglia
        case Mode of
          AM_Append:
            Y := tvCorpo.DataController.AppendRecord;
          AM_Insert:
            Y := tvCorpo.DataController.InsertRecord(Y + 1);
        end;
        // Inserisce la descrizione
        tvCorpo.DataController.Values[Y, tvCorpoDESCRIZIONE.Index] := Qry.FieldByName('Descrizione3').AsString;
        // Sposta il focus sul record appena aggiunto (Altrimenti non mette il codice Magazzino nel rigo)
        DC.FocusedRowIndex := Y;
      end;
      if (not Qry.FieldByName('Descrizione4').IsNull) and (Qry.FieldByName('Descrizione4').AsString <> '') and (Mode <> AM_Edit) then
      begin
        // Aggiunge o appende un rigo alla griglia
        case Mode of
          AM_Append:
            Y := tvCorpo.DataController.AppendRecord;
          AM_Insert:
            Y := tvCorpo.DataController.InsertRecord(Y + 1);
        end;
        // Inserisce la descrizione
        tvCorpo.DataController.Values[Y, tvCorpoDESCRIZIONE.Index] := Qry.FieldByName('Descrizione4').AsString;
        // Sposta il focus sul record appena aggiunto (Altrimenti non mette il codice Magazzino nel rigo)
        DC.FocusedRowIndex := Y;
      end;
      if (not Qry.FieldByName('Descrizione5').IsNull) and (Qry.FieldByName('Descrizione5').AsString <> '') and (Mode <> AM_Edit) then
      begin
        // Aggiunge o appende un rigo alla griglia
        case Mode of
          AM_Append:
            Y := tvCorpo.DataController.AppendRecord;
          AM_Insert:
            Y := tvCorpo.DataController.InsertRecord(Y + 1);
        end;
        // Inserisce la descrizione
        tvCorpo.DataController.Values[Y, tvCorpoDESCRIZIONE.Index] := Qry.FieldByName('Descrizione5').AsString;
        // Sposta il focus sul record appena aggiunto (Altrimenti non mette il codice Magazzino nel rigo)
        DC.FocusedRowIndex := Y;
      end;
    end;
    // ====================================================================

  finally
    DM1.CloseWait;
    Qry.Close;
    Qry.Free;
    // Salva il FocusedRecordIndex corrente per poi ripristinarlo alla fine
    CurrView.Controller.FocusedRowIndex := LPrecRowIndex;

    // Riabilita il painting del componente forzando così l'aggiornamento dello schermo
    // NB. Tolto perchè altrimenti dava problemi
    // DC.EndUpdate;

    // Se siamo su un sottorigo causa il ricalcolo anche del rigo principale
    if DC.IsDetailMode then
      CalcolaTotaliSottorighi(tvCorpo.DataController, DC.GetMasterRecordIndex);
    // Se abilitato e necessario ricalcola i totali del documento
    if RicalcoloTotali then
      CalcolaTotali(False);
  end;
end;

// Procedure che riceve dei codici articolo da ricercare per un futuro inserimento come nuovo rigo di documento
procedure TPreventiviOrdiniForm.Aggiornaledescrizionidallelencoarticoli2Click(Sender: TObject);
begin
  if DM1.Messaggi('Aggiorna descrizioni articoli', 'Confermi di voler aggiornare le descrizione articoli dei righi selezionati?', '', [mbYes, mbNo], 0, nil) <> mrYes
  then
    Exit;
  DM1.ShowWait('Aggiorna descrizioni articoli', 'Operazione in corso...');
  try
    AggiornaDescrizioniArticoliRighiSelezionati(tvCorpo);
  finally
    DM1.CloseWait;
  end;
end;

procedure TPreventiviOrdiniForm.Nascondiscontopercentuale1Click(Sender: TObject);
begin
  if not RxSpeedModifica.Down then
    DM1.Messaggi('Levante', 'Devi essere in modalità di modifica', '', [mbOk], 0, nil);
  if DM1.Messaggi('Nascondi sconto percentuale', 'Confermi di voler nascondere lo sconto percentuale?', '', [mbYes, mbNo], 0, nil) = mrYes then
  begin
    QryDocumentoABBUONO.Clear;
    QryDocumentoABBUONOPERC.Clear;
    QryDocumentoABBUONOSU.Clear;
    RGAbbuonoPropertiesChange(RGAbbuono);
  end;
end;

procedure TPreventiviOrdiniForm.NuovoRigoDocumento(CodTutti, CodArt, CodBarre, CodForn, CodMag: String; Mode: TAddArtMode; Qta: Double = 0;
  RicalcoloTotali: Boolean = True);
var
  Y: Integer;
  QryQuanti: TIBOQuery;
  TmpStr: String;
  DC: TcxCustomDataController;
  // GoRichiediQta: Boolean;
  NumRecFound: Integer;
  CodiceDaStampare: String;
begin
  // Se i codici sono tutti nulli esce
  if (CodTutti = '') and (CodArt = '') and (CodBarre = '') and (CodForn = '') then
    Exit;

  // ===========================================================================================
  // NB: Tutta questa parte è stata spostata qui da poco più in basso perchè così
  // ha effetto anche sull'inserimento di nuovi righi di manodopera.
  // -------------------------------------------------------------------------------------------
  // DC Punta al DataController che attualmente ha il focus
  DC := GridCorpo.FocusedView.DataController;
  // Se non c'è alcun record selezionato forza l'Append del nuovo rigo
  // altrimenti dà un errore.
  if DC.FocusedRecordIndex = -1 then
    Mode := AM_Append;
  // Y contiene la coordinata Y della cella selezionata
  Y := DC.FocusedRecordIndex;
  // Questa riga è stata aggiunta per risolvere alcuni problemi.
  // Non ho ben capito perchè funziona però funziona quindi non toglierla.
  // Il problema accadeva quando ad esempio avevo un documento con 1 riga
  // e quando io aggiungevo un articolo con il codice dopo aver aver modificato
  // un campo del rigo già esistente il nuovo articolo appariva prima del rigo
  // e non in fondo. Così va tutto bene.
  DC.FocusedRecordIndex := -1;
  // Prima ripristina il focused record index che precedentemente avevo forzato a -1 per
  // risolvere un problema spiegato più sopra. Se non ripristino il valore del FocusedRecordIndex
  // succede che nel caso il codice inserito sia in più articoli quando l'utente seleziona
  // l'articolo voluto tra quelli  trovati lo inserisce in una nuova riga e non su quella
  // su cui ha scritto il codice articolo da ceercare (ovviamente nel caso avesse inserito
  // il codice voluto direttamente sul rigo).
  DC.FocusedRecordIndex := Y;
  // ===========================================================================================

  // Verifica se il codice ricevuto è relativo alla manodopera e se lo è la carica ed esce
  // altrimenti prosegue normalmente
  if CodArt <> '' then
  begin
    if NuovoRigoManodopera(CodArt, Mode) then
      Exit;
  end
  else if CodTutti <> '' then
  begin
    if NuovoRigoManodopera(CodTutti, Mode) then
      Exit;
  end
  else if CodBarre <> '' then
  begin
    if NuovoRigoManodopera(CodBarre, Mode) then
      Exit;
  end
  else if CodForn <> '' then
  begin
    if NuovoRigoManodopera(CodForn, Mode) then
      Exit;
  end;
  // Se è una manodopera esce
  if NuovoRigoManodopera(CodArt, Mode) then
    Exit;

  // ==========================================================================
  // Determina il codice da stampare in base al tipo di ricerca effettuata.
  // In pratica dipende da quale codice si è utilizzato per la ricerca stessa.
  // --------------------------------------------------------------------------
  CodiceDaStampare := '';
  if CodForn <> '' then
    CodiceDaStampare := CodForn
  else if CodArt <> '' then
    CodiceDaStampare := CodArt
  else if CodTutti <> '' then
    CodiceDaStampare := CodTutti;
  // ==========================================================================

  // ===========================================================================================
  // NB: Tutta questa parte è stata spostata qui da poco più in alto perchè così
  // ha effetto anche sull'inserimento di nuovi righi di manodopera.
  // -------------------------------------------------------------------------------------------
  // DC Punta al DataController che attualmente ha il focus
  // DC := GridCorpo.FocusedView.DataController;
  // Se non c'è alcun record selezionato forza l'Append del nuovo rigo
  // altrimenti dà un errore.
  // if DC.FocusedRecordIndex = -1 then
  // Mode := AM_Append;
  // Y contiene la coordinata Y della cella selezionata
  // Y := DC.FocusedRecordIndex;
  // Questa riga è stata aggiunta per risolvere alcuni problemi.
  // Non ho ben capito perchè funziona però funziona quindi non toglierla.
  // Il problema accadeva quando ad esempio avevo un documento con 1 riga
  // e quando io aggiungevo un articolo con il codice dopo aver aver modificato
  // un campo del rigo già esistente il nuovo articolo appariva prima del rigo
  // e non in fondo. Così va tutto bene.
  // DC.FocusedRecordIndex := -1;
  // ===========================================================================================

  // Crea Qry
  QryQuanti := TIBOQuery.Create(Self);
  DM1.ShowWait('Levante', 'Operazione in corso...');
  try
    QryQuanti.DatabaseName := DM1.ArcDBFile;
    QryQuanti.IB_Connection := DM1.DBAzienda;

    // Imposta la query che ritornerà il numero degli articoli trovati in base
    // alla richiesta dell'utente
    QryQuanti.SQL.Add('SELECT DISTINCT(A.CODICEARTICOLO) FROM ARTICOLI A');

    // Costruisce la Stringa con le clausole di where dei codici per la ricerca dell'articolo
    TmpStr := '';
    // Se è specificato il parametro TuttiCod cerca indistintamente per tutti i codici altrimenti
    // per i singoli codici
    // NB: Nei codici aggiuntivi i codici possono essere racchiusi tra <> e []
    // -----------------------------------------------------------------------
    if CodTutti <> '' then
    begin
      TmpStr := '';
      // Se è abilitata la ricerca per codice principale
      if DM1.TableProgressiviRICART_CODICEPRINC.AsString <> 'F' then
      begin
        if TmpStr <> '' then
          TmpStr := TmpStr + ' OR ';
        TmpStr := TmpStr + 'UPPER(A.CodiceArticolo) LIKE ''' + Uppercase(CodTutti) + '''';
      end;
      // Se è abilitata la ricerca per Barcode
      if DM1.TableProgressiviRICART_BARCODE.AsString <> 'F' then
      begin
        if TmpStr <> '' then
          TmpStr := TmpStr + ' OR ';
        TmpStr := TmpStr + 'UPPER(A.BarCode) LIKE ''' + Uppercase(CodTutti) + '''';
      end;
      // Se è abilitata la ricerca per Codice articolo fornitore
      if DM1.TableProgressiviRICART_CODICEFORN.AsString <> 'F' then
      begin
        if TmpStr <> '' then
          TmpStr := TmpStr + ' OR ';
        TmpStr := TmpStr + 'UPPER(A.CodiceFornitore) LIKE ''' + Uppercase(CodTutti) + '''';
      end;
      // Se è abilitata la ricerca per Codici aggiuntivi
      if DM1.TableProgressiviRICART_CODAGG.AsString <> 'F' then
      begin
        if TmpStr <> '' then
          TmpStr := TmpStr + ' OR ';
        TmpStr := TmpStr + '(UPPER(CodiciAggiuntivi) LIKE  ''%<' + Uppercase(CodTutti) + '>%'' OR UPPER(A.CodiciAggiuntivi) LIKE  ''%[' + Uppercase(CodTutti)
          + ']%'')';
      end;
      // Se è abilitata la ricerca per il sistema di gestione dei listini fornitori
      if DM1.TableProgressiviRICART_LISTFORN.AsString <> 'F' then
      begin
        if TmpStr <> '' then
          TmpStr := TmpStr + ' OR ';
        TmpStr := TmpStr +
          'EXISTS (SELECT LF.CODICEARTICOLO FROM LISTFORN LF WHERE LF.CODICEARTICOLO = A.CODICEARTICOLO AND UPPER(LF.CODICEARTICOLOFORNITORE) LIKE ''' +
          Uppercase(CodTutti) + ''')';
      end;
      // Se invece il "CodiceTutti" non è stato inserito esegue le ricerche per i singoli codici
    end
    else
    begin
      if CodArt <> '' then
        TmpStr := TmpStr + 'UPPER(CodiceArticolo) = ''' + Uppercase(CodArt) + ''' OR ';
      if CodBarre <> '' then
        TmpStr := TmpStr + 'UPPER(BarCode) = ''' + Uppercase(CodBarre) + ''' OR ';
      if CodForn <> '' then
      begin
        TmpStr := TmpStr + 'UPPER(CodiceFornitore) = ''' + Uppercase(CodForn) + ''' OR ';
        TmpStr := TmpStr +
          'EXISTS (SELECT LF.CODICEARTICOLO FROM LISTFORN LF WHERE LF.CODICEARTICOLO = A.CODICEARTICOLO AND UPPER(LF.CODICEARTICOLOFORNITORE) LIKE ''' +
          Uppercase(CodForn) + ''') OR ';
      end;
      TmpStr := DM1.StrLeft(TmpStr, Length(TmpStr) - 4); // Elimina l'ultimo OR
    end;
    // Aggiunge le condizioni rilevate
    if TmpStr <> '' then
      QryQuanti.SQL.Add('WHERE (' + TmpStr + ')');
    // Se è stata specificata una restrizione nel'accesso alle risorse
    // dell'agenda per utente la applica
    if DM1.LimitazioniArticoliPerUtente <> '' then
    begin
      if TmpStr = '' then
        QryQuanti.SQL.Add('WHERE')
      else
        QryQuanti.SQL.Add(' AND ');
      QryQuanti.SQL.Add('(' + DM1.LimitazioniArticoliPerUtente + ')');
    end;
    // -----------------------------------------------------------------------

    // Apre la query e ricva da essa il numero dei record trovati
    QryQuanti.Open;
    NumRecFound := QryQuanti.RecordCount;

    // =======================================================================
    // Se trova un solo articolo lo importa direttamente nel documento
    // -----------------------------------------------------------------------
    if NumRecFound = 1 then
    begin

      // CodArt Ora contiene il codice articolo dell'articolo trovato dalla query
      // (In questo modo anche se ei era cercato l'articolo per altri tipi di codice, non ci sono problemi)
      CodArt := QryQuanti.FieldByName('CodiceArticolo').AsString;
      // Se ancora a questo punto il CodiceArticoloDaStampare è ancora vuoto (non dovrebbe esserlo)
      // lo forza uguale al Codice articolo principale.
      if CodiceDaStampare = '' then
        CodiceDaStampare := CodArt;
      // Prima ripristina il focused record index che precedentemente avevo forzato a -1 per
      // risolvere un problema spiegato più sopra. Se non ripristino il valore del FocusedRecordIndex
      // succede che nel caso il codice inserito sia in più articoli quando l'utente seleziona
      // l'articolo voluto tra quelli  trovati lo inserisce in una nuova riga e non su quella
      // su cui ha scritto il codice articolo da ceercare (ovviamente nel caso avesse inserito
      // il codice voluto direttamente sul rigo).
      // DC.FocusedRecordIndex := Y;
      // Inserisce l'articolo trovato in un nuovo rigo di documento
      InserisciNuovoRigoDocumento(CodArt, CodiceDaStampare, CodMag, Mode, Qta, RicalcoloTotali);

      // =============================================================================
      // Se invece ne trova più di uno visualizza l'elenco per permettere di scegliere
      // -----------------------------------------------------------------------------
    end
    else if NumRecFound > 1 then
    begin

      // Prima ripristina il focused record index che precedentemente avevo forzato a -1 per
      // risolvere un problema spiegato più sopra. Se non ripristino il valore del FocusedRecordIndex
      // succede che nel caso il codice inserito sia in più articoli quando l'utente seleziona
      // l'articolo voluto tra quelli  trovati lo inserisce in una nuova riga e non su quella
      // su cui ha scritto il codice articolo da ceercare (ovviamente nel caso avesse inserito
      // il codice voluto direttamente sul rigo).
      DC.FocusedRecordIndex := Y;
      DM1.SelezionaArticolo(CodiceDaStampare, '', Mode, Qta, QryDocumentoPRATICA.AsInteger, QryDocumentoDATAPRATICA1.AsDateTime);

      // =============================================================================
      // Altrimenti significa che non ha trovato alcun articolo e quindi ritorna un errore
      // -----------------------------------------------------------------------------
    end
    else
    begin

      MessageBeep(MB_ICONEXCLAMATION);
      MessageDlg('Articolo non trovato !', mtError, [mbOk], 0)

    end;
    // =============================================================================

  finally
    // Pulizie finali
    DM1.CloseWait;
    QryQuanti.Close;
    QryQuanti.Free;
  end;
end;

procedure TPreventiviOrdiniForm.RxSpeedButtonUscitaClick(Sender: TObject);
begin
  // Se in modalità KIOSK effettua il cancel della QryDocumento
  if Tag = MODE_KIOSK then
  begin
    // Se non  c'è nessun rigo esce dalla form
    if (tvCorpo.DataController.RecordCount = 0) and (not MainForm.MagKioskMode) then
    begin
      // Chiede prima conferma
      MessageBeep(0);
      if MessageDlg('Confermi di voler uscire dall''emissione continua di documenti?', mtInformation, [mbOk, mbCancel], 0) = mrOk then
      begin
        Close;
      end;
    end
    else
    begin
      MessageBeep(0);
      if MessageDlg('Confermi di voler annullare il documento?', mtInformation, [mbOk, mbCancel], 0) = mrOk then
      begin
        QryDocumento.Cancel;
        // Si predispone per un altro documento
        DM1.NuovoDocFisc(DM1.KioskTipoDocDefault, '', 0, 0, '', 4, 0, False, False);
      end;
    end;
  end
  else
  begin
    // Se è una distntabase passa alla form dell'anagrafica articolo senza distruggere questa form
    if Self.DistintaBase then
    begin
      // Self.Hide;
      AnagArtForm.RxSpeedButtonUscitaClick(RxSpeedButtonUscita);
      // Se invece è un impegno richiama il codice di uscita di quest'ultimo
    end
    else if Self.IsImpegno then
    begin
      ImpegnoForm.RxSpeedButtonUscitaClick(ImpegnoForm.RxSpeedButtonUscita);
    end
    else
    begin
      // Chiude la Form
      Close;
    end;
  end;
end;

procedure TPreventiviOrdiniForm.Deselezionacantiereimpianto1Click(Sender: TObject);
begin
  if RxSpeedModifica.Down then
    DM2.ClearCantiereDoc(QryDocumentoPRATICA, QryDocumentoDATAPRATICA1, DbeDescrizioneCantiere)
  else
    DM1.Messaggi('Levante', 'Il documento deve essere in modalità di modifica', '', [mbOk], 0, nil);
end;

procedure TPreventiviOrdiniForm.DiBaModificaClick(Sender: TObject);
begin
  // Cambia stato al pulsante Modifica dell'Anagrafica articoli e poi richiama l'evento OnClick
  AnagArtForm.RxSpeedModifica.Down := not AnagArtForm.RxSpeedModifica.Down;
  AnagArtForm.RxSpeedModificaClick(AnagArtForm.RxSpeedModifica);
end;

procedure TPreventiviOrdiniForm.ImpegnoModificaClick(Sender: TObject);
begin
  // Cambia stato al pulsante Modifica dell'Anagrafica articoli e poi richiama l'evento OnClick
  ImpegnoForm.RxSpeedModifica.Down := not ImpegnoForm.RxSpeedModifica.Down;
  ImpegnoForm.RxSpeedModificaClick(ImpegnoForm.RxSpeedModifica);
end;

procedure TPreventiviOrdiniForm.ImportaArticoliDaFileTxt;
const
  IndexCodiceArticolo = 0;
  IndexDescrizione = 1;
  IndexUM = 2;
  IndexQta = 3;
  IndexPrezzo = 4;
var
  Dlg: TOpenDialog;
  FF: TextFile; // Puntatore al file di testo da importare
  NomeFile: String;
  SS, CurrentStr: String;
  SL: TStrings;
  vCodiceArticolo: String;
  vDescrizione: String;
  vUM: String;
  vQta: Double;
  VPrezzo: Double;
  DC: TcxCustomDataController;
  Row: Integer;
begin
  Dlg := TOpenDialog.Create(Self);
  try
    if Dlg.Execute then
      NomeFile := Dlg.FileName
    else
      Exit;
  finally
    Dlg.Free;
  end;
  // Se il file non esiste solleva ua eccezione
  if not FileExists(NomeFile) then
    raise Exception.Create('File da importare non presente.');
  // Crea la StringList che conterrà i campi appena importari
  SL := TStringList.Create;
  SL.Delimiter := ';';
  SL.StrictDelimiter := True;
  // Apre il file da importare
  AssignFile(FF, NomeFile);
  // Si posiziona all'inizio del file
  Reset(FF);
  // Disabilita l'aggiornamento a video della griglia
  GridCorpo.BeginUpdate;
  DC := tvCorpo.DataController;
  DC.FocusedRecordIndex := -1;
  // Messaggio a video
  DM1.ShowWait('Terminale portatile', 'Comunicazione in corso...');
  try
    try
      // Cicla finchè non si è arrivato fino in fondo
      while not SeekEof(FF) do
      begin
        // Legge la riga attuale e la pone in SS
        Readln(FF, SS);
        // Ripulisce il tutto da eventuali spazi di troppo all'inizio e alla fine
        SS := Trim(SS);
        // Carica la riga corrente nella StringList
        SL.DelimitedText := SS;
        // Messaggio a video
        DM1.ShowWait('Caricamento articoli', 'Caricamento riga: ' + SS);
        // Carica i dati correnti nelle variabili di appoggio
        vCodiceArticolo := Trim(SL.Strings[IndexCodiceArticolo]);
        vDescrizione := Trim(SL.Strings[IndexDescrizione]);
        vUM := Trim(SL.Strings[IndexUM]);
        // Qta
        vQta := 0;
        CurrentStr := Trim(SL.Strings[IndexQta]);
        if CurrentStr <> '' then
          vQta := StrToFloat(StringReplace(CurrentStr, '.', '', []));
        // Elimina l'eventuale carattere '.' presente come separatore delle migliaia, per la virgola il caratttere è fisso a ','.
        // Prezzo
        VPrezzo := 0;
        CurrentStr := Trim(SL.Strings[IndexPrezzo]);
        if CurrentStr <> '' then
          VPrezzo := StrToFloat(StringReplace(CurrentStr, '.', '', []));
        // Elimina l'eventuale carattere '.' presente come separatore delle migliaia, per la virgola il caratttere è fisso a ','.
        // Caricamento nuovo rigo
        Row := DC.AppendRecord;
        DC.Values[Row, tvCorpoCODICEMAGAZZINO.Index] := QryDocumentoCODICEMAGAZZINO.AsInteger;
        if not QryDocumentoCODICEMAGAZZINO2.IsNull then
          DC.Values[Row, tvCorpoCODICEMAGAZZINO2.Index] := QryDocumentoCODICEMAGAZZINO2.AsInteger;
        DC.Values[Row, tvCorpoCODICEARTICOLO.Index] := vCodiceArticolo;
        DC.Values[Row, tvCorpoCODICEARTICOLOSTM.Index] := vCodiceArticolo;
        DC.Values[Row, tvCorpoDESCRIZIONE.Index] := vDescrizione;
        DC.Values[Row, tvCorpoUNITADIMISURA.Index] := vUM;
        DC.Values[Row, tvCorpoQTA.Index] := vQta;
        DC.Values[Row, tvCorpoPREZZOUNITARIO.Index] := DM1.Arrotonda(VPrezzo, DM1.DecMicroPrz);
        // Alituotq IVA
        AssegnaAliquotaIVA(DocIvaDefault.Codice, Row, DC);
        // Esegue il ricalcolo del rigo
        CalcolaPerModificaPrezzoUnitario(Row, DC);
        CalcolaImportoRigo(DC, Row);
      end;
      // Messaggio a video
      DM1.ShowWait('Caricamento articoli', 'Chiusura file...');
      // Chiude il file da importare
      CloseFile(FF);
      // Fine messaggi a video
      DM1.CloseWait;
      // Riabilita l'aggiornamento a video della griglia
      GridCorpo.EndUpdate;
      // Visualizza un messaggio
      // MessageBeep(0);
      // MessageDlg('Operazione completata!', mtInformation, [mbOk], 0);
    finally
      // Fine messaggi a video
      DM1.CloseWait;
      // Riabilita l'aggiornamento a video della griglia
      GridCorpo.EndUpdate;
      // Pulisce tutto
      SL.Free;
      // Se abilitato e necessario ricalcola i totali del documento
      CalcolaTotali(False);
    end;
  except
    // Visualizza un messaggio
    MessageBeep(0);
    MessageDlg('Ci sono stati degli errori, l''operazione è stata annullata.'#13#13'Il messaggio di errore verrà visualizzato dopo aver premuto OK.',
      mtInformation, [mbOk], 0);
    raise;
  end;

end;

procedure TPreventiviOrdiniForm.GridEdit(SetEdit: Boolean);
var
  i: Integer;
  tvClone: TcxGridTableView;
begin
  // In base al parametro ricevuto mette la griglia del corpo documento
  // in modalità di editing oppure no
  // tvCorpo.OptionsCustomize.ColumnHorzSizing := SetEdit;
  tvCorpo.OptionsData.Appending := SetEdit;
  tvCorpo.OptionsData.Deleting := SetEdit;
  tvCorpo.OptionsData.Editing := SetEdit;
  tvCorpo.OptionsData.Inserting := SetEdit;

  // TableViewDocCorr.OptionsCustomize.ColumnHorzSizing := SetEdit;
  TableViewDocCorr.OptionsData.Appending := SetEdit;
  TableViewDocCorr.OptionsData.Deleting := SetEdit;
  TableViewDocCorr.OptionsData.Editing := SetEdit;
  TableViewDocCorr.OptionsData.Inserting := SetEdit;

  // TableViewDDTCorr.OptionsCustomize.ColumnHorzSizing := SetEdit;
  TableViewDDTCorr.OptionsData.Appending := SetEdit;
  TableViewDDTCorr.OptionsData.Deleting := SetEdit;
  TableViewDDTCorr.OptionsData.Editing := SetEdit;
  TableViewDDTCorr.OptionsData.Inserting := SetEdit;

  // btvNotifiche.OptionsCustomize.ColumnHorzSizing := SetEdit;
  btvNotifiche.OptionsData.Appending := SetEdit;
  btvNotifiche.OptionsData.Deleting := SetEdit;
  btvNotifiche.OptionsData.Editing := SetEdit;
  btvNotifiche.OptionsData.Inserting := SetEdit;

  tvDiBa.OptionsData.Appending := SetEdit;
  tvDiBa.OptionsData.Deleting := SetEdit;
  tvDiBa.OptionsData.Editing := SetEdit;
  tvDiBa.OptionsData.Inserting := SetEdit;
  // Cicla per tutti i righi principali e mette in editing tutti i DetailRows
  for i := 0 to tvDiBa.CloneCount - 1 do
  begin
    tvClone := (tvDiBa.Clones[i] as TcxGridTableView);
    tvClone.OptionsData.Appending := SetEdit;
    tvClone.OptionsData.Deleting := SetEdit;
    tvClone.OptionsData.Editing := SetEdit;
    tvClone.OptionsData.Inserting := SetEdit;
  end;

  tvOre.OptionsData.Appending := SetEdit;
  tvOre.OptionsData.Deleting := SetEdit;
  tvOre.OptionsData.Editing := SetEdit;
  tvOre.OptionsData.Inserting := SetEdit;
  // Cicla per tutti i righi principali e mette in editing tutti i DetailRows
  for i := 0 to tvOre.CloneCount - 1 do
  begin
    tvClone := (tvOre.Clones[i] as TcxGridTableView);
    tvClone.OptionsData.Appending := SetEdit;
    tvClone.OptionsData.Deleting := SetEdit;
    tvClone.OptionsData.Editing := SetEdit;
    tvClone.OptionsData.Inserting := SetEdit;
  end;

  // Se siamo in modifica attiva il DragDrop
  // NB: Se siamo in modalità di modifica e la QtàEvasa è visibile
  // allora attiva anche il Drag & Drop altrimenti no.
  // Se invece siamo fuori dalla modalità di modifica
  // il Drag & Drop è sempre attivo.
  {
    if SetEdit and (not tvCorpoQTAEVASA.Visible) then begin
    tvCorpo.DragMode  := dmManual;
    tvDiBa.DragMode   := dmManual;
    end else begin
    tvCorpo.DragMode  := dmAutomatic;
    tvDiBa.DragMode   := dmAutomatic;
    end;
  }
end;

procedure TPreventiviOrdiniForm.EspandiTutto;
var
  Y: Integer;
begin
  // Cicla per tutti i record e li collassa tutti
  for Y := 0 to tvCorpo.ViewData.RecordCount - 1 do
  begin
    tvCorpo.ViewData.Records[Y].Expand(False);
  end;
end;

// Funzione che controlla se esiste un altro documento dello stesso tipo e dello stesso
// anno che ha lo stesso numero.
function TPreventiviOrdiniForm.ControllaNumDocStessoAnno: Boolean;
var
  Qry: TIB_Cursor;
  Present: TDateTime;
  Year, Month, Day: Word;
begin
  // Inizializzazione
  Result := False;

  // Se si tratta di un documento di ingresso esce subito
  if DM1.IsDocumentoDiIngresso(QryDocumentoTIPODOCUMENTO.AsString) then
    Exit;

  // Ricava l'anno in corso
  Present := QryDocumentoDATADOCUMENTO.AsDateTime;
  DecodeDate(Present, Year, Month, Day);

  Qry := TIB_Cursor.Create(nil);
  try
    Qry.DatabaseName := DM1.ArcDBFile;
    Qry.IB_Connection := DM1.DBAzienda;
    Qry.SQL.Add('SELECT COUNT(*) AS PRESENTE FROM ' + TestateTable);
    Qry.SQL.Add('WHERE TIPODOCUMENTO = ''' + QryDocumentoTIPODOCUMENTO.AsString + '''');
    Qry.SQL.Add('  AND REGISTRO = ''' + QryDocumentoREGISTRO.AsString + '''');
    Qry.SQL.Add('  AND NUMORDPREV = ' + QryDocumentoNUMORDPREV.AsString);
    Qry.SQL.Add('  AND DATADOCUMENTO >= ''01/01/' + IntToStr(Year) + '''');
    Qry.SQL.Add('  AND DATADOCUMENTO <= ''12/31/' + IntToStr(Year) + '''');
    Qry.SQL.Add('  AND NOT (');
    Qry.SQL.Add('      TIPODOCUMENTO = ''' + TipoDoc + '''');
    Qry.SQL.Add('      AND REGISTRO = ''' + Registro + '''');
    Qry.SQL.Add('      AND NUMORDPREV = ' + IntToStr(NumeroDoc));
    Qry.SQL.Add('      AND DATADOCUMENTO = ''' + FormatDateTime('mm/dd/yyyy', DataDoc) + '''');
    Qry.SQL.Add('      )');
    Qry.Open;
    // Ritorna il risultato
    Result := Qry.Fields[0].AsInteger > 0;
  finally
    Qry.Free;
  end;
end;

// Funzione che controlla se esiste un altro documento dello stesso tipo e dello stesso
// anno che ha lo stesso numero.
function TPreventiviOrdiniForm.ControllaProtocolloDocStessoAnno(ProtNum: Integer): Boolean;
var
  Qry: TIB_Cursor;
  Present: TDateTime;
  Year, Month, Day: Word;
begin
  // Inizializzazione
  Result := False;

  // Ricava l'anno in corso
  // NB: Come riferimento usa la data specificat nell'apposito parametro
  Present := QryDocumento.FieldByName(ProtocolloAutomatico_DataRiferimento_FieldName).AsDateTime;
  DecodeDate(Present, Year, Month, Day);

  Qry := TIB_Cursor.Create(nil);
  try
    Qry.DatabaseName := DM1.ArcDBFile;
    Qry.IB_Connection := DM1.DBAzienda;
    Qry.SQL.Add('SELECT COUNT(*) AS PRESENTE FROM ' + TestateTable);
    Qry.SQL.Add('WHERE PROTOCOLLO = ' + QryDocumentoPROTOCOLLO.AsString);
    if ProtocolloAutomatico_DataRiferimento_FieldName <> '' then
    begin
      Qry.SQL.Add('  AND ' + ProtocolloAutomatico_DataRiferimento_FieldName + ' >= ' + QuotedStr('01/01/' + IntToStr(Year)));
      Qry.SQL.Add('  AND ' + ProtocolloAutomatico_DataRiferimento_FieldName + ' <= ' + QuotedStr('12/31/' + IntToStr(Year)));
    end;
    Qry.SQL.Add('  AND NOT (');
    Qry.SQL.Add('      TIPODOCUMENTO = ''' + TipoDoc + '''');
    Qry.SQL.Add('      AND REGISTRO = ''' + Registro + '''');
    Qry.SQL.Add('      AND NUMORDPREV = ' + IntToStr(NumeroDoc));
    if DataDoc = 0 then
      Qry.SQL.Add('      AND DATADOCUMENTO = ''' + FormatDateTime('mm/dd/yyyy', QryDocumento.FieldByName(ProtocolloAutomatico_DataRiferimento_FieldName).AsDateTime) + '''')
    else
      Qry.SQL.Add('      AND DATADOCUMENTO = ''' + FormatDateTime('mm/dd/yyyy', DataDoc) + '''');
    Qry.SQL.Add('      )');
    Qry.Open;
    // Ritorna il risultato
    Result := Qry.Fields[0].AsInteger > 0;
  finally
    Qry.Free;
  end;
end;

// Funzione che controlla se esiste un altro documento dello stesso tipo e dello stesso
// anno che ha lo stesso numero.
function TPreventiviOrdiniForm.Controlla_RifDocNumStessoAnno_GiaUsato: Boolean;
var
  Qry: TIB_Cursor;
  Present: TDateTime;
  Year, Month, Day: Word;
begin
  // Inizializzazione
  Result := False;

  // Se non tutti i dati necessari sono validi esce subito
  if (QryDocumentoRIFDOC_TIPO.AsString = '') or (QryDocumentoRIFDOC_NUM.AsInteger = 0) or (QryDocumentoRIFDOC_DATA.IsNull) or
    (QryDocumentoRIFDOC_DATA.AsFloat = 0) then
    Exit;

  // Se si tratta di un documento di ingresso esce subito
  if DM1.IsDocumentoDiIngresso(QryDocumentoTIPODOCUMENTO.AsString) then
    Exit;

  // Ricava l'anno in corso
  Present := QryDocumentoDATADOCUMENTO.AsDateTime;
  DecodeDate(Present, Year, Month, Day);

  Qry := TIB_Cursor.Create(nil);
  try
    Qry.DatabaseName := DM1.ArcDBFile;
    Qry.IB_Connection := DM1.DBAzienda;
    Qry.SQL.Add('SELECT COUNT(*) AS PRESENTE FROM ' + TestateTable);
    Qry.SQL.Add('WHERE RifDoc_Tipo = ' + QuotedStr(QryDocumentoRIFDOC_TIPO.AsString));

    // Nel caso il registro non fosse specificato nel RifDoc
    if Trim(QryDocumentoRIFDOC_REG.AsString) = '' then
      Qry.SQL.Add('  AND TRIM(COALESCE(RifDoc_Reg,'''')) = ' + QuotedStr(''))
    else
      Qry.SQL.Add('  AND RifDoc_Reg = ' + QuotedStr(QryDocumentoRIFDOC_REG.AsString));

    Qry.SQL.Add('  AND RifDoc_Num = ' + QryDocumentoRIFDOC_NUM.AsString);
    Qry.SQL.Add('  AND RifDoc_Data >= ' + QuotedStr('01/01/' + IntToStr(Year)));
    Qry.SQL.Add('  AND RifDoc_Data <= ' + QuotedStr('12/31/' + IntToStr(Year)));
    Qry.SQL.Add('  AND NOT (');
    Qry.SQL.Add('      TIPODOCUMENTO = ' + QuotedStr(TipoDoc));
    Qry.SQL.Add('      AND REGISTRO = ' + QuotedStr(Registro));
    Qry.SQL.Add('      AND NUMORDPREV = ' + IntToStr(NumeroDoc));
    Qry.SQL.Add('      AND DATADOCUMENTO = ' + QuotedStr(FormatDateTime('mm/dd/yyyy', DataDoc)));
    Qry.SQL.Add('      )');
    Qry.Open;
    // Ritorna il risultato
    Result := Qry.Fields[0].AsInteger > 0;
  finally
    Qry.Free;
  end;
end;

// Funzione che controlla che non si possa emettere un documento con numerazione
// successiva ma data successiva al documento precedentemente emesso.
function TPreventiviOrdiniForm.ControllaSuccessioneNumerazione: Boolean;
var
  Qry: TIB_Cursor;
  Present: TDateTime;
  Year, Month, Day: Word;
begin
  // Inizializzazione
  Result := False;

  // Se si tratta di un documento di ingresso esce subito
  if DM1.IsDocumentoDiIngresso(QryDocumentoTIPODOCUMENTO.AsString) or (QryDocumentoTIPODOCUMENTO.AsString = 'Intervento') then
    Exit;

  // Ricava l'anno in corso
  Present := QryDocumentoDATADOCUMENTO.AsDateTime;
  DecodeDate(Present, Year, Month, Day);

  Qry := TIB_Cursor.Create(nil);
  try
    Qry.DatabaseName := DM1.ArcDBFile;
    Qry.IB_Connection := DM1.DBAzienda;
    Qry.SQL.Add('SELECT COUNT(*) AS PRESENTE FROM ' + TestateTable);
    Qry.SQL.Add('WHERE TIPODOCUMENTO = ''' + QryDocumentoTIPODOCUMENTO.AsString + '''');
    Qry.SQL.Add('  AND REGISTRO = ''' + QryDocumentoREGISTRO.AsString + '''');
    Qry.SQL.Add('  AND NUMORDPREV < ' + QryDocumentoNUMORDPREV.AsString);
    Qry.SQL.Add('  AND DATADOCUMENTO > ''' + FormatDateTime('mm/dd/yyyy', QryDocumentoDATADOCUMENTO.AsDateTime) + '''');
    Qry.SQL.Add('  AND DATADOCUMENTO <= ''12/31/' + IntToStr(Year) + '''');
    // Qry.SQL.Add('  AND NOT (');
    // Qry.SQL.Add('      TIPODOCUMENTO = ''' + TipoDoc + '''');
    // Qry.SQL.Add('      AND REGISTRO = ''' + Registro + '''');
    // Qry.SQL.Add('      AND NUMORDPREV = ' + IntToStr(NumeroDoc));
    // Qry.SQL.Add('      AND DATADOCUMENTO = ''' + FormatDateTime('mm/dd/yyyy', DataDoc) + '''');
    // Qry.SQL.Add('      )');
    Qry.Open;
    // Ritorna il risultato
    Result := Qry.Fields[0].AsInteger > 0;
  finally
    Qry.Free;
  end;
end;

procedure TPreventiviOrdiniForm.RxSpeedModificaClick(Sender: TObject);
var
  MR: TModalResult;
  PrecEditSQL: TStrings;
begin
  if BeforeNewDocForm <> nil then
    BeforeNewDocForm.Close;
  // Se il registro del documento è quello dei documenti esterni (MAGO) e però il registro
  // relativo non è più presente (perchè sono stati scaricati i documenti esterni mentre
  // questo era in modifica oppure era nuovo) annulla l'operazione altrimenti
  // sarebbe un casino
  if (QryDocumentoREGISTRO.AsString = EXT_DOC_REGISTRO) and (not DM1.ExternalDocsPresent) then
  begin
    RxSpeedModifica.Down := not RxSpeedModifica.Down;
    DM1.Messaggi('Documento', 'Il registro del documento non è più valido.', '', [mbOk], 0, nil);
    Exit;
  end;
  // Fà in modo che il focus non sia su una DetailView perchè altrimenti darebbe dei problemi
  GridCorpo.FocusedView := tvCorpo;
  // A seconda che il tasto sia abbassato o meno svolge la funzione di
  // attivare la modifica dei campi o disabilitarla.
  if RxSpeedModifica.Down then
  begin
    // Controlla che il documento non sia a sola lettura
    if SolaLettura then
    begin
      RxSpeedModifica.Down := False;
      DM1.ChiudiAttendere;
      DM1.Messaggi('Informazione', 'Documento non modificabile.', '', [mbOk], 0, nil);
      Exit;
    end;

    // Se è una fattura ed è già stata inviata (o preparata per l'invio) non la fa modificare
    //  Se dobbiamo operare noi per assistenza richiede una password per poter continuare ugualmente.
    //  NB: Se siamo in modalità "teletrasporto" allora deve permettere la modifica anche se il documento
    //       sarebbe ReadOnly per rendere possibile l'apertura della fattura anche quando la si sta
    //       importando dal teletrasporto.
    if (TFatturaPA.IsReadOnly(QryDocumentoTIPODOCUMENTO.AsString, QryDocumentoFE_STATUS.AsString) and (Tag <> MODE_TELETRASPORTO))
    and not TConfirmForm.AuthorizationRequest('Documento non modificabile', 'Il documento non può essere modificato perchè inviato all''S.D.I. oppure è una fattura elettronica passiva.', 'th3cla')
    then
    begin
      RxSpeedModifica.Down := False;
      Exit;
    end;

    // Prima di avviare la modifica controlla se il record è stato o meno creato da questa postazione e quindi
    // se si è autorizzati alla sua modifica (se sincronizzazione attiva).
    if not DM1.ControllaSeProprioRegistro(QryDocumentoREGISTRO.AsString) then
    begin
      RxSpeedModifica.Down := False;
      DM1.ChiudiAttendere;
      Exit;
    end;
    // Tenta di abilitare la modifica dell'archivio; se non ci riesce rimette
    // tutto a posto.
    try
      try
        DM1.Attendere;
        // Disabilita i controlli legati agli archivi dei documenti
        QryDocumento.DisableControls;
        // Procedure che azzera gli array dei documenti importati
        ImportedDocuments_Reset(fImportedDocumentsArray);
        // Solo se non si è attivata l'aggiunta del codice chiave ai codici per la SINCRONIZZAZIONE permette di modificare il registro del
        // documento e il magazzino del documento.
        if DM1.AggiungiCodiceChiaveAiCodici then
        begin
          BitBtnMagazzino.Enabled := False;
          DBEditMagazzino.ParentColor := False;
          DBComboRegistro.Enabled := False;
          DBComboRegistro.ParentColor := False;
          // Non permette la modifica se è in modalità SOLA LETTURA
        end
        else if not SolaLettura then
        begin
          // Abilita la modifica dei campi
          QryDocumento.Edit;
          // Abilita l'editing del corpo documento
          GridEdit(True);
          // Modifica la visualizzazione dei controlli
          // per la modalità di modifica
          RxSpeedButtonElimina.Enabled := True;
          RxSpeedButtonNuovo.Enabled := True and not MainForm.IsLevanteLight;
          // RxSpeedButtonTrova.Enabled := True and not MainForm.IsLevanteLight;
          BitBtnPratica1.Enabled := True;
          BitBtnPratica1_1.Enabled := True;
          BitBtnPratica2.Enabled := True;
          BitBtnPratica3.Enabled := True;
          BitBtnCliente.Enabled := True;
          BitBtnDestinazioneMerci.Enabled := True;
          BitBtnSelezioneStato.Enabled := True;
          BitBtnSubSogg.Enabled := True;
          BitBtnCausale.Enabled := True;
          BitBtnPagamento.Enabled := True;
          BitBtnBanca.Enabled := True;
          BitBtnForzaIva.Enabled := True;
          SbRifSogg1.Enabled := True;
          SbRifSogg2.Enabled := True;
          SbRifSogg3.Enabled := True;
          SbRifSogg4.Enabled := True;
          SbRifSogg5.Enabled := True;
          SbRifSogg6.Enabled := True;
          SbRifSogg7.Enabled := True;
          SbRifSogg8.Enabled := True;
          SbRifSogg9.Enabled := True;
          SbRifSogg10.Enabled := True;
          ExtTermImport.Enabled := True;
          SBCalcola1.Enabled := True;
          SBCalcola2.Enabled := True;
          SBCalcola3.Enabled := True;
          BitBtnMagazzino.Enabled := True;
          BitBtnMagazzino2.Enabled := True;
          AddArt.Text := '';
          DbeAzioneMagazzino.Enabled := True;
          DbeAzioneCantiere.Enabled := True;
          AbilitaPanelloVariazioneMargine(True);
          StampaClientArea.Enabled := True;
          // Flag che se True fa in modo che sia possibili modificare il registro dei documento solo
          // alla creazione del documento stesso e non lo consente più successivamente.
          DBComboRegistro.Enabled := not(DM1.ModificaRegistroSoloNuovoDocumento and (not QryDocumentoNUMORDPREV.IsNull));
          // Se siamo in modalità di gestione di versioni diverse dello stesso documento
          // fa in modo che non si possano modificare manualmente il numero del documento stesso
          // e il registro o meglio li rende modificabili solo se sono entrambi nulli.
          if AbilitaGestioneVersioniDocumento and ((not QryDocumentoNUMORDPREV.IsNull) or (not QryDocumentoREGISTRO.IsNull)) then
          begin
            DBEditNumDoc.Enabled := False;
            DBComboRegistro.Enabled := False;
          end;
        end;
        // Modifica la visualizzazione dei controlli
        // per la modalità di modifica
        RxSpeedButtonStampa.Enabled := False;
        RxSpeedButtonFax.Enabled := False;
        RxSpeedButtonMail.Enabled := False;
        if Tag = MODE_KIOSK then
          RxSpeedButtonUscita.Enabled := True
        else
          RxSpeedButtonUscita.Enabled := False;
        if QryDocumentoNUMORDPREV.IsNull or (QryDocumentoNUMORDPREV.AsInteger = 0) then
          MainForm.SBTipoDocumento.Enabled := True;
        // Colora tutti i campi per la modofica
        DM1.ColoraTuttiCampi(PreventiviOrdiniForm, COLOR_MODIFICA);
        // tvCorpo.Styles.Background := DM1.tvBackgroundModifica;
        // tvCorpo.Styles.ContentEven := DM1.tvContentEvenModifica;
        // tvCorpo.Styles.ContentOdd := DM1.tvContentOddModifica;
        tvCorpo.Styles.ContentOdd := DM1.tvContentEvenModifica;
        TableViewDocCorr.Styles.Background := DM1.tvBackgroundModifica;
        TableViewDocCorr.Styles.ContentEven := DM1.tvContentEvenModifica;
        TableViewDocCorr.Styles.ContentOdd := DM1.tvContentOddModifica;
        TableViewDDTCorr.Styles.Background := DM1.tvBackgroundModifica;
        TableViewDDTCorr.Styles.ContentEven := DM1.tvContentEvenModifica;
        TableViewDDTCorr.Styles.ContentOdd := DM1.tvContentOddModifica;
        // Se il documento è visibile riposiziona il focus...
        // NB: Verifica anche che non si sia sul pannello delle preferenze di stampa
        if Visible and (ClientArea.ActivePage = TabDoc) then
        begin
          // Se la variabile FocusDestinatario = True pone il focus sulla RagSoc del SOggetto, altrimenti sul corpodoc
          // GridCorpo.SetFocus; // Altrimenti dà un errore
          TrovaArt.SetFocus; // Altrimenti dà un errore
          if (FocusDestinatario) and (QryDocumentoCODICECLIENTE.AsInteger = 0) then
            DBERagSocCli.SetFocus
          else
            AddArt.SetFocus;
          // Se si tratta di un documento di ingresso, mette il focus sul numero del documento (coaì hanno chiesto)
          if DM1.IsDocumentoDiIngresso(QryDocumentoTIPODOCUMENTO.AsString) and not NumerazioneAutomatica then
            DBEditNumDoc.SetFocus;
        end;
      finally
        // Riabilita i controlli legati agli archivi dei documenti
        QryDocumento.EnableControls;
        // Chiude le varia attese
        DM1.ChiudiAttendere;
        DM1.CloseWait;
      end;
    except
      on E: Exception do
      begin
        MessageBeep(0);
        MessageDlg(E.Message, mtError, [mbOk], 0);
        RxSpeedModifica.Down := False;
        // Riabilita i controlli legati agli archivi dei documenti
        QryDocumento.EnableControls;
      end;
    end;
  end
  else
  begin
    // Gestisce l'eccezione nel caso qualche cosa vada storto
    try
      try
        // Se è in modalità MODE_TELETRASPORTO richiama la form per il Check-In
        // NB: Lo metto prima di aprire i messaggi di attesa perchè altrimenti
        // il mouse è a clessidra
        // NB: Se non siamo in modalità TELETRASPORTO verifica se però è abilitata la
        // gestione delle versioni multiple del documento, nel qual caso
        // al posto della richiesta di conferma classica richiede quella apposita.
        if Tag = MODE_TELETRASPORTO then
          DM1.ConfermaCheckIn
        else if AbilitaGestioneVersioniDocumento then
          GestVerDoc_ChiediConferma;
        // Attesa
        DM1.Attendere;

        // ---------------------------------------------------------------------------------------------
        // Chiede di confermare le modifiche o di annullare l'operazione
        // NB: Se è in modalità KIOSK oppure il FATTURAZIONE DIFFERITA evita la dialog di conferma
        // NB: Anche se è una distinta base
        if (Tag = MODE_KIOSK) or (Tag = MODE_FATTURAZIONE_DIFFERITA) then
          MR := mrYes
        else if ModalResultConferma <> mrNone then
          MR := ModalResultConferma
        else
          MR := DM1.ConfermaModifiche;

        // Se l'utente ha confermato il documento, prima di andare avanti verifica se il cliente
        // ho sforato il fido concessogli, nel qual caso avvisa l'utente e poi
        // forza MR = mrCancel in modo che la conferma del documento venga annullata
        // NB: Solo se stiamo facendo una Fattura oppure una Fattura R.F. oppure una NOta di credito fornitore
        if (MR = mrYes) and (not MainForm.IsLevanteLight) and ClientiForm.ControllaScopertoCliente(QryDocumentoTIPODOCUMENTO.AsString,
          QryDocumentoNUMORDPREV.AsInteger, QryDocumentoREGISTRO.AsString, QryDocumentoDATADOCUMENTO.AsDateTime, QryDocumentoCODICECLIENTE.AsString,
          QryDocumentoTOTALEDAPAGARE.AsCurrency, True) then
          MR := mrCancel;

        // Controllo Codice FIscale e Partita IVA
        // NB: Non controlla se cliente estero (partit IVA e Codice Fiscale sono diversi se esteri quindi fallirebbero tutti
        if MR = mrYes then
        begin
          // Focus
          if dbePartitaIVA.Focused then
          begin
            dbeCodiceFiscale.SetFocus;
            dbePartitaIVA.SetFocus;
          end
          else if dbeCodiceFiscale.Focused then
          begin
            dbePartitaIVA.SetFocus;
            dbeCodiceFiscale.SetFocus;
          end;
          // Mauri 06/06/2020: Ho eliminato questa verifica del codice fiscale perchè tanto c'è già sia nell'anagrafica del soggetto che all'invio della fattura elettronica
          // (che è la più importante). Qua mi dava fastidio dopo che ho aggiunto la verifica dei primi sei caratteri del cod.fisc. che corrispondano al nome e cognome
          // del cliente, il problema era che sul documento non ho nome e cognome.
          // // Controllo
          // if ((QryDocumentoTIPODOCUMENTO.AsString = 'Fattura') or (QryDocumentoTIPODOCUMENTO.AsString = 'Fatt.R.F.') or (QryDocumentoTIPODOCUMENTO.AsString = 'Nota_accre')) and
          // not DM2.ControlloCodiceFiscalePartitaIva(QryDocumentoCODICEFISCALECLI.AsString, QryDocumentoPARTITAIVACLI.AsString, QryDocumentoNAZIONESIGLA.AsString,
          // QryDocumentoTIPOPERSONA.AsString, False) then
          // MR := mrCancel;
        end;

        // In base alla risposta se annullare o confermara fà l'azione corretta.
        if MR = mrYes then
        begin
          // Se si tratta di un documento di ingresso, ritorna un errore di numero documento non inserito
          // NBScad: HO messo anche qui il controllo (c'è anche più sotto) perchè altrimenti quando inserivo un nuovo documento
          // di ingresso e mi dimenticavo di inserire il numero a mano mi dava l'errore e dopo spariva i dati della
          // testata e quindi non potevo più confermare il dcumento stesso e lo perdevo.
          if DBEditNumDoc.Focused then
          begin
            AddArt.SetFocus;
            DBEditNumDoc.SetFocus;
          end;
          if QryDocumentoNUMORDPREV.IsNull and not NumerazioneAutomatica then
            raise Exception.Create('Numero documento non inserito.');
          // Nel caso sia abilitato ilrelativo flag controlla che il documento
          // abbia il soggetto selezionato altrimenti non ne permette la conferma
          if (not MainForm.IsLevanteLight) and ConfermaDocSoloConSoggettoSelezionato and
            ((QryDocumentoCODICECLIENTE.IsNull) or (QryDocumentoCODICECLIENTE.AsInteger = 0)) then
          begin
            DM1.Messaggi('ATTENZIONE!!!', 'Soggetto non selezionato.'#13#13'Conferma annullata!', '', [mbOk], 0, nil);
            RxSpeedModifica.Down := True;
            Exit;
          end;
          // Nel caso sia abilitato ilrelativo flag controlla che il documento
          // abbia una pratica selezionato altrimenti non ne permette la conferma
          if (not MainForm.IsLevanteLight) and ConfermaDocSoloConPraticaSelezionata and (QryDocumentoPRATICA.IsNull) then
          begin
            DM1.Messaggi('ATTENZIONE!!!', 'Pratica/Cantiere non selezionata.'#13#13'Conferma annullata!', '', [mbOk], 0, nil);
            RxSpeedModifica.Down := True;
            Exit;
          end;
          // Nel caso sia abilitato ilrelativo flag controlla che il soggetto
          // intestatario del documento sia lo stesso soggetto intestatario della pratica
          // ovviamente il documento deve far parte di una pratica.
          if (not MainForm.IsLevanteLight) and ConfermaDocSoloSeStessoSoggettoDocEPratica and
            ((QryDocumentoPRATICA.IsNull) or (QryDocumentoCODICECLIENTE.IsNull) or (QryDocumentoCODICECLIENTE.AsInteger = 0) or
            (QryDocumentoCODICECLIENTE.AsInteger <> DM1.GetCodiceSoggettoPratica(QryDocumentoPRATICA.AsInteger, QryDocumentoDATAPRATICA1.AsDateTime))) then
          begin
            DM1.Messaggi('ATTENZIONE!!!',
              'Il soggetto intestatario del documento e il soggetto intestatario della pratica/cantiere della quale il documento fa parte devono combaciare.'#13#13'Conferma annullata!',
              '', [mbOk], 0, nil);
            RxSpeedModifica.Down := True;
            Exit;
          end;
          // Nel caso sia abilitato ilrelativo flag controlla che lo STATO sia stato selezionato
          // altrimenti non consente la conferma del documento
          if (not MainForm.IsLevanteLight) and ConfermaDocSoloConStatoSelezionato and
            ((QryDocumentoSTATODESCRIZIONE.IsNull) or (Trim(QryDocumentoSTATODESCRIZIONE.AsString) = '')) then
          begin
            DM1.Messaggi('ATTENZIONE!!!', 'STATO del documento non selezionato.'#13#13'Conferma annullata!', '', [mbOk], 0, nil);
            RxSpeedModifica.Down := True;
            Exit;
          end;
          // --------------------------------------------------------------




          // ==============================================================
          // Parte di avvio transazione e preparazione Dataset
          // NB: SPOSTATO PIU' SOTTO PER RISOLVERE ALCUNI PROBLEMI
          // --------------------------------------------------------------
          // NB: Se è un intervento non esegue nulla di tutto ciò perchè il controllo della transazione è fatto dalla parte "APPUNTAMENTO" del documento
          // if not IsImpegno then begin
          // // Verifica che non ci siano già transazioni in atto e se ci sono lanca un allarme
          // DM1.CheckForAlreadyInTransaction;
          // DM1.DBAzienda.StartTransaction;
          // end;
          // try
          // ==============================================================

          // Disabilita i controlli legati agli archivi dei documenti
          QryDocumento.DisableControls;
          // Disabilita la modifica dei campi
          QryDocumento.Edit;
          // ------------------------------------------------------------
          // Azzera il Flag
          ModalResultConferma := mrNone;
          // Visualizza il messaggio di operazione in corso
          DM1.ShowWait('Documento', 'Conferma documento');
          // Rigenera i valori di ORDER in modo da avere solo numeri interi
          RefreshOrderValues(tvCorpo);
          // Prima di richiedere l'eventuale numero progressivo del nuovo documento
          // sposta il focus su un componente perchè se si è appena selezionato un altro
          // registro e non ci si è spostati su un altro controllo togliendo il focus considera
          // ancora il regitro precedentemente impostato e quindi assegna il progressivo errato.
          if Visible and (ClientArea.ActivePage = TabDoc) then
            AddArt.SetFocus
          else if Visible and (ClientArea.ActivePage = TabDocumentiCorrelati) then
            ClientArea.SetFocus;

          // Sposta il focus nella form laterale con i dati del rigo in modo che il dato
          // che magari è stato appena inserito ma non confermato con Invio o spostandosi su
          // un altro controllo...
          // NB: Sposto il focus in vari controlli perchè altrimenti se uno non era visibile dava un errore.
          Self.SpostaFocus;

          // ============================================================
          // PARTE CHE ASSEGNA IL NUMERO DOCUMENTO E IL REGISTRO IN BASE
          // ALLA SITUAZIONE
          // ------------------------------------------------------------
          // Se è attivata la gestione delle versioni multiple dello stesso documento...
          if Self.AbilitaGestioneVersioniDocumento then
          begin
            // Se il documento non è nuovo (NumOrdPrev isNotNull) e l'utente ha scelto di salvarlo come documento
            // completamente ex-novo gli assegna un nuovo numero documento e revisione 01.
            // Per fare questo rende nulli sia il numero attuale del documento che il registro così le righe
            // qui sotto lo trattano come se fosse un documento ex-novo.
            if GestVerDoc_Mode = mfNuovoProtocollo then
            begin
              QryDocumentoNUMORDPREV.Clear;
              QryDocumentoREGISTRO.Clear;
            end;
            // Se il numero del documento è nullo significa che è la prima stesura
            // del documento e quindi gli assegna un nuovo numero documento e la versione 01
            if QryDocumentoNUMORDPREV.IsNull then
            begin
              QryDocumentoNUMORDPREV.Value := DM1.NextNumDocFisc_GestVerDoc(QryDocumentoTIPODOCUMENTO.Value, QryDocumentoDATADOCUMENTO.Value);
              QryDocumentoREGISTRO.Value := GestVerDoc_NextRegistro;
              // Se il documento non è nuovo (NumOrdPrev isNotNull)  e l'utente ha scelto di salvarlo come
              // una nuova versione dello stesso documento, gli lascia lo stesso numero documento e gli
              // assegna la revisione successiva nel registro
            end
            else if (not QryDocumentoNUMORDPREV.IsNull) and (GestVerDoc_Mode = mfNuovaVersione) then
            begin
              QryDocumentoREGISTRO.Value := GestVerDoc_NextRegistro;
            end;
            // Quindi se l'utente ha selezionato di salvare il documento come ex-novo oppure come
            // una nuova versione dello stesso documento devo copiare la InsertSQL di UpdateDocumento
            // nella proprietà EditSQL di QryDocumento in modo che invece di fare l'Update della testata
            // esistente ne crei una nuova (questo grazie al fatto che ho verificato che la proprietà
            // EditSQL ha la priorità rispetto alla MOdifySQL del componente UpdateSQL.
            if (GestVerDoc_Mode = mfNuovaVersione) or (GestVerDoc_Mode = mfNuovoProtocollo) then
            begin
              // Salva la EditSQL per poi ripristinarla
              PrecEditSQL := TStringList.Create;
              PrecEditSQL.AddStrings(QryDocumento.EditSQL);
              // Modifica la EditSQL
              QryDocumento.EditSQL.Clear;
              QryDocumento.EditSQL.AddStrings(QryDocumento.InsertSQL);
            end;
            // Se invece NON è attivata la gestione delle versioni multiple dello stesso documento...
          end
          else
          begin
            // Se non è già assegnato un numero documento provvede ad assegnarne uno automaticamente
            if QryDocumentoNUMORDPREV.IsNull then
            begin
              // Se si tratta di un documento di ingresso, ritorna un errore di numero documento non inserito
              if not NumerazioneAutomatica then
              begin
                raise Exception.Create('Numero documento non inserito.');
                // Altrimenti se un documento di uscita assegna automaticamente il codice documento.
              end
              else
                QryDocumentoNUMORDPREV.Value := DM1.NextNumDocFisc(QryDocumentoTIPODOCUMENTO.Value, QryDocumentoREGISTRO.Value, QryDocumentoDATADOCUMENTO.Value,
                  fNumDocUnivoco_ProgressivoInfinito);
            end;
          end;
          // ============================================================

          // Assegna l'operatore dell'ultima modofica e di creazione
          QryDocumentoDATAULTMOD_ULTMOD.Value := Now;
          QryDocumentoOPERATOREULTMOD_ULTMOD.Value := DM1.IDOperatoreCorrente;
          // Se il codice a barre del documennto non è ancora stato assegnato, lo assegna
          if QryDocumentoBARCODE.IsNull or (QryDocumentoBARCODE.AsString = '') then
            QryDocumentoBARCODE.Value := DM1.NextBarcodeDocumento(QryDocumentoTIPODOCUMENTO.AsString, QryDocumentoNUMORDPREV.AsInteger,
              QryDocumentoREGISTRO.AsString, QryDocumentoDATADOCUMENTO.AsDateTime);

          // Se è attivato il numero di protocollo progressivo automatico per le fatture di acquisto provvede
          // ad assegnarlo al documento
          //  NB: IN base allìapposito parametro, come data di riferimento per un nuovo protocollo automatico, usa
          //       la DataProtocollo stessa oppure la data di creazione del documento
          if ProtocolloAutomatico and (not QryDocumento.FieldByName(ProtocolloAutomatico_DataRiferimento_FieldName).IsNull) and (QryDocumentoPROTOCOLLO.AsInteger = 0) then
            QryDocumentoPROTOCOLLO.Value := DM1.NextProtocolloDocFisc(QryDocumento.FieldByName(ProtocolloAutomatico_DataRiferimento_FieldName).AsDateTime, ProtocolloAutomatico_DataRiferimento_FieldName);

          // Controlla che non ci sia un altro documento dello stesso tipo con lo stesso numero nello stesso anno.
          if ControllaNumDocStessoAnno and (not Self.IsImpegno) then
            raise Exception.Create('Un documento con lo stesso numero è già presente.');

          // Verifica protocollo
          if (not QryDocumentoPROTOCOLLO.IsNull) and ControllaProtocolloDocStessoAnno(QryDocumentoPROTOCOLLO.Value) then
            raise Exception.Create('ATTENZIONE !!!'#13#13'Un documento con lo stesso protocollo è già presente.');

          // ==================================================================================================================
          // Controlla che non si possa emettere ad es. una fattura con numero successivo ma data precedente alla fattura prima
          // ------------------------------------------------------------------------------------------------------------------
          if (not MainForm.IsLevanteLight) and ControllaSuccessioneNumerazione then
          begin
            // Se si tratta di un tipo documento per il quale deve essere garantita la corretta progressione del numero
            //  rispetto alla data allora esce subito
            if fGarantisciProgressioneNumDoc then
            begin
              DM1.Messaggi('Levante', 'C''è un problema con il numero o la data.'#13#13'La data non può essere antecedente a quella del documento precedente.', '', [mbOK], 0, nil);
              RxSpeedModifica.Down := True;
              Exit;
            end
            // Altrimenti se la progressione rispetto la data NON deve essere garantita allora visualizza solo un avvertimento
            else
            begin
              if DM1.Messaggi('Levante',
                'Si sta inserendo una documento con numero successivo ma data antecedente al documento precedente.'#13#13'Continuare ugualmente?', '',
                [mbYes, mbNo], 0, nil) <> mrYes then
              begin
                RxSpeedModifica.Down := True;
                Exit;
              end;
            end;
          end;
          // ==================================================================================================================

          // ==============================================================
          // Parte di avvio transazione e preparazione Dataset
          // NB: PRIMA ERA PIU' SOPRA
          // --------------------------------------------------------------
          // Parte di avvio transazione e preparazione Dataset
          // NB: Se è un intervento non esegue nulla di tutto ciò perchè il controllo della transazione è fatto dalla parte "APPUNTAMENTO" del documento
          if not IsImpegno then
          begin
            // Verifica che non ci siano già transazioni in atto e se ci sono lanca un allarme
            DM1.CheckForAlreadyInTransaction;
            DM1.DBAzienda.StartTransaction;
          end;
          try
            // ==============================================================

            // Se il mese di competenza non è già assegnato gli assegna il mese della data del documento automaticamente
            if QryDocumentoMESECOMPETENZA.IsNull then
              AggiornaMeseDiCompetenzaFatturazione(QryDocumentoDATADOCUMENTO.Value);
            // Se è una distintabase aggiorna sempre il tipo documento con il CodiceArticolo aggiornato
            if DistintaBase then
              QryDocumentoTIPODOCUMENTO.Value := AnagArtForm.QryArtCODICEARTICOLO.AsString;
            // Controlla: se tutti righi sono IMportati o Esportati o entrambi controlla ed eventualmente aggiorna lo stato
            // della testata documento, adeguandola
            ControllaSeTuttiRighiImportExport;
            // Se la colonna QTAEVASA è visibile assegna automaticamente lo stato in base al fatto che vi siano o meno
            // ancora righi da evadere
            ImpostaStatoOrdineFornitore;
            // Effettua il salvataggio delle preferenze di stampa del documento
            DM1.ShowWait('', 'Salvataggio preferenze di stampa documento.');
            StmPref_SavePreferences;
            // Ricalcola i totali del documento.
            // NB: Se siamo nel teletrasporto non deve mai ricalcolare nulla
            // NB: PRIMA ERA QUALCHE RIGA PIU' SOTTO OA HO PROVATO A METTERLA QUI
            if not SolaLettura then
            begin
              DM1.ShowWait('', 'Ricalcolo totali documento');
              CalcolaTotali(True);
            end;
            // Effettua il post
            QryDocumento.Post;
            // IN ogni caso azzera la proprietà EditSQL di QryDocumento perchè potrebbe essere stata valorizzata con
            // la query di tipo insert (Vedi la parte per la gestione delle versioni multiple dello stesso documento
            // poco più sopra nella parte per l'assegnazione di un nuovo numero documento).
            // Ripristina la EditSQL se è il caso
            // NB: Lo fa anche nel blocco finally per sicurezza
            if Assigned(PrecEditSQL) then
            begin
              QryDocumento.EditSQL.Clear;
              QryDocumento.EditSQL.AddStrings(PrecEditSQL);
            end;
            // Se siamo in un documento di ingresso verifica se ci sono degli articoli che non sono inseriti
            // nell'archivio articoli e se non lo sono li aggiunge automaticamente
            if FCaricamentoAutomaticoNuoviArticoli and not MainForm.IsLevanteLight then
              ControllaNuoviArticoliDaInserire(tvCorpo.DataController);
            // Chiede se si voglio generare le scadenze relative al documento
            // solo se si tratta di una fattura.
            if (not MainForm.IsLevanteLight) and fScadenzeCreazioneAutomatica then
              CreazioneAggiornamentoScadenzeDocumento;
            // COntrolla se i prezzi di acquisto (nel caso di documenti di acquisto) dei singoli articoli
            // sono cambiato rispetto a quanto inserito nell'archivio articoli ed eventualmente
            // li aggiorna chiedendo prima conferma all'operatore
            if (not MainForm.IsLevanteLight) and AggiornamentoAutomaticoPrezziDiAcquisto and DM1.IsDocumentoDiIngresso(TipoDoc) then
              ControllaCOrrispondenzaPrezzoDiAcquistoDiTuttiIRighi;
            // Verifica e avverte se il documento sta scaricando degli articoli oltre la qtà residua
            // disponibile nel cantiere stesso
            if (not MainForm.IsLevanteLight) and VerificaSottoscortaCantiere then
              ControllaSottoscortaCantiere;
            // Se il flag lo attiva converte le descrizioni degli articoli del documento nella descrizione del gruppo
            // di appartenenza dell'articolo stesso (1 livello)
            if (not MainForm.IsLevanteLight) and AbilitaConversioneDescArtToDescGruppo then
              ConvertiDescArtInDescGruppo(tvCorpo.DataController);
            // Se ci sono righi con QtàInEvasione > 0 li evade...
            EvadiQtaInEvasione(tvCorpo.DataController, True);
            // Salva le modifiche dei righi del documento nel file 'RighiPrv'.
            SalvaRighiDocumento(QryDocumentoTIPODOCUMENTO.Value, QryDocumentoREGISTRO.Value, QryDocumentoNUMORDPREV.Value, QryDocumentoDATADOCUMENTO.Value,
              QryDocumentoCODICECLIENTE.Value, AbilitaAccorpamentoRighi);
            DM1.ShowWait('', 'Salva dati documenti correlati (Fattura elettronica)');
            SalvaDocumentiCorrelatiPA(QryDocumentoTIPODOCUMENTO.Value, QryDocumentoREGISTRO.Value, QryDocumentoNUMORDPREV.Value,
              QryDocumentoDATADOCUMENTO.Value);
            DM1.ShowWait('', 'Conferma documento');
            // Aggiunge il soggetto attuale alle eventuali pratiche in cui il documento è inserito.
            if (not QryDocumentoPRATICA.IsNull) and (QryDocumentoPRATICA.Value > 0) then
              DM1.AggiungiSoggettoAllaPratica(QryDocumentoPRATICA.Value, QryDocumentoDATAPRATICA1.Value, QryDocumentoCODICECLIENTE.Value);
            if (not QryDocumentoPRATICA2.IsNull) and (QryDocumentoPRATICA2.Value > 0) then
              DM1.AggiungiSoggettoAllaPratica(QryDocumentoPRATICA2.Value, QryDocumentoDATAPRATICA2.Value, QryDocumentoCODICECLIENTE.Value);
            if (not QryDocumentoPRATICA3.IsNull) and (QryDocumentoPRATICA3.Value > 0) then
              DM1.AggiungiSoggettoAllaPratica(QryDocumentoPRATICA3.Value, QryDocumentoDATAPRATICA3.Value, QryDocumentoCODICECLIENTE.Value);
            // Procedura che marca gli eventuali documenti importati presenti nell'appposito
            // array come fatturati oppure e impostato lo come DopoFAtturato o similare
            // ed eventualmente marca i documenti importati con corrispettivo non pagato
            // come chiusi.
            // Il tutto in base a come impostato il tipo documento attuale nel layouts.ini
            // (in pratica adesso possiamo decidere ad esempio che anche un preventivo possa marcare
            // i documneti importati come fatto)
            ImportedDocuments_SetMarkersAfterImported;
            // Se tutto è andato esegue il Commit
            // NB: Se è un intervento non esegue nulla di tutto ciò perchè il controllo della transazione è fatto dalla parte "APPUNTAMENTO" del documento
            if not IsImpegno then
              DM1.DBAzienda.CommitRetaining;
            // Aggiorna le variabili locali che contengono i dati del documento
            // ATTENZIONE: Deve avvenire dopo il salva righi perchè la funzione SalvaRighiDocumento usa queste variabili
            // per avere i vecchi valori identificativi del documento per eliminare i vecchi righi
            // nel caso uno dei dati dalla chiave del documento sia cambiato.
            // Altrimenti succede un casino
            TipoDoc := QryDocumentoTIPODOCUMENTO.Value;
            Registro := QryDocumentoREGISTRO.Value;
            NumeroDoc := QryDocumentoNUMORDPREV.Value;
            DataDoc := QryDocumentoDATADOCUMENTO.Value;
            // Campi privati che contengono alcuni valori precedenti che mi servono per decidere se
            // ricreare le scadenze oppure no dopo la variazione del documento stesso.
            FPrecCodiceCliente := QryDocumentoCODICECLIENTE.AsInteger;
            FPrecCodicePagamento := QryDocumentoPAGAMENTO.AsInteger;
            FPrecTotaleDaPagare := QryDocumentoTOTALEDAPAGARE.AsFloat;
            // Decide se gli allegati devono essere già visibili oppure no.
              Allegati_VerificaAbilitazione;
          except
            // Se invece ci sono stati problemi annulla tutto
            // NB: Se è un intervento non esegue nulla di tutto ciò perchè il controllo della transazione è fatto dalla parte "APPUNTAMENTO" del documento
            if not IsImpegno then
              DM1.DBAzienda.RollbackRetaining;
            // Rilancia l'eccezione
            raise;
          end;
          // Se il documento è visualizzato in modalità MODE_TELETRASPORTO chiude la form
          if Tag = MODE_TELETRASPORTO then
            Close;
        end
        else if MR = mrNo then
        begin
          // Azzera il Flag
          ModalResultConferma := mrNone;
          // Se un campo della griglia delle righe documento era in editing esce dall'editing stesso
          // altrimenti da un errore pericoloso
          Self.SpostaFocus;
          // Ricalcola i totali del documento
          QryDocumento.Cancel;
          // Se il documneto è  in modalità MODE_TELETRASPORTO, elimina il documento
          // e chiude la form
          if Tag = MODE_TELETRASPORTO then
          begin
            DM1.EliminaDocFisc2(TipoDoc, Registro, NumeroDoc, DataDoc);
            Close;
            // Ricalcola i totali del documento (solo se c'è il numero doc) e ricarica i righi del
            // documento per ripristinarli
          end
          else if not QryDocumentoNUMORDPREV.IsNull then
          begin
            CaricaRighiDocumento(TipoDoc, Registro, NumeroDoc, DataDoc);
            QryDocumento.Edit;
            CalcolaTotali(True);
            QryDocumento.Post;
            // Se il numero documento è nullo chiude la FORM
          end
          else
            Close;
        end
        else
        begin
          // Azzera il Flag
          ModalResultConferma := mrNone;
          // Annulla tutto
          RxSpeedModifica.Down := True;
          // Pulizia
          DM1.ChiudiAttendere;
          // Esce
          Exit;
        end;
        // ---------------------------------------------------------------------------------------------

        // Se il documento è visibile riposiziona il focus...
        // NB: Se la scelta dell'utente è di non confermare il documento salto il codice dentro l'IF
        // perchè altrimenti mi dà un errore 'Dataset non in edit or insert mode' e non ho capito
        // assolutamente per quale motivo.
        if Visible and (MR <> mrNo) and (ClientArea.ActivePage = TabDoc) then
        begin
          // Se la variabile FocusDestinatario = True pone il focus sulla RagSoc del SOggetto, altrimenti sul corpodoc
          if (FocusDestinatario) and (QryDocumentoCODICECLIENTE.AsInteger = 0) and (not DistintaBase) then
            DBERagSocCli.SetFocus
          else
            AddArt.SetFocus;
        end;
        // Ripristina i pulsanti e i campi
        RxSpeedButtonElimina.Enabled := False;
        RxSpeedButtonNuovo.Enabled := False;
        RxSpeedButtonTrova.Enabled := False;
        if (not DistintaBase) then
        begin
          RxSpeedButtonStampa.Enabled := True;
          RxSpeedButtonFax.Enabled := DM1.IsFatturaEletronica(QryDocumentoTIPODOCUMENTO.AsString) and not MainForm.IsLevanteLight;
          RxSpeedButtonMail.Enabled := not MainForm.IsLevanteLight;
        end;
        RxSpeedButtonUscita.Enabled := True;
        BitBtnPratica1.Enabled := False;
        BitBtnPratica1_1.Enabled := False;
        BitBtnPratica2.Enabled := False;
        BitBtnPratica3.Enabled := False;
        BitBtnCliente.Enabled := False;
        BitBtnDestinazioneMerci.Enabled := False;
        BitBtnSelezioneStato.Enabled := False;
        BitBtnSubSogg.Enabled := False;
        BitBtnMagazzino.Enabled := False;
        BitBtnMagazzino2.Enabled := False;
        BitBtnCausale.Enabled := False;
        BitBtnPagamento.Enabled := False;
        BitBtnBanca.Enabled := False;
        BitBtnForzaIva.Enabled := False;
        ExtTermImport.Enabled := False;
        SBCalcola1.Enabled := False;
        SBCalcola2.Enabled := False;
        SBCalcola3.Enabled := False;
        SbRifSogg1.Enabled := False;
        SbRifSogg2.Enabled := False;
        SbRifSogg3.Enabled := False;
        SbRifSogg4.Enabled := False;
        SbRifSogg5.Enabled := False;
        SbRifSogg6.Enabled := False;
        SbRifSogg7.Enabled := False;
        SbRifSogg8.Enabled := False;
        SbRifSogg9.Enabled := False;
        SbRifSogg10.Enabled := False;
        DbeAzioneMagazzino.Enabled := False;
        DbeAzioneCantiere.Enabled := False;
        StampaClientArea.Enabled := False;
        AbilitaPanelloVariazioneMargine(False);
        AddArt.Text := '';
        MainForm.SBTipoDocumento.Enabled := False;
        if PreventiviOrdiniForm <> nil then
        begin
          DM1.ColoraTuttiCampi(PreventiviOrdiniForm, COLOR_NORMALE);
          tvCorpo.Styles.Background := DM1.tvBackground;
          tvCorpo.Styles.ContentEven := DM1.tvContentEven;
          tvCorpo.Styles.ContentOdd := DM1.tvContentOdd;
          TableViewDocCorr.Styles.Background := DM1.tvBackground;
          TableViewDocCorr.Styles.ContentEven := DM1.tvContentEven;
          TableViewDocCorr.Styles.ContentOdd := DM1.tvContentOdd;
          TableViewDDTCorr.Styles.Background := DM1.tvBackground;
          TableViewDDTCorr.Styles.ContentEven := DM1.tvContentEven;
          TableViewDDTCorr.Styles.ContentOdd := DM1.tvContentOdd;
        end;
        // Disabilita l'editing del corpo documento
        GridEdit(False);
        {
          // Se arriva fino a qui senza problemi effettua il commit della transazione
          DM1.DBAzienda.Commit;
        }
      except
        on E: Exception do
        begin
          // Se ci sono problemi...
          // NB: Se è un intervento non esegue nulla di tutto ciò perchè il controllo della transazione è fatto dalla parte "APPUNTAMENTO" del documento
          // NB: Aggiunta il 04/04/2013
          // if (not IsImpegno) and DM1.DBAzienda.InTransaction then DM1.DBAzienda.RollbackRetaining;
          {
            // Se invece c'è stato un errore effettua il rollback
            DM1.DBAzienda.Rollback;
          }
          // Messaggio di errore
          MessageBeep(0);
          MessageDlg(E.Message, mtError, [mbOk], 0);
          RxSpeedModifica.Down := True;
          // Riabilita i controlli legati agli archivi dei documenti
          QryDocumento.EnableControls;
          // NB: Aggiunta il 04/04/2013
          // QryDocumento.Edit;
        end;
      end;
    finally
      // Chiude le varia attese
      DM1.ChiudiAttendere;
      DM1.CloseWait;
      // Ripristina la EditSQL se è il caso
      // NB: Anche qui per sicurezza ma lo fa anche dopo il primo Post
      if Assigned(PrecEditSQL) then
      begin
        QryDocumento.EditSQL.Clear;
        QryDocumento.EditSQL.AddStrings(PrecEditSQL);
      end;
      // Riabilita i controlli legati agli archivi dei documenti
      QryDocumento.EnableControls;
    end;
  end;
end;

function TPreventiviOrdiniForm.CreazioneAggiornamentoScadenzeDocumento: Boolean;
var
  LNumeroScadenze: Integer;
  LScadenzePrecedentiDaEliminare, LScadenzePresenti: Boolean;
  LMessage: String;
  function GetNumeroScadDoc: Integer;
  var
    Qry: TIB_Cursor;
  begin
    Qry := TIB_Cursor.Create(Self);
    try
      Qry.DatabaseName := DM1.ArcDBFile;
      Qry.IB_Connection := DM1.DBAzienda;
      Qry.SQL.Add('SELECT count(*) as Risultato FROM Scadenz WHERE TipoDoc = ''' + TipoDoc + ''' AND Registro = ''' + Registro + ''' AND NumDoc = ' +
        IntToStr(NumeroDoc) + ' AND DataDoc = ''' + FormatDateTime('mm/dd/yyyy', DataDoc) + '''');
      Qry.Open;
      Result := Qry.FieldByName('Risultato').Value;
      Qry.Close;
    finally
      Qry.Free;
    end;
  end;
  procedure EliminaScadenzePrecedenti;
  var
    Qry: TIB_Cursor;
  begin
    Qry := TIB_Cursor.Create(Self);
    try
      Qry.DatabaseName := DM1.ArcDBFile;
      Qry.IB_Connection := DM1.DBAzienda;
      Qry.SQL.Add('DELETE FROM SCADENZ WHERE TipoDoc = ''' + TipoDoc + ''' AND Registro = ''' + Registro + ''' AND NumDoc = ' + IntToStr(NumeroDoc) +
        ' AND DataDoc = ''' + FormatDateTime('mm/dd/yyyy', DataDoc) + '''');
      Qry.ExecSQL;
      QryDocumento.Edit;
      try
        QryDocumentoDATASCAD1.Clear;
        QryDocumentoDATASCAD2.Clear;
        QryDocumentoDATASCAD3.Clear;
        QryDocumentoDATASCAD4.Clear;
        QryDocumentoDATASCAD5.Clear;
        QryDocumentoIMPORTOSCAD1.Clear;
        QryDocumentoIMPORTOSCAD2.Clear;
        QryDocumentoIMPORTOSCAD3.Clear;
        QryDocumentoIMPORTOSCAD4.Clear;
        QryDocumentoIMPORTOSCAD5.Clear;
      finally
        QryDocumento.Post;
      end;
    finally
      Qry.Free;
    end;
  end;

begin
  DM1.ShowWait('', 'Controllo scadenze');

  LNumeroScadenze := GetNumeroScadDoc;

  // Determina se devono essere create le scadenze
  LScadenzePresenti := (LNumeroScadenze > 0);
  // Determina se deve eliminare le scadenze precedenti
  //  NB: Aggiunto il "DM.Arrotonda" perchè è capitato un caso con una fattura della termoidraulica riccionese (fatt. 414/01 del 24/09/2020 - TANARI)
  //       dell'importo di 2309,28 nel quale il totale delle scadence (sempre 2309,28) risultava maggiore del dotale documento mentre invece
  //       ovviamente 2309,28 non è maggiore di 2309,28 bensi uguale, così ho risolto.
  LScadenzePrecedentiDaEliminare := (QryDocumentoPAGAMENTO.AsInteger <> FPrecCodicePagamento)
    or (DM1.Arrotonda(QryDocumentoTOTALEDAPAGARE.AsFloat, FormatSettings.CurrencyDecimals) <> DM1.Arrotonda(FPrecTotaleDaPagare, FormatSettings.CurrencyDecimals))
    or (QryDocumentoCODICECLIENTE.AsInteger <> FPrecCodiceCliente)
    or (QryDocumentoTIPODOCUMENTO.AsString <> TipoDoc)
    or (QryDocumentoNUMORDPREV.AsInteger <> NumeroDoc)
    or (QryDocumentoREGISTRO.AsString <> Registro)
    or (QryDocumentoDATADOCUMENTO.AsDateTime <> DataDoc);
  LScadenzePrecedentiDaEliminare := LScadenzePrecedentiDaEliminare and LScadenzePresenti;

  // Elimina le scadenze precedenti e le ricrea nuove
  if LScadenzePrecedentiDaEliminare then
  begin
    // Se NON è in modalità KIOSK chiede conferma all'utente per proseguire (se KIOSK non chiede conferma)
    if (Tag = MODE_KIOSK) or (DM1.Messaggi('Conferma', 'AGGIORNARE le scadenze di pagamento?', '', [mbYes, mbNo], 0, nil) = mrYes) then
    begin
      DM1.ShowWait('', 'Aggiornamento scadenze documento');
      EliminaScadenzePrecedenti;
      CreaScadenzeDocumento;
    end;
  end
  // Crea le scadenze del documento se necessario
  else if not LScadenzePresenti then
  begin
    LMessage := 'Creare le scadenze di pagamento?';
    if fScadenzeCreazioneAutomaticaSoloDocumento then
      LMessage := LMessage + #13#13'NB: SOLO NEL DOCUMENTO, LO SCADENZARIO NON VERRA'' AGGIORNATO!!!';
    // Flag che indica se le scadenze devono essere create oppure no ma in ogni caso senza
    //  chiedere conferma all'utente. In pratica se = mrNone prosegue normalmente chiedendo conferma all'utente,
    //  se invece = mrYes oppure = mrNo crea o non cre le scadenze ma senza chiedere conferma all'utente.
    if ModalResultCreaScad = mrNo then
      Exit;
    // Se NON è in modalità KIOSK chiede conferma all'utente per proseguire (se KIOSK non chiede conferma)
    if (ModalResultCreaScad = mrYes) or (Tag = MODE_KIOSK) or (Tag = MODE_FATTURAZIONE_DIFFERITA) or (DM1.Messaggi('Conferma', LMessage, '', [mbYes, mbNo], 0, nil) = mrYes) then
    begin
      DM1.ShowWait('', 'Creazione scadenze documento');
      CreaScadenzeDocumento;
    end;
  end;
end;

// Procedura che carica sul documento la CausaleCantiere di default
// la uso quando scarico un documento dal teletrasporto.
procedure TPreventiviOrdiniForm.CaricaCausaliDefault;
var
  LO: TMemIniFile;
begin
  // In base ai parametri di Layouts.ini carica o imposta alcuni campi
  LO := TMemIniFile.Create(DM1.Repository_Layouts.FullLocalFileName);
  try
    QryDocumentoCAUSALE.Value := Uppercase(LO.ReadString(QryDocumentoTIPODOCUMENTO.AsString, 'CausaleDefault', ''));
    QryDocumentoCAUSALECANTIERE.Value := Uppercase(LO.ReadString(QryDocumentoTIPODOCUMENTO.AsString, 'CausaleCantiereDefault', ''));
  finally
    LO.Free;
  end;
end;

procedure TPreventiviOrdiniForm.FormShow(Sender: TObject);
var
  LO: TMemIniFile;
begin
  // Decide se gli allegati devono essere già visibili oppure no.
  // NB: Prima era in fondo (l'ultima riga di questo gestore di evento)
  // ma c'era un peoblema di visualizzazione alla prima apertura del documento
  // e spostandolo qui ora va bene.
  // NB: L'ho rimesso in fondo perchè ora non sembra dare problemi di visualizzazione e perchè
  // qui all'inizio invece dava problemi con l'inizializzazione dei filtri
  // Allegati_VerificaAbilitazione;
  // Inizializzazione
  tvCorpo.DataController.RecordCount := 0;
  // Se siamo in modaltà Levante Light disabilita alcuni pulsanti
  if MainForm.IsLevanteLight then
  begin
    RxSpeedButtonVisualizza.Enabled := False;
    RxSpeedButtonMail.Enabled := False;
  end;

  // L'editing della griglia deve essere disabilitato
  // NB: IN questo modo viene anche impostato il DragMode a Automatic
  GridEdit(False);
  // Se si è in modalità KIOSK rende visibile il pulsante di conferma del documento
  SBKioskConfermaDoc.Visible := (Tag = MODE_KIOSK);
  // Se è una distinta base modifica i nome delle tabelle delle query del compoennte UpdateDocumento
  ImpostaNomiTabelle;
  // In base al valore di 'Tag' apre la form in diverse modalità...
  case Tag of
    // Mode = 0: Non fà nulla
    MODE_FATTURAZIONE_DIFFERITA:
      begin
        // RIchiama l'evento OnChancge del controlla che seleziona il tipo del documento
        CambiaTipoDocumento;
      end;
    // Mode = 1: Apre le tabelle necessarie, si posiziona sul record giusto, visualizza la form.
    MODE_OPEN:
      begin
        // Imposta il Flag che indica se si tratta di una distintabase
        if CaricaDocumento(TipoDoc, Registro, NumeroDoc, DataDoc) then
        begin
          // RIchiama l'evento OnChancge del controlla che seleziona il tipo del documento
          CambiaTipoDocumento;
          // Carica i valori dell'aliquota IVA di default del documento
          CaricaAliquotaIVADefaultDocumento;
          // Se il documento viene trovato carica anche il resto
          CaricaRighiDocumento(TipoDoc, Registro, NumeroDoc, DataDoc);
          // Se è una fattura attiva il bottone per l'invio come fattura elettronica
          RxSpeedButtonFax.Enabled := DM1.IsFatturaEletronica(QryDocumentoTIPODOCUMENTO.AsString) and not MainForm.IsLevanteLight;
        end
        else
        begin
          // Se il documento invece non viene trovato, visualizza un messaggio di errore e chiude tutto
          MessageBeep(0);
          MessageDlg('Documento non trovato !', mtError, [mbOk], 0);
          Close;
          Exit;
        end;
      end;
    // Mode = 2: Azzera i righi per il nuovo documento
    MODE_NEW:
      begin
        // RIchiama l'evento OnChancge del controlla che seleziona il tipo del documento
        CambiaTipoDocumento;
        // Pone il nuovo documento in modifica
        // NB: Se siamo in un rapporto di intervento e il rapporto di intervento non è
        // anche lui in modalità NEW evita le righe sottostanti perchè significa che
        // si è aperto un impegno preesistente per cui non esisteva già un documento e quindi
        // ne stiamo creando uno nuovo ma non deve andare già in modifica perchè in realtà
        // l'impegno non lo è.
        if (not Self.IsImpegno) or (Self.IsImpegno and (ImpegnoForm.Tag = MODE_NEW)) then
        begin
          RxSpeedModifica.Down := True;
          RxSpeedModificaClick(Self);
        end;
      end;
    // MOde = 3: Modalità KIOSK (Vendita al banco)
    MODE_KIOSK:
      begin
        // RIchiama l'evento OnChancge del controlla che seleziona il tipo del documento
        CambiaTipoDocumento;
        // Pone il nuovo documento in modifica
        RxSpeedModifica.Down := True;
        RxSpeedModificaClick(Self);
        // Ricalcola i totali del documento (perchè altrimenti dopo aver confermato o annullato un documento precedente rimangono i totali di quest'ultimo)
        // Se abilitato e necessario ricalcola i totali del documento
        CalcolaTotali(True);
        // Se il tipo documento è disabilitato dalle protezioni, chiude la form altrimenti salterebbe le protezioni
        if DM1.ControllaDocumento(TipoDoc) < 2 then
        begin
          MessageBeep(0);
          MessageDlg('Il tipo di documento "' + TipoDoc + '" non è abilitato.', mtInformation, [mbOk], 0);
          Close;
          Exit;
        end;
      end;
    // Mode = 4: Apre le tabelle necessarie, si posiziona sul record giusto, visualizza la form e si mette in MODIFICA
    MODE_TELETRASPORTO:
      begin
        // Imposta il Flag che indica se si tratta di una distintabase
        if CaricaDocumento(TipoDoc, Registro, NumeroDoc, DataDoc) then
        begin
          // RIchiama l'evento OnChancge del controlla che seleziona il tipo del documento
          CambiaTipoDocumento;
          // Carica i valori dell'aliquota IVA di default del documento
          CaricaAliquotaIVADefaultDocumento;
          // Se il documento viene trovato carica anche il resto
          CaricaRighiDocumento(TipoDoc, Registro, NumeroDoc, DataDoc);
          // Mette il documento in modifica
          RxSpeedModifica.Down := True;
          RxSpeedModificaClick(Self);
          // Carica le causali di default del documento
          // NB: Non se riceviamo un preventivo (da un fornitore si intende) altrimenti ci ha dato dei problemi
          // rif. utente LD IDROSANITARIA problema "Documento già presente nello stesso anno" perchè
          // loro assegnavano di default al preventivo una causale che modificava il registro.
          // NB: Solo se riceve un documento di acquisto perchè penso che il caso si applichi a tutti i documenti
          // di vendita (anche se di solito non ne riceviamo dal teletrasporto)
          // NB: E solo se NON siamo in modalità MODE_TELETRASPORTO
          if DM1.IsDocumentoDiIngresso(QryDocumentoTIPODOCUMENTO.AsString) then
            CaricaCausaliDefault;
          // Se il PID della stazione = 'NC' significa che siamo cu un cliente di Siena
          // e quindi con il listino netto e quindi ricalcola i Prezzi Unitari dei righi
          // come prezzi netti.
          if DM1.TableDatiAziendaCA_PID.AsString = 'NC' then
            RendeTuttiPrzUnitDaLordiANetti;
        end
        else
        begin
          // Se il documento invece non viene trovato, visualizza un messaggio di errore e chiude tutto
          MessageBeep(0);
          MessageDlg('Documento non trovato !', mtError, [mbOk], 0);
          Close;
          Exit;
        end;
      end;
  end;
  // Carica la descrizione pagamento
  if not QryDocumentoPAGAMENTO.IsNull then
    DM1.CaricaDescrizionePagamento(QryDocumentoPAGAMENTO.Value, DescrizionePagamento);
  // Carica i dati della banca
  if (not QryDocumentoABI.IsNull) and (not QryDocumentoCAB.IsNull) then
    DM1.CaricaDatiBanca(QryDocumentoABI.Value, QryDocumentoCAB.Value, Banca, ABI, CAB, BIC);
  // Carica la descrizione delle pratiche
  if (not QryDocumentoPRATICA.IsNull) and (not QryDocumentoDATAPRATICA1.IsNull) then
    DM1.CaricaDescrizionePratica(QryDocumentoPRATICA.Value, QryDocumentoDATAPRATICA1.Value, EditDescrizionePratica1);
  if (not QryDocumentoPRATICA2.IsNull) and (not QryDocumentoDATAPRATICA2.IsNull) then
    DM1.CaricaDescrizionePratica(QryDocumentoPRATICA2.Value, QryDocumentoDATAPRATICA2.Value, EditDescrizionePratica2);
  if (not QryDocumentoPRATICA3.IsNull) and (not QryDocumentoDATAPRATICA3.IsNull) then
    DM1.CaricaDescrizionePratica(QryDocumentoPRATICA3.Value, QryDocumentoDATAPRATICA3.Value, EditDescrizionePratica3);
  // RIchiama l'evento OnChancge del controlla che seleziona il tipo del documento
  // NB: E' stato spostato più in su, perchè venissero impostati i microprezzi prima del caricamento dei righi perchè
  // altrimenti nei sottorighi non funzionavano i microprezzi stessi.
  CambiaTipoDocumento;
  // Provato a eliminare perchè viene richiamato anche più sopra (quindi 2 volte) ma se o tolgo poi ho delle discrepanze
  // Rende visibili solo i righi del castelletto IVA che non sono vuoti
  ControllaVisualizzazioneCastellettoIVA;

  // Se è un preventivo oppure una distinta base lo visualizza espanso orizzontalmente per default
  LO := TMemIniFile.Create(DM1.Repository_Layouts.FullLocalFileName);
  try
    if (TipoDoc = 'Preventivo') or DistintaBase then
      BodyScreenState := TBodyScreenState(LO.ReadInteger(TipoDoc, 'V_DefaultBodyScreenState', Ord(bssHorzStretched)))
    else
      BodyScreenState := TBodyScreenState(LO.ReadInteger(TipoDoc, 'V_DefaultBodyScreenState', Ord(bssNormal)));
  finally
    LO.Free;
  end;

  if (TipoDoc = 'Preventivo') or DistintaBase then
    BodyScreenState := TBodyScreenState.bssHorzStretched;
  // Se è un impegno...
  if Self.IsImpegno then
  begin
    // Disabilita alcuni pulsanti che non devono essere attivi nella DistintaBase
    // RxSpeedButtonStampa.Enabled       := False;
    // RxSpeedButtonFax.Enabled          := False;
    // RxSpeedButtonMail.Enabled         := False;
    // RxSpeedButtonVisualizza.Enabled   := False;
    // Disabilita le gestione dell'evento OnShow per fare in modeo che alle successive Show non la riesegua
    PreventiviOrdiniForm.OnShow := PreventiviOrdiniForm.FormShowImpegni;
  end;
  // Se è una distintabase ..
  if DistintaBase then
  begin
    try
      // Disabilita alcuni pulsanti che non devono essere attivi nella DistintaBase
      RxSpeedButtonStampa.Enabled := False;
      RxSpeedButtonFax.Enabled := False;
      RxSpeedButtonMail.Enabled := False;
      RxSpeedButtonVisualizza.Enabled := False;
      // Imposta la proprietà DataSource dei campi COdiceArticolo e DescrizioneArticolo per collegarli
      // al DataSource dell'anagrafica articolo
      // Carica il codice e la descrizione dell'articolo nella DIBA per avere un riferimento
      // durante l'inserimento della DIBA
      LabelCodiceArticolo.Caption := AnagArtForm.QryArtCODICEARTICOLO.AsString;
      LabelDescrizioneArticolo.Caption := AnagArtForm.QryArtDESCRIZIONE.AsString;
      // Disabilita le gestione dell'evento OnShow per fare in modeo che alle successive Show non la riesegua
      PreventiviOrdiniForm.OnShow := nil;
      // Setta il Prezzo orario della manodopera e richiama la funzione che aggiorna i prezzi di vendita e ricalcola i totali
      // della Distinta Base perchè i prezzi di alcuni articoli potrebbero essere cambiati.
      // PrezzoUnitarioOpera.Value := DM1.Manodopera[0].PrezzoUnitario1;
      // Per aggiornare i totali purtroppo devo mettere subito alla visualizzazione il Dataset in modalità di Editing
      // e questo potrebbe dare problemi nel caso in cui la DistintaBase sia già aperta da un altro utente
      // NB: IN SEGUITO A PROBLEMI AVUTO CON LA DIBA (documento già aperto da un altro utente) METTO IL PESSIMISTIC LOCKING = FALSE (SOLO DIBA)
      QryDocumento.PessimisticLocking := False;
      QryDocumento.Edit;
      try
        DM1.ShowWait('Articolo composto', 'Aggiornamento prezzi sottoarticoli.');
        AggiornaPrezziDocumento(tvCorpo.DataController, False);
      finally
        CalcolaTotali(True);
        DM1.CloseWait;
      end;
      QryDocumento.Post;
    except
      // Se in questo blocco capita un errore, probabilmente è perchè un altro utente ha aperto
      // lo stesso articolo in modalità di modifica e poichè nelle righe quì sopra deve ricalcolare i totali, non è possibile
      // nemmeno aprire un articolo composto se un altro utente lo sta modificando.
      // In questo caso chiude la form dell'agrafica articolo che a sua forza alla chiusura anche la form del documento
      // (Distinta base) altrimenti si incasinava il sistema.
      DM1.Messaggi('ATTENZIONE !'#13#13#13'Apertura Articolo',
        'Si è verificato un errore durante il caricamento dell''articolo.'#13#13#13'Probabilmente qualche altro utente sta modificando lo stesso articolo.',
        'NB: Non è possibile aprire un articolo composto se un altro utente lo sta modificando.', [mbOk], 0, nil);
      AnagArtForm.Close;
    end;
  end;
  // IMposta il flag di SolaLettura a True se nel TipoDOcumentoEsteso è contenuto il marcatore apposito.
  SolaLettura := DM1.IsReadOnlyDoc(QryDocumentoTIPODOCUMENTOESTESO.AsString);
  // Se il documento è a sola lettura disabilita il pulsante del pannellino dei Titali/Margini
  SBApriChiudiTotaliMargini1.Enabled := not SolaLettura;
  // Carica i sottocantieri del cantiere attuale  nelle ComboBox delle colonne
  // relative ai sottocantieri
  CaricaItemsSottocantieri;
  CaricaItemsSottocantieriDatiRigo;
  // CArica i tipi di richi nelle ComboBox delle colonne relative
  CaricaItemsTipiRighi;
  CaricaItemsTipiRighiDatiRigo;
  // Carica Descrizioni manodopere
  CaricaDescrizioniManodopera;
  // Carica lo sconto dell'anagrafica soggetto
  if not DistintaBase then
    CaricaScontoSoggetto;
  // Apre le query relative  alla selezione dei tipi ore
  QTipoOre1.Open;
  QTipoOre2.Open;
  QTipoOre3.Open;
  // Forza l'esecuzione dei gestori di evento OnChange dei campi relativi al SEGNOOPERAZIONE
  // in modo che i Combobox delle azioni si allinei ai loro valori.
  QryDocumentoSEGNOOPERAZIONEChange(QryDocumentoSEGNOOPERAZIONE);
  QryDocumentoSEGNOOPERAZIONECANTIEREChange(QryDocumentoSEGNOOPERAZIONECANTIERE);
  // Se si tratta di un nuovo documento visualizza la form di richiesta esplicita
  // dei dati relativi al cantiere e all'azione da eseguire
  // NB: PER ADESSO NON LA UTILIZZO PERCHE' NON MI PIACE
  // if Tag = MODE_NEW then  VisualizzaRichiestaDatiInizialiDocumento;
  // Imposta la visibilità o meno di alcuni campi della ritenuta d'acconto
  SetRitAccVisiblesFields;
  // Decide se gli allegati devono essere già visibili oppure no.
  // NB: Prima era in fondo (l'ultima riga di questo gestore di evento)
  // ma c'era un peoblema di visualizzazione alla prima apertura del documento
  // e spostandolo qui ora va bene.
  Allegati_VerificaAbilitazione;

  ControllaVisualizzazioneSplitPayment(False);

  // Campi privati che contengono alcuni valori precedenti che mi servono per decidere se
  // ricreare le scadenze oppure no dopo la variazione del documento stesso.
  FPrecCodiceCliente := QryDocumentoCODICECLIENTE.AsInteger;
  FPrecCodicePagamento := QryDocumentoPAGAMENTO.AsInteger;
  FPrecTotaleDaPagare := QryDocumentoTOTALEDAPAGARE.AsFloat;
end;

procedure TPreventiviOrdiniForm.CaricaDescrizioniManodopera;
begin
  LabelDescOpera.Caption := DM1.Manodopera[0].Descrizione;
  LabelDescOpera1.Caption := DM1.Manodopera[1].Descrizione;
  LabelDescOpera2.Caption := DM1.Manodopera[2].Descrizione;
  LabelDescOpera3.Caption := DM1.Manodopera[3].Descrizione;
  LabelDescOpera4.Caption := DM1.Manodopera[4].Descrizione;
end;

// Procedura che cicla rigo per rigo e imposta il prezzo unitario di ogni rigo
// trasformandolo da lordo a netto, in pratica, nel caso il prezzo unitario del rigo
// sia lordo, nel senso che poi c'è almeno uno sconto, prende l'importo del rigo, che
// è netto, e lo divide per la Qtà, ovviamente potranno esserci dei problemi di arrotondamento.
procedure TPreventiviOrdiniForm.RendeTuttiPrzUnitDaLordiANetti;
var
  DC: TcxCustomDataController;
  i: Integer;
begin
  // Altre inizializzazioni
  DC := tvCorpo.DataController;
  tvCorpo.BeginUpdate;
  try
    for i := 0 to DC.RecordCount - 1 do
    begin
      // Solo se ci sono degli sconti sul rigo, altrimenti significa che il
      // PrzUnit è già netto
      if ((not VarIsNull(DC.Values[i, tvCorpoSCONTORIGO.Index])) and (DC.Values[i, tvCorpoSCONTORIGO.Index] <> 0)) or
        ((not VarIsNull(DC.Values[i, tvCorpoSCONTORIGO2.Index])) and (DC.Values[i, tvCorpoSCONTORIGO2.Index] <> 0)) or
        ((not VarIsNull(DC.Values[i, tvCorpoSCONTORIGO3.Index])) and (DC.Values[i, tvCorpoSCONTORIGO3.Index] <> 0)) then
      begin
        // Evita gli errori dovuti a valori nulli o zero
        if ((not VarIsNull(DC.Values[i, tvCorpoQTA.Index])) and (DC.Values[i, tvCorpoQTA.Index] <> 0)) and
          (not VarIsNull(DC.Values[i, tvCorpoIMPORTORIGO.Index])) then
        begin
          // Assegna il risultato al PrzUnitario del rigo attuale
          DC.Values[i, tvCorpoPREZZOUNITARIO.Index] := DM1.Arrotonda((DC.Values[i, tvCorpoIMPORTORIGO.Index] / DC.Values[i, tvCorpoQTA.Index]),
            DM1.DecMicroPrz);
          // Azzera gli sconti
          DC.Values[i, tvCorpoSCONTORIGO.Index] := 0;
          DC.Values[i, tvCorpoSCONTORIGO2.Index] := 0;
          DC.Values[i, tvCorpoSCONTORIGO3.Index] := 0;
        end;
      end;
    end;
  finally
    tvCorpo.EndUpdate;
  end;
end;

procedure TPreventiviOrdiniForm.CreaSottorigoTemporaneo(MDC: TcxCustomDataController; Y: Integer);
var
  yy: Integer;
  DDC: TcxCustomDataController;
begin
  // Prima controlla che non abbia già dei sottorighi
  // Per sapere perchè ho commentato queste righe leggi più sotto.
  // if DM1.CheckIfExpandable(MDC, Y, True) then
  // Exit;
  // Se non c'è nessun rigo selezionato esce subito
  if Y = -1 then
    Exit;
  // Se è un rigo di manodopera crea un sottorigo temporaneo di manodopera operaio...
  if DM1.CodiceIsManodopera(DM1.NoNullStringValue(MDC, Y, tvCorpoCODICEARTICOLO.Index)) then
  begin
    // Se non ci sono sottorighi provvede a crearne uno
    // NB: Non ho usato la DM1.CheckIfExpandable perchè non funzionava
    // bene nel caso il rigo principale fosse già stato composto
    // (cioè avesse già avuto dei sottorighi poi eliminati) dava
    // dei problemi.
    DDC := MDC.GetDetailDataController(Y, RELATION_IDX_SOTTORIGHI_ORE);
    if DDC.RecordCount > 0 then
      Exit;
    yy := DDC.AppendRecord;
    DDC.Values[yy, tvOreCODDIPENDENTE.Index] := -1;
    DDC.Values[yy, tvOreDESCRIZDIPENDENTE.Index] := '- - -';
    DDC.Values[yy, tvOreNOTE.Index] := '- - -';
  end
  // Se invece è un rigo normale di componenti crea un sottorigo temporaneo di articolo composto...
  else
  begin
    // Se non ci sono sottorighi provvede a crearne uno
    // NB: Non ho usato la DM1.CheckIfExpandable perchè non funzionava
    // bene nel caso il rigo principale fosse già stato composto
    // (cioè avesse già avuto dei sottorighi poi eliminati) dava
    // dei problemi.
    // I righi composti hanno il flag PrzUnitAutocalc a True per default
    MDC.Values[Y, tvCorpoPREZZOUNITARIOAUTOCALC.Index] := 'T';
    DDC := MDC.GetDetailDataController(Y, RELATION_IDX_SOTTORIGHI_NORMALI);
    if DDC.RecordCount > 0 then
      Exit;
    yy := DDC.AppendRecord;
    DDC.Values[yy, tvCorpoROWTYPE.Index] := TIPORIGODOC_SottorigoTemporaneo;
    DDC.Values[yy, tvCorpoCODICEARTICOLO.Index] := '- - -';
    DDC.Values[yy, tvCorpoCODICEARTICOLOSTM.Index] := '- - -';
    DDC.Values[yy, tvCorpoDESCRIZIONE.Index] := '- - -';
    DDC.Values[yy, tvCorpoORDER.Index] := 1;
  end;
end;

procedure TPreventiviOrdiniForm.FormShowImpegni(Sender: TObject);
begin
  if DatiRigoForm <> nil then
    DatiRigoForm.Show;
end;

procedure TPreventiviOrdiniForm.FormCreate(Sender: TObject);
begin
  FSospendiCalcoloTotali := False;
  FSplitPayment := True; // Evita che se carico una fattura son SPlitPayment questa appaia in un primo momento con TotaleSplitPayment = 0 (fino a quando non si rcalcola per qualche motivo)
  // Posizionamento del FormMainPanel
  FormMainPanel.Left := CLIENT_LEFT_BORDER;
  FormMainPanel.Top := CLIENT_TOP_BORDER;
  FormMainPanel.Width := Self.Width - CLIENT_LEFT_BORDER - CLIENT_RIGHT_BORDER;
  FormMainPanel.Height := Self.Height - CLIENT_TOP_BORDER - CLIENT_BOTTOM_BORDER;
  // Lo lega alle dimensioni della form
  FormMainPanel.Anchors := [akLeft, akTop, akRight, akBottom];
  // IMposta alcuni pannelli ParentColor = True per renderli non visibili
  // NB: Però mi servono visibili a design time altrimenti mi dimentico di loro
  PanelUpper.ParentColor := True;
  PanelLower.ParentColor := True;
  StampaClientArea.ParentColor := True;
  DocCorrClientArea.ParentColor := True;
  NotificheFEClientArea.ParentColor := True;

  // Inizializzazione
  PanelAllegati.Height := 0;
  // Altrimenti ci sono alcune imprecisioni nel layout iniziale del documento
  fFirstCaricaLayoutDocumento := True;
  CaricaLayoutDocumento_NotLoadColumnSettingsNextTime := False;
  BodyScreenState := TBodyScreenState.bssNormal;
  fModificandoDaDatiRigoForm := False;
  ModalResultConferma := mrNone;
  ModalResultMovMag := mrNone;
  ModalResultCreaScad := mrNone;
  GestVerDoc_Mode := mfNone;
  SolaLettura := False;
  NumerazioneAutomatica := True;
  fStampaCastellettoIVA := True;
  fStmPref_FileName := DM1.GUIDAsString;
  EvidenziaRighiSenzaQtaPrzUnit := True;

  // Posizione iniziale
  ClientArea.ActivePage := TabDoc;
  DocClientArea.VertScrollBar.Position := 0;

  // IMposta i settaggi di visualizzazione della form
  MainForm.CaricaTemaClientForm(Self, ClientTopPanel, RxSpeedButtonUscita, RxSpeedButtonHelp, RxSpeedModifica, RxSpeedButtonNuovo, RxSpeedButtonElimina,
    RxSpeedButtonTrova, RxSpeedButtonResetQuery, RxSpeedButtonStampa, RxSpeedButtonFax, RxSpeedButtonMail, RxSpeedButtonVisualizza);

  // Colore normale (non modifica) nei campi
  DM1.ColoraTuttiCampi(PreventiviOrdiniForm, COLOR_NORMALE);

  // IMposta la caption della form in base al nome del programma impostato nella variabile 'NomeApplicazione'
  Caption := MainForm.NomeApplicazione + ' - (Documento)';

  // Carica l'icona del tipo documento visualizzato
  // NB: Lasciare quì e non rimetterlo nell'evento OnShow perchè altrimenti
  // quando si usa la modalità KIOSK fà casino con il ripristino dell'icona in alto a sx
  // all'uscita di questa modalità.
  MainForm.SalvaIconaDocTipo;
  MainForm.CaricaIconaDocTipo(Self.Name);
  // Blocca l'aggiornamento dell'IconaDocTipo
  MainForm.BloccaIconaDocTipo(True, Name);

  // Crea l'istanza dell'oggetto che si occuperò della gestione dei totali a corpo
  FTotaleCorpo := TTotaleCorpoFactory.NewTotaleCorpo(Self);
end;

procedure TPreventiviOrdiniForm.NuovoRigoOre(CodDip: Integer; Mode: TAddArtMode);
var
  Y: Integer;
  Qry: TIB_Cursor;
  DC: TcxCustomDataController;
  Tmp: String;
begin
  // Prima di tutto controlla che la view che ha il focus sia
  // relativa alle ore, altrimenti esce.
  if GridCorpo.FocusedView.PatternGridView.Name <> 'tvOre' then
    raise Exception.Create('Nuovo rigo ore - Attualmente non è selezionata alcuna vista ore.');
  // DC Punta al DataController che attualmente ha il focus
  DC := GridCorpo.FocusedView.DataController;
  // Y contiene la coordinata Y della cella selezionata
  Y := DC.FocusedRecordIndex;
  // Crea Qry
  Qry := TIB_Cursor.Create(Self);
  try
    Qry.DatabaseName := DM1.ArcDBFile;
    Qry.IB_Connection := DM1.DBAzienda;
    // Cerca il dipendente desiderato
    Qry.SQL.Add('SELECT *');
    Qry.SQL.Add('FROM DIPENDENTI D');
    Qry.SQL.Add('WHERE D.CODICE = ' + IntToStr(CodDip));
    // Apre la query
    Qry.Open;
    // Se trova il dipendente
    if not Qry.Eof then
    begin
      // Se non c'è alcun record selezionato forza l'Append del nuovo rigo
      // altrimenti dà un errore.
      if DC.FocusedRecordIndex = -1 then
        Mode := AM_Append;
      // In base alla modalità modifica il rigo corrente oppure fà un append o un isert.
      case Mode of
        AM_Append:
//          Y := DC.InsertRecord(DC.RecordCount - 1);
          Y := DC.AppendRecord;
        // NB: Faccio in modo che il rigo nullo (obbligatorio) rimanga sempre alla fine altrimenti mi dava un errore se eliminavo l'ultimo rigo e visto che questo rigo non è eliminabile...
        AM_Insert:
          Y := DC.InsertRecord(Y);
      end;
      // Costruisce il Nome + COgnome
      // Construisce il Nome e cognome del dipendente
      Tmp := '';
      if not Qry.FieldByName('NOME').IsNull then
        Tmp := Trim(Qry.FieldByName('NOME').AsString);
      if not Qry.FieldByName('COGNOME').IsNull then
      begin
        if Length(Trim(Tmp)) > 0 then
          Tmp := Tmp + ' ';
        Tmp := Tmp + Trim(Qry.FieldByName('COGNOME').AsString);
      end;
      // CArica i valori
      DC.Values[Y, tvOreCODDIPENDENTE.Index] := CodDip;
      DC.Values[Y, tvOreDESCRIZDIPENDENTE.Index] := Tmp;
      DC.Values[Y, tvOreTIPOORE1.Index] := Qry.FieldByName('TIPOORE1').AsString;
      DC.Values[Y, tvOreTIPOORE2.Index] := Qry.FieldByName('TIPOORE2').AsString;
      DC.Values[Y, tvOreTIPOORE3.Index] := Qry.FieldByName('TIPOORE3').AsString;
      DC.Values[Y, tvOreOPERAINDEX.Index] := Qry.FieldByName('OPERAINDEX').AsInteger;
      if not Qry.FieldByName('COSTOORARIO').IsNull then
        DC.Values[Y, tvOreCOSTOORARIO.Index] := Qry.FieldByName('COSTOORARIO').AsCurrency;
      // Imposta il prezzo di vendita prendendolo dal rigo principale
      DC.Values[Y, tvOrePRZUNITVEND.Index] := DM1.NoNullFloatValue(tvCorpo.DataController, DC.GetMasterRecordIndex, tvCorpoPREZZOUNITARIO.Index);
      // Se è abilitato, richiede la Qtà di ore da inserire
      // if DM1.RichiediQta then DM1.ChiediOreManodopera(CodDip,
      if fRichiediQtaDoc then
        DM1.ChiediOreManodopera(CodDip, Tmp, DC, Y, tvOreQTA.Index, tvOreNOTE.Index);
      // Se la Qta e anche il costo orario non sono nulli provvede a calcolare
      // l'importo.
      CalcolaImportoOrario(DC, Y);
      // Se abilitato e necessario ricalcola i totali del documento
      CalcolaTotali(False);
      // Altrimenti significa che non ha trovato alcun articolo e quindi ritorna un errore
    end
    else
    begin
      MessageBeep(0);
      MessageDlg('Dipendente non trovato !', mtError, [mbOk], 0)
    end;
    Qry.Close;
  finally
    Qry.Free;
  end;
end;

function TPreventiviOrdiniForm.CalcolaImportoOrario(DC: TcxCustomDataController; Y: Integer): Double;
begin
  // Inizializza il valore da ritornare (il numero di ore ordinarie) che uso nella
  // gestione dell'evento 'tvOreEditValueChanged' per modificare il numero di
  // ore ordinarie nel rigo attraverso 'Sender.Controller.EditingController.Edit.EditValue'
  // altrimenti non mi modifica il campo QTA.
  Result := 0;
  if (not VarIsNull(DC.Values[Y, tvOreQTA.Index])) then
  begin
    Result := DC.Values[Y, tvOreQTA.Index];
  end;

  // CALCOLO COSTO ORE ORDINARIE
  if (not VarIsNull(DC.Values[Y, tvOreQTA.Index])) and (not VarIsNull(DC.Values[Y, tvOreCOSTOORARIO.Index])) then
  begin
    DC.Values[Y, tvOreIMPORTOCOSTOORARIO.Index] := DM1.Arrotonda(DC.Values[Y, tvOreCOSTOORARIO.Index] * DC.Values[Y, tvOreQTA.Index], DM1.DecMicroPrz);
  end
  else
    DC.Values[Y, tvOreIMPORTOCOSTOORARIO.Index] := 0;

  // CALCOLO VENDITA ORE ORDINARIE
  if (not VarIsNull(DC.Values[Y, tvOreQTA.Index])) and (not VarIsNull(DC.Values[Y, tvOrePRZUNITVEND.Index])) then
  begin
    DC.Values[Y, tvOreIMPORTOVEND.Index] := DM1.Arrotonda(DC.Values[Y, tvOrePRZUNITVEND.Index] * DC.Values[Y, tvOreQTA.Index], DM1.DecMicroPrz);
  end
  else
    DC.Values[Y, tvOreIMPORTOVEND.Index] := 0;
end;

procedure TPreventiviOrdiniForm.RxSpeedButtonNuovoClick(Sender: TObject);
begin
  DM1.Attendere;
  try
    // Se siamo nella view delle ore...
    if GridCorpo.FocusedView.PatternGridView.Name = 'tvOre' then
    begin
      Application.CreateForm(TDipendentiForm, DipendentiForm);
      // DipendentiForm.Parent := MainForm;
      MainForm.SetParentComponent(DipendentiForm);
      DipendentiForm.DblClickMode := DblClickModeSelection;
      DipendentiForm.CallerCode := 7;
      DipendentiForm.SoloManodoperaTipo := DM1.CodiceToIndexManodopera(tvCorpo.Controller.FocusedRecord.Values[tvCorpoCODICEARTICOLO.Index]);
      DipendentiForm.SoloAttivi := True;
      DipendentiForm.Show;
      // Altrimenti se siamo nella view degli articoli...
    end
    else
    begin
      // Visualizza la form che permette di selezionare l'articolo da inserire
      // nel documento.
      Application.CreateForm(TArticoliForm, ArticoliForm);
      // ArticoliForm.Parent := MainForm;
      MainForm.SetParentComponent(ArticoliForm);
      ArticoliForm.Tag := 999; // Abilita la seleziona dell'articolo
      if QryDocumentoPRATICA.AsInteger <> 0 then
      begin
        ArticoliForm.PratCodice := QryDocumentoPRATICA.AsInteger;
        ArticoliForm.PratDataApertura := QryDocumentoDATAPRATICA1.AsDateTime;
      end;
      ArticoliForm.AddMode := AM_Append;
      ArticoliForm.Show;
    end;
  finally
    DM1.ChiudiAttendere;
  end;
end;

procedure TPreventiviOrdiniForm.FormKeyUp(Sender: TObject; var Key: Word; Shift: TShiftState);
begin
  // Solo se KeyPreview = True
  if KeyPreview then
  begin
    case Key of

      // ESC
      27:
        begin
          if RxSpeedButtonUscita.Enabled then
          begin
            RxSpeedButtonUscitaClick(Self);
          end;
        end;

      // F2 = Modifica
      113:
        begin
          if RxSpeedModifica.Enabled then
          begin
            RxSpeedModifica.Down := not RxSpeedModifica.Down;
            RxSpeedModificaClick(Self);
          end;
        end;

      // F3 = Nuovo
      114:
        begin
          if RxSpeedButtonNuovo.Enabled then
          begin
            if ssCtrl in Shift then
            begin
              if ExtTermImport.Enabled then
                ExtTermImportClick(ExtTermImport);
            end
            else
            begin
              RxSpeedButtonNuovoClick(Self);
            end;
          end;
        end;

      // F4 = Elimina
      115:
        begin
          if RxSpeedButtonElimina.Enabled then
          begin
            RxSpeedButtonEliminaClick(Self);
          end;
        end;

      // F5 = Trova
      116:
        begin
          if RxSpeedButtonTrova.Enabled then
          begin
            RxSpeedButtonTrovaClick(Self);
          end;
        end;

      // F7 = Stampa
      118:
        begin
          if RxSpeedButtonStampa.Enabled then
          begin
            RxSpeedButtonStampa.Down := not RxSpeedButtonStampa.Down;
            RxSpeedButtonStampaClick(Self);
          end;
        end;

      // F8 = Fax
      119:
        begin
          if RxSpeedButtonFax.Enabled then
          begin
            RxSpeedButtonFax.Down := not RxSpeedButtonFax.Down;
            RxSpeedButtonFax.Action.Execute;
          end;
        end;

      // F9 = E-mail
      120:
        begin
          if RxSpeedButtonMail.Enabled then
          begin
            RxSpeedButtonMail.Down := not RxSpeedButtonMail.Down;
            RxSpeedButtonMailClick(Self);
          end;
        end;

      // F10 = Visualizza
      121:
        begin
          if RxSpeedButtonVisualizza.Enabled then
          begin
            RxSpeedButtonVisualizzaClick(Self);
          end;
        end;

      // F12 = Conferma documento KIOSK
      123:
        begin
          if RxSpeedButtonVisualizza.Enabled then
          begin
            SBKioskConfermaDocClick(Self);
            Key := 0;
          end;
        end;

    end;
  end;
end;

procedure TPreventiviOrdiniForm.RxSpeedButtonVisualizzaClick(Sender: TObject);
var
  CodArt: String;
  DC: TcxCustomDataController;
begin
  DM1.Attendere;
  try
    DC := GridCorpo.FocusedView.DataController;
    CodArt := DM1.NoNullStringValue(DC, DC.FocusedRecordIndex, tvCorpoCODICEARTICOLO.Index);
    if DM1.ModCtrl(MOD_ARTICOLI) > 0 then
    begin
      if Trim(CodArt) <> '' then
      begin
        // Se è un articolo composto e siamo dentro un documento aperto,
        // evita di aprire l'articolo altrimenti darebbe problemi dovuti al
        // fatto che la PreventiviOrdiniForm è già esistente (il documento) e viene usata
        // anche nella Distinta base.
        // if (DM1.CheckIfExpandable(DC, DC.FocusedRecordIndex, True)) and (Assigned(PreventiviOrdiniForm)) then begin
        if (DM1.CheckIfExpandable(DC, DC.FocusedRecordIndex, True)) then
        begin
          DM1.Messaggi('Levante', 'Non è possibile visualizzare la scheda di un articolo composto o di manodopera da dentro un documento.', '', [mbOk], 0, nil);
          Exit;
        end;
        // Continua con l'apertura dell'anagrafica articolo
        Application.CreateForm(TAnagArtForm, AnagArtForm);
        // La riga sottostante è stata sostituita con la successiva per risolvere l'errore
        // che dava il programma quando girava su Win95/98/ME (Questo programma ha eseguito una operazione non valida...)
        // Il problema lo dava solo quando assegnavo la proprietà Parent della form AnagArtForm.
        // con le altre form andava bene.
        // AnagArtForm.Parent := MainForm;
        MainForm.FormSetParentPlatformDependent(AnagArtForm, MainForm);
        AnagArtForm.CodiceArticolo := Trim(CodArt);
        AnagArtForm.Tag := 1;
        AnagArtForm.Show;
      end;
    end;
  finally
    DM1.ChiudiAttendere;
  end;
end;

procedure TPreventiviOrdiniForm.RxSpeedButtonEliminaClick(Sender: TObject);
var
  TV: TcxGridTableView;
begin
  TV := GridCorpo.FocusedView as TcxGridTableView;
  // Richiesta conferma
  MessageBeep(0);
  if MessageDlg('Eliminare tutti i record selezionati?', mtInformation, [mbNo, mbOk], 0) = mrOk then
  begin
    // Cancellazione
    TV.DataController.DeleteSelection;
    // Se abilitato e necessario ricalcola i totali del documento
    // NB: Forza il ricalcolo totale del documento altrimenti potevano
    // esserci incongruenze se si eliminavano sottorighi multipli
    CalcolaTotali(True);
  end;
end;

procedure TPreventiviOrdiniForm.RxDBGrid4GetCellParams(Sender: TObject; Field: TField; AFont: TFont; var Background: TColor; Highlight: Boolean);
begin
  // Se è il record selezionato lascia perdere, anche se è la prima colonna
  if (not Highlight) and (Field.FieldName <> 'Codice') then
  begin
    // Visualizza la scadenza in verde o rosso
    // in base all'avvenuto pagamento o meno.
    // if DM1.QueryScadenze.FieldByName('DebitoResiduo').Value > 0 then AFont.Color := clRed
    // else AFont.Color := clGreen;
  end;
end;

procedure TPreventiviOrdiniForm.RxSpeedButtonNuovoMouseUp(Sender: TObject; Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
begin
  // *************************************************************************
  // NB: FACENDO CLICK COL DX SI INSERISCE UN NUOVO ARTICOLO NEL DOCUMENTO
  // NEL PUNTO DOVE SI TROVA IL CURSORE FACENDO SCORRERE GLI ARTICOLI
  // SUCCESSIVI DI 1 POSTO.
  // *************************************************************************
  if Button = mbRight then
  begin
    // Visualizza la form che permette di selezionare l'articolo da inserire
    // nel documento.
    Application.CreateForm(TArticoliForm, ArticoliForm);
    ArticoliForm.Parent := MainForm;
    ArticoliForm.Tag := 999;
    ArticoliForm.AddMode := AM_Insert;
    ArticoliForm.Show;
  end;
end;

procedure TPreventiviOrdiniForm.FormClose(Sender: TObject; var Action: TCloseAction);
begin
  // Chiude la form a sx con i dati del rigo selezionato
  CloseDatiRigoForm;
  // Se la form di richiesta di dati iniziale è aperta la chiude
  if BeforeNewDocForm <> nil then
    BeforeNewDocForm.Close;
  // Se è in MOdifica chiede se Confermare o annullare l'operazione prima di uscire
  // però solo se non si è in modalità KIOSK
  if (Tag <> MODE_KIOSK) and RxSpeedModifica.Down then
  begin
    RxSpeedModifica.Down := False;
    RxSpeedModificaClick(Self);
  end
  else
  begin
    // Se aperta chiude la query del documento
    if QryDocumento.Active then
      QryDocumento.Close;
    // Rende invisibile la LabelTipoDocumento e il relativo pulsante
    // e ripristina la IconaDocTipo precedente
    // Prima ovviamente sblocca l'IconaDocTipo
    MainForm.BloccaIconaDocTipo(False, Name);
    DisableLabelTipoDocumento;
    MainForm.RipristinaIconaDocTipo;
    // Se la form è stata richiamata in modalità Vendita al banco, Rimette SBUtilita non premuto,
    // e non fà il ripristinaFocus, altrimenti fà solo il ripristina Focus, se è in modalità
    // Fatturazione Differita non fà nulla
    case Tag of
      // Non fà nulla in modo che non faccia il RipristinaFOcus che darebbe un errore
      MODE_FATTURAZIONE_DIFFERITA:
        ;
      MODE_TELETRASPORTO:
        ;
      // Il pulsante Impostazioni deve tornare NON PREMUTO (Nel caso fosse stata richiamata con la vendita al banco)
      MODE_KIOSK:
        MainForm.SBUtilita.Down := False;
    end;
    // Distrugge la form stessa
    Action := caFree;
    if DistintaBase then
    begin
      // Ripristina il puntatore al documento eventualmente aperto prima
      // della chiamata della distintabase.
      PreventiviOrdiniForm := AnagArtForm.PrecPreventiviOrdiniForm;
    end
    else
    begin
      // Il puntatore alla form := nil
      PreventiviOrdiniForm := nil;
    end;
  end;
end;

procedure TPreventiviOrdiniForm.DBEditStatoDocumentoChange(Sender: TObject);
begin
  DBEditStatoDocumento.Font.Color := DM1.StrToColor(QryDocumentoSTATOFOREGROUND.Value, clBlack);
  DBEditStatoDocumento.Color := DM1.StrToColor(QryDocumentoSTATOBACKGROUND.Value, clSilver);
end;

procedure TPreventiviOrdiniForm.DBEditStatoDocumentoKeyUp(Sender: TObject; var Key: Word; Shift: TShiftState);
begin
  if RxSpeedModifica.Down and ((Ord(Key) = VK_BACK) or (Ord(Key) = VK_DELETE)) then
    AzzeraStato1Click(AzzeraStato1);
end;

procedure TPreventiviOrdiniForm.DBEFOrzaIVAKeyUp(Sender: TObject; var Key: Word; Shift: TShiftState);
begin
  if RxSpeedModifica.Down and ((Ord(Key) = VK_BACK) or (Ord(Key) = VK_DELETE)) then
    AzzeraAliquotaIVA1Click(AzzeraAliquotaIVA1);
end;

procedure TPreventiviOrdiniForm.dbePA_CausalePagRitenuta_SiglaKeyPress(Sender: TObject; var Key: Char);
begin
  // Solo maiuscole
  Key := Upcase(Key);
end;

procedure TPreventiviOrdiniForm.MICopiaRighiSelezionatiClick(Sender: TObject);
begin
  DM1.Attendere;
  try
    EsportaRigoDocFisc(GridCorpo.FocusedView as TcxGridTableView);
  finally
    DM1.ChiudiAttendere;
    MainForm.AggiornaDocumentiEsportati;
  end;
end;

// Procedura che provvede a spostare i righi di manodopera e/o di Altre Spese in fondo al documento
procedure TPreventiviOrdiniForm.SpostaFocus;
begin
  // Sposta il focus nella form laterale con i dati del rigo in modo che il dato
  // che magari è stato appena inserito ma non confermato con Invio o spostandosi su
  // un altro controllo...
  // NB: Sposto il focus in vari controlli perchè altrimenti se uno non era visibile dava un errore.
  if (Self.Visible) and (DatiRigoForm <> nil) and (DatiRigoForm.Visible) and (DatiRigoForm.dxLayoutControl1.Visible) then
  begin
    if DatiRigoForm.eCodiceArticolo.Visible and DatiRigoForm.eCodiceArticolo.Enabled then
      DatiRigoForm.eCodiceArticolo.SetFocus
    else if DatiRigoForm.eQta.Visible and DatiRigoForm.eQta.Enabled then
      DatiRigoForm.eQta.SetFocus
    else if DatiRigoForm.ePrezzoUnitario.Visible and DatiRigoForm.ePrezzoUnitario.Enabled then
      DatiRigoForm.ePrezzoUnitario.SetFocus;
    if DatiRigoForm.eDescrizione.Visible and DatiRigoForm.eDescrizione.Enabled then
      DatiRigoForm.eDescrizione.SetFocus;
  end;
end;

procedure TPreventiviOrdiniForm.SpostaManodoperaSpeseInFondo(const ASpostaOpera, ASpostaSpese: Boolean);
var
  RI: Integer;
  DC: TcxCustomDataController;
  ManIndex: Integer;
begin
  // Inizializzazione
  RI := 0;
  DC := tvCorpo.DataController;
  ManIndex := 1000000;
  // Cicla per tutti i righi
  while (RI < DC.RecordCount) and (DM1.NoNullFloatValue(DC, RI, tvCorpoORDER.Index) < 1000000) do
  begin
    // Se il codice del rigo attuale  è relativo alla manodopera lo sposta in fondo
    if ASpostaOpera and (not VarIsNull(DC.Values[RI, tvCorpoCODICEARTICOLO.Index])) and DM1.CodiceIsManodopera(DC.Values[RI, tvCorpoCODICEARTICOLO.Index]) then
    begin
      DC.Values[RI, tvCorpoORDER.Index] := ManIndex;
      Inc(ManIndex);
    end
    // Se invece è un rigo relativo al riepilogo delle altre spese lo sposta in fondo (dopo anche della manodopera)
    else if ASpostaSpese and (not VarIsNull(DC.Values[RI, tvCorpoDESCRIZIONE.Index])) and
      (LeftStr(DC.Values[RI, tvCorpoDESCRIZIONE.Index], 20) = 'RIMBORSO SPESE VARIE') then
      DC.Values[RI, tvCorpoORDER.Index] := 2000000;
    // Passa al prox rigo
    Inc(RI);
  end;
  // Rigenera i valori di ORDER in modo da avere solo numeri interi
  RefreshOrderValues(tvCorpo);
end;

procedure TPreventiviOrdiniForm.MIIncollaRighiSelezionatiClick(Sender: TObject);
var
  Capt: String;
  RicalcolaTotali: Boolean;
  LAppendOrInsert: TAddArtMode;
begin
  RicalcolaTotali := False;
  DM1.ShowWait('Bacheca', 'Importazione...');
  // Aggiunto il BeginUpdate per provare a velocizare l'operazione che altrimenti
  // era molto lenta
//  GridCorpo.BeginUpdate; //NB: Ho provato a rimetterlo ma poi a volte dava degli access violation
  try
    // Cicla per tutti i documenti esportati indicati nella ListView della MainForm
    // e importa quelli selezionati nel documento attuale.
    while MainForm.ListViewExpDoc.SelCount > 0 do
    begin
      Capt := MainForm.ListViewExpDoc.Selected.Caption;
      DM1.ShowWait('', 'Importazione ' + Capt);

      // Se è un documento esportato ne importa i righi
      if (MainForm.ListViewExpDoc.Selected.ImageIndex = 0) or (MainForm.ListViewExpDoc.Selected.ImageIndex = 3) then
      begin
        ImportaDocFisc(DM1.ExpDocToDocType(Capt), DM1.ExpDocToDocReg(Capt), DM1.ExpDocToDocNum(Capt), DM1.ExpDocToDocDate(Capt), RifEnabled,
          MainForm.BachecaInsert);

        // Se si tratta di articoli importati dal terminalino Barcode
      end
      else if MainForm.ListViewExpDoc.Selected.ImageIndex = 4 then
      begin
        ImportaRighiCodiceQtaDallaBacheca(DM1.ExpDocToDocType(Capt), DM1.ExpDocToDocReg(Capt), DM1.ExpDocToDocNum(Capt), DM1.ExpDocToDocDate(Capt), RifEnabled,
          MainForm.BachecaInsert);

        // Se è un articolo esportato lo importa come articolo
      end
      else if MainForm.ListViewExpDoc.Selected.ImageIndex = 1 then
      begin
        // Fa in modo che ricalcoli i totali, ho fatto così perchè ho modificato la procedura
        // "NuovoRigoDocumento" in modo che non esegua il ricalcolo dei totali per ogni articolo importato
        // perchè altrimenti era molto lento.
        RicalcolaTotali := True;
        // Inserisce l'articolo nel documento.
        // NB: In base al valore del flag BachecaInsert della MainForm effettua l'Append del nuovo record
        // (BachecaInsert = False) oppure l'Insert (BachecaInsert := True).
        if MainForm.BachecaInsert then
          LAppendOrInsert := TAddArtMode.AM_Insert
        else
          LAppendOrInsert := TAddArtMode.AM_Append;
//        GridCorpo.BeginUpdate; //NB: Ho provato a rimetterlo ma poi a volte dava degli access violation
        try
          // NuovoRigoDocumento('', DM1.ExpArtToCodice(Capt), '', '', QryDocumentoCodiceMagazzino.AsString, AM_Append, DM1.ExpArtToQta(Capt), False);
          InserisciNuovoRigoDocumento(DM1.ExpArtToCodice(Capt), DM1.ExpArtToCodiceStm(Capt), QryDocumentoCODICEMAGAZZINO.AsString, LAppendOrInsert,
            DM1.ExpArtToQta(Capt), False);
        finally
//          GridCorpo.EndUpdate; //NB: Ho provato a rimetterlo ma poi a volte dava degli access violation
        end;
        // Elimina l'articolo appena importato
        DM1.EliminaExpArt(DM1.ExpArtToCodice(Capt), DM1.ExpArtToCodiceStm(Capt));
      end;
      // Elimina la voce
      MainForm.ListViewExpDoc.Selected.Delete;
    end;
  finally
    // Aggiunto il BeginUpdate per provare a velocizare l'operazione che altrimenti
    // era molto lenta
//    GridCorpo.EndUpdate; //NB: Ho provato a rimetterlo ma poi a volte dava degli access violation
    // Se abilitato e necessario ricalcola i totali del documento
    if RicalcolaTotali then
      CalcolaTotali(False);
    // Pulizie finali
    DM1.CloseWait;
    // Aggiorna la bacheca
    MainForm.AggiornaDocumentiEsportati;
  end;
end;

procedure TPreventiviOrdiniForm.MICreaScadenzeClick(Sender: TObject);
begin
  // Chiede prima conferma
  MessageBeep(0);
  if MessageDlg('Sei sicuro/a ?', mtWarning, [mbOk, mbNo], 0) = mrOk then
  begin
    DM1.Attendere;
    try
      CreaScadenzeDocumento;
    finally
      DM1.ChiudiAttendere;
    end;
  end;
end;

procedure TPreventiviOrdiniForm.MIAggiornaPrezziClick(Sender: TObject);
begin
  // Chiede prima conferma
  MessageBeep(0);
  if MessageDlg('Sei sicuro/a ?', mtWarning, [mbOk, mbNo], 0) = mrOk then
  begin
    DM1.Attendere;
    try
      AggiornaPrezziDocumento(tvCorpo.DataController, False);
      // Se abilitato e necessario ricalcola i totali del documento
      CalcolaTotali(False);
    finally
      DM1.ChiudiAttendere;
    end;
  end;
end;

procedure TPreventiviOrdiniForm.MenuRxDBGridCorpoDocPopup(Sender: TObject);
var
  RI: Longint;
  DC: TcxCustomDataController;
begin
  // DC Punta al DataController corrente
  DC := tvCorpo.DataController;
  // RI contiene l'indice al record corrente
  RI := DC.FocusedRecordIndex;

  FloppyCONAD.Visible := False;
  // Abilita/disabilita alcune voci del menù in base alla situazione
  if RxSpeedModifica.Down then
  begin
    MITotaleACorpo.Enabled := True and not MainForm.IsLevanteLight;
    TotaleacorpoSOLOdeirighiselezionati1.Enabled := True and not MainForm.IsLevanteLight;
    Aggiornaledescrizionidallelencoarticoli1.Enabled := True and not MainForm.IsLevanteLight;
    Aggiornaledescrizionidallelencoarticoli2.Enabled := True and not MainForm.IsLevanteLight;
    MICopiaRighiSelezionati.Enabled := False;
    MIIncollaRighiSelezionati.Enabled := True and not MainForm.IsLevanteLight;
    MIAggiornaPrezzi.Enabled := True and not MainForm.IsLevanteLight;
    Aggiornaiprezzideirighiselezionati1.Enabled := True and not MainForm.IsLevanteLight;
    AggiornairicarichiperfascedicostoTUTTIIRIGHI1.Enabled := (not DM1.IsDocumentoDiIngresso(QryDocumentoTIPODOCUMENTO.AsString)) and (DM1.TableProgressiviRICARICHIPERFASCEPREZZO.AsString = 'T') and not MainForm.IsLevanteLight;
    AggiornairicarichiperfascedicostoSOLORIGHISELEZIONATI1.Enabled := (not DM1.IsDocumentoDiIngresso(QryDocumentoTIPODOCUMENTO.AsString)) and (DM1.TableProgressiviRICARICHIPERFASCEPREZZO.AsString = 'T') and not MainForm.IsLevanteLight;
    Convertinomearticoloinnomegruppo1.Enabled := True and not MainForm.IsLevanteLight;
    MICreaScadenze.Enabled := False;
    Azzeragliscontideirighiselezionati1.Enabled := True and not MainForm.IsLevanteLight;
    Azzeragliscontidituttiirighi1.Enabled := True and not MainForm.IsLevanteLight;
    Esplodiirighiselezionati1.Enabled := True and not MainForm.IsLevanteLight;
    Esplodituttiirighideldocumento1.Enabled := True and not MainForm.IsLevanteLight;
    Selezionecumulativasottocantieri1.Enabled := True and not MainForm.IsLevanteLight;
    EsportaleQtinevasionenellabacheca1.Enabled := True and not MainForm.IsLevanteLight;
    SelezionecumulativaaliquotaIVA1.Enabled := True and not MainForm.IsLevanteLight;
    Aumentocumulativoprezzoarticoli1.Enabled := True and not MainForm.IsLevanteLight;
    Consideralasituazioneattualecomecostoericarica1.Enabled := True and not MainForm.IsLevanteLight;
    Caricaarticolidafile1.Enabled := True and not MainForm.IsLevanteLight;
    Salvaimpostazionidocumento1.Enabled := True and not MainForm.IsLevanteLight;
    Inversionecodiciarticolo1.Enabled := True and tvCorpoCODICEARTICOLO.Visible and (not MainForm.IsLevanteLight);
    EsportaExcel1.Enabled := False;
    EsportaTesto1.Enabled := False;
    EsportagrigliacorpodocumentoinformatoExcel1.Enabled := False;
    Aggiungidiciturapercessionecreditodimpostaecobonus1.Enabled := True;
    // Fà in modo che le NoteRigo non possano essere modificate se è un rigo di riferimento
    // ------------------------------------------------------------------------------------
    // Se si tratta du un rigo di riferimento ad un documento importato non permette nessuna modifica
    // (NB: Riconosce che si trova su un riferimento di un rigo importato perchè
    // in questo caso il campo 'CodiceIVA' = -9 e la descrizione dell'articolo
    // inizia con '--->'
    Editordescrizione1.Enabled := not((DM1.NoNullIntValue(DC, RI, tvCorpoCODICEIVA.Index) = -9) and
      (DM1.StrLeft(DM1.NoNullStringValue(DC, RI, tvCorpoDESCRIZIONE.Index), 4) = '--->'));
    Editordescrizione1.Enabled := Editordescrizione1.Enabled and (not MainForm.IsLevanteLight);
  end
  else
  begin
    Editordescrizione1.Enabled := False;
    MITotaleACorpo.Enabled := False;
    TotaleacorpoSOLOdeirighiselezionati1.Enabled := False;
    Aggiornaledescrizionidallelencoarticoli1.Enabled := False;
    Aggiornaledescrizionidallelencoarticoli2.Enabled := False;
    MICopiaRighiSelezionati.Enabled := True and not MainForm.IsLevanteLight;
    MIIncollaRighiSelezionati.Enabled := False;
    MIAggiornaPrezzi.Enabled := False;
    Aggiornaiprezzideirighiselezionati1.Enabled := False;
    AggiornairicarichiperfascedicostoTUTTIIRIGHI1.Enabled := False;
    AggiornairicarichiperfascedicostoSOLORIGHISELEZIONATI1.Enabled := False;
    Convertinomearticoloinnomegruppo1.Enabled := False;
    MICreaScadenze.Enabled := True and not MainForm.IsLevanteLight;
    Azzeragliscontideirighiselezionati1.Enabled := False;
    Azzeragliscontidituttiirighi1.Enabled := False;
    Esplodiirighiselezionati1.Enabled := False;
    Esplodituttiirighideldocumento1.Enabled := False;
    Selezionecumulativasottocantieri1.Enabled := False;
    EsportaleQtinevasionenellabacheca1.Enabled := False;
    SelezionecumulativaaliquotaIVA1.Enabled := False;
    Aumentocumulativoprezzoarticoli1.Enabled := False;
    Consideralasituazioneattualecomecostoericarica1.Enabled := False;
    Salvaimpostazionidocumento1.Enabled := False;
    Inversionecodiciarticolo1.Enabled := False;
    EsportaExcel1.Enabled := True;
    EsportaTesto1.Enabled := True;
    EsportagrigliacorpodocumentoinformatoExcel1.Enabled := True;
    Caricaarticolidafile1.Enabled := False;
    Aggiungidiciturapercessionecreditodimpostaecobonus1.Enabled := False;
    // Se si tratta di una fattura e se tale funzione e abilitata
    // abilita la possibilità di fare il disco per la rifatturazione
    // CONAD
    if TipoDoc = 'Fattura' then
    begin
      // if DM1.ModCtrl(MOD_DISCO_RIFATTURAZIONE) > 0 then FloppyCONAD.Visible := True;
    end;
  end;
end;

procedure TPreventiviOrdiniForm.RxSpeedButtonStampaClick(Sender: TObject);
begin
  // Richiama la procedura che si occupa di stampare il documento
  DM1.Attendere;
  try
    StampaDocFisc(TipoDoc, Registro, NumeroDoc, DataDoc, 1, DM1.CopieDocFisc(TipoDoc), False);
  finally
    DM1.ChiudiAttendere;
  end;
end;

procedure TPreventiviOrdiniForm.SBCalcolaClick(Sender: TObject);
begin
  DM1.Attendere;
  CalcolaTotali(True);
  DM1.ChiudiAttendere;
end;

procedure TPreventiviOrdiniForm.SBCollapseSoggettiClick(Sender: TObject);
begin
  tvCorpo.ViewData.Collapse(False);
end;

procedure TPreventiviOrdiniForm.Salvaimpostazionidocumento1Click(Sender: TObject);
begin
  // Chiede prima conferma
  MessageBeep(0);
  if MessageDlg('Sei sicuro/a ?', mtWarning, [mbOk, mbNo], 0) = mrOk then
    // Salva le impostazioni delle colonne dei clienti
    // DM1.SalvaGriglieDevExpress(GridCorpo, TipoDoc, False);
    DM1.SalvaDevExPropertiesStore(PropertiesStore, 'CorpoDoc_' + TipoDoc, False);
end;

procedure TPreventiviOrdiniForm.RxSpeedButtonStampaMouseUp(Sender: TObject; Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
var
  ClientPoint, ScreenPoint: TPoint;
begin
  // *************************************************************************
  // NB: FACENDO CLICK COL DX RICHIAMA IL MENU' DI STAMPA
  // *************************************************************************
  if Button = mbRight then
  begin
    // Esegue la conversione delle coordinate dove dovrà apparire il menù
    // da coordinate client della finestra a coordinate assolute dello schermo.
    // (NB: Il menù popup apparirà in prossimità del tasto NUOVO)
    ClientPoint.X := RxSpeedButtonStampa.Left + 10 + ClientTopPanel.Left;
    ClientPoint.Y := RxSpeedButtonStampa.Top + 10;
    ScreenPoint := ClientToScreen(ClientPoint);
    // Imposta la proprietà TAG del menù (0=Anteprima, 1=Stampa, 2=Fax, 3=Email)
    MenuStampe.Tag := 0;
    MenuStampe.Popup(ScreenPoint.X, ScreenPoint.Y);
  end;
end;

procedure TPreventiviOrdiniForm.FloppyCONADClick(Sender: TObject);
// var
// Fattura:TStringList;
// NumProgr, NumFattura:Integer;
begin
  // // Chiede prima conferma
  // MessageBeep(0);
  // if MessageDlg('Inserire un floppy disk nell''unità A:', mtConfirmation, [mbOk, mbCancel], 0) = mrOk then begin
  // DM1.Attendere;
  // Fattura     := TStringList.Create;
  // NumProgr    := 0;
  // NumFattura  := DM1.TablePreventiviOrdiniNumOrdPrev.Value;
  // DM1.TableRighiDocumento.First;
  // while not DM1.TableRighiDocumento.EOF do begin
  // // Se il rigo attuale è un riferimento ad un DDT lo inserisce come tipo record
  // //  01 (Testata), altrimenti come tipo record 2 (Riga)
  // if (DM1.TableRighiDocumentoDescrizione.Value[1] = '-')
  // and(DM1.TableRighiDocumentoDescrizione.Value[2] = '-')
  // and(DM1.TableRighiDocumentoDescrizione.Value[3] = '-')
  // and(DM1.TableRighiDocumentoDescrizione.Value[4] = '>') then begin
  // NumProgr := NumProgr + 1;
  // Fattura.Add('01' +
  // DM1.Padr(IntToStr(NumProgr), ' ', 5) +
  // DM1.Padr(IntToStr(NumFattura), ' ', 6) +
  // FormatDateTime('yymmdd', DM1.TablePreventiviOrdiniDataDocumento.Value) +
  // DM1.RifToNumDoc(DM1.TableRighiDocumentoDescrizione.Value, 6) +
  // DM1.RifToDataDoc(DM1.TableRighiDocumentoDescrizione.Value) +
  // '                                              ' + // 46 Spazi
  // DM1.PadR(DM1.TableRighiDocumentoNoteRigo.Value, ' ', 15) + // Codice Cliente destinatario
  // '                                    '); // 36 Spazi per arrivare a 128 caratteri
  // DM1.TableRighiDocumento.Next;
  // end else begin
  // // Se la QTA = 0 significa che è un rigo descrittivo e non un articolo e quindi lo salta
  // if (not DM1.TableRighiDocumentoQTA.IsNull)and(DM1.TableRighiDocumentoQTA.Value <> 0) then begin
  // Fattura.Add('02' +
  // DM1.Padr(IntToStr(NumProgr), ' ', 5) +
  // DM1.StrLeft(DM1.TableRighiDocumentoCodiceArticolo.Value, 15) +
  // DM1.PadL(Trim(DM1.StrLeft(DM1.TableRighiDocumentoDescrizione.Value, 30)), ' ', 30) +
  // DM1.StrLeft(DM1.TableRighiDocumentoUnitaDiMisura.Value, 2) +
  // DM1.PadR(IntToStr(Round(DM1.TableRighiDocumentoQTA.Value * 100)), ' ', 7) +
  // DM1.PadR(IntToStr(Round(DM1.TableRighiDocumentoPrezzoUnitario.Value * 100)), ' ', 9) +
  // DM1.PadR(IntToStr(Round(DM1.TableRighiDocumentoImportoRigo.Value)), ' ', 9) +
  // '    ' + // 4 Spazi (Numero pezzi)
  // ' ' + // 1 Spazio (Tipo IVA ' ' = soggetto ad aliquota normale
  // DM1.Padr(IntToStr(DM1.TableRighiDocumentoCodiceIVA.Value), ' ', 2) +
  // ' ' + // 1 Spazio (Tipo movimento  ' ' = Merce)
  // '1' + // 1 Carattere (Tipo cessione '1' = Vendita merce)
  // '          ' + // 11 Spazi vuoti
  // ' ' + // 1 Carattere Tipo Trattamento (Non gestito)
  // '     ' + // 5 Caratteri costo trasporto per unità consegnata
  // ' ' + // 1 Carattere Codice contabile (' ' = Normale)
  // ' ' + // 1 Carattere TipoFattura (' ' = Fattura di vendita)
  // '                      '); // 22 Spazi vuoti per arrivare a 128 caratteri
  // end;
  // DM1.TableRighiDocumento.Next;
  // end;
  // end;
  // // Alla fine di tutto salva la String list sul floppy e libera la memoria
  // Fattura.SaveToFile('a:\conad.asc');
  // Fattura.Free;
  // DM1.ChiudiAttendere;
  // end;
end;

procedure TPreventiviOrdiniForm.DBEdit1Enter(Sender: TObject);
begin
  if Sender is TDBComboBox then
  begin
    if (Sender as TDBComboBox).Color = COLOR_MODIFICA then
      (Sender as TDBComboBox).Color := COLOR_FOCUS;
    ActiveControlName := (Sender as TDBComboBox).Name;
  end
  else if Sender is TDBEdit then
  begin
    if (Sender as TDBEdit).Color = COLOR_MODIFICA then
      (Sender as TDBEdit).Color := COLOR_FOCUS;
    ActiveControlName := (Sender as TDBEdit).Name;
  end
  else if Sender is TDBLookupComboBox then
  begin
    if (Sender as TDBLookupComboBox).Color = COLOR_MODIFICA then
      (Sender as TDBLookupComboBox).Color := COLOR_FOCUS;
    ActiveControlName := (Sender as TDBLookupComboBox).Name;
  end
  else if Sender is TDBCheckBox then
  begin
    if (Sender as TDBCheckBox).Color = COLOR_MODIFICA then
      (Sender as TDBCheckBox).Color := COLOR_FOCUS;
    ActiveControlName := (Sender as TDBCheckBox).Name;
  end
  else if Sender is TDBMemo then
  begin
    if (Sender as TDBMemo).Color = COLOR_MODIFICA then
      (Sender as TDBMemo).Color := COLOR_FOCUS;
    ActiveControlName := (Sender as TDBMemo).Name;
  end
  else if Sender is TEdit then
  begin
    if (Sender as TEdit).Color = COLOR_MODIFICA then
      (Sender as TEdit).Color := COLOR_FOCUS;
    ActiveControlName := (Sender as TEdit).Name;
  end
  else if Sender is TcxCurrencyEdit then
  begin
    if (Sender as TcxCurrencyEdit).Style.Color = COLOR_MODIFICA then
      (Sender as TcxCurrencyEdit).Style.Color := COLOR_FOCUS;
    ActiveControlName := (Sender as TcxCurrencyEdit).Name;
  end
  else if Sender is TcxDBTextEdit then
  begin
    if (Sender as TcxDBTextEdit).Style.Color = COLOR_MODIFICA then
      (Sender as TcxDBTextEdit).Style.Color := COLOR_FOCUS;
    ActiveControlName := (Sender as TcxDBTextEdit).Name;
  end
  else if Sender is TcxComboBox then
  begin
    if (Sender as TcxComboBox).Style.Color = COLOR_MODIFICA then
      (Sender as TcxComboBox).Style.Color := COLOR_FOCUS;
    ActiveControlName := (Sender as TcxComboBox).Name;
  end
  else if Sender is TcxDBComboBox then
  begin
    if (Sender as TcxDBComboBox).Style.Color = COLOR_MODIFICA then
      (Sender as TcxDBComboBox).Style.Color := COLOR_FOCUS;
    ActiveControlName := (Sender as TcxDBComboBox).Name;
  end
  else if Sender is TcxDBDateEdit then
  begin
    if (Sender as TcxDBDateEdit).Style.Color = COLOR_MODIFICA then
      (Sender as TcxDBDateEdit).Style.Color := COLOR_FOCUS;
    ActiveControlName := (Sender as TcxDBDateEdit).Name;
  end
  else if Sender is TcxTextEdit then
  begin
    if (Sender as TcxTextEdit).Style.Color = COLOR_MODIFICA then
      (Sender as TcxTextEdit).Style.Color := COLOR_FOCUS;
    ActiveControlName := (Sender as TcxTextEdit).Name;
  end
  else if Sender is TcxDBImageComboBox then
  begin
    if (Sender as TcxDBImageComboBox).Style.Color = COLOR_MODIFICA then
      (Sender as TcxDBImageComboBox).Style.Color := COLOR_FOCUS;
    ActiveControlName := (Sender as TcxDBImageComboBox).Name;
  end
  else if Sender is TcxGrid then
  begin
    // NB: Per quanto riguarda le griglie serve solo per impostare la variabile ActiveControlName;
    ActiveControlName := (Sender as TcxGrid).Name;
  end;
  // Controlla se il controllo che ha il form fa parte del pannello dei dati
  // del destinatario del documento, ed eventualmente espande il relativo pannello.
  if (Sender as TControl).Parent is TPanel then
  begin
    if ((Sender as TControl).Parent as TPanel).Name = PanelDestinatario.Name then
      ApriPannelloIntestatario(PanelDestinatario)
    else
      ChiudiPannelloIntestatario(PanelDestinatario);
  end
  else
    ChiudiPannelloIntestatario(PanelDestinatario);
  // Controlla se il controllo che ha il form fa parte del pannello dei dati
  // della destinazione merce del documento, ed eventualmente espande il relativo pannello.
  if (Sender as TControl).Parent is TPanel then
  begin
    if ((Sender as TControl).Parent as TPanel).Name = PanelLuogoDestinazione.Name then
      ApriPannelloIntestatario(PanelLuogoDestinazione)
    else
      ChiudiPannelloIntestatario(PanelLuogoDestinazione);
  end
  else
    ChiudiPannelloIntestatario(PanelLuogoDestinazione);
end;

procedure TPreventiviOrdiniForm.DBEdit1Exit(Sender: TObject);
begin
  // Azzera il nome del controllo attivo
  ActiveControlName := '';

  if Sender is TDBComboBox then
  begin
    if (Sender as TDBComboBox).Color = COLOR_FOCUS then
      (Sender as TDBComboBox).Color := COLOR_MODIFICA;
  end
  else if Sender is TDBEdit then
  begin
    if (Sender as TDBEdit).Color = COLOR_FOCUS then
      (Sender as TDBEdit).Color := COLOR_MODIFICA;
  end
  else if Sender is TDBLookupComboBox then
  begin
    if (Sender as TDBLookupComboBox).Color = COLOR_FOCUS then
      (Sender as TDBLookupComboBox).Color := COLOR_MODIFICA;
  end
  else if Sender is TDBCheckBox then
  begin
    if (Sender as TDBCheckBox).Color = COLOR_FOCUS then
      (Sender as TDBCheckBox).Color := COLOR_MODIFICA;
  end
  else if Sender is TDBMemo then
  begin
    if (Sender as TDBMemo).Color = COLOR_FOCUS then
      (Sender as TDBMemo).Color := COLOR_MODIFICA;
  end
  else if Sender is TEdit then
  begin
    if (Sender as TEdit).Color = COLOR_FOCUS then
      (Sender as TEdit).Color := COLOR_MODIFICA;
  end
  else if Sender is TcxCurrencyEdit then
  begin
    if (Sender as TcxCurrencyEdit).Style.Color = COLOR_FOCUS then
      (Sender as TcxCurrencyEdit).Style.Color := COLOR_MODIFICA;
  end
  else if Sender is TcxDBTextEdit then
  begin
    if (Sender as TcxDBTextEdit).Style.Color = COLOR_FOCUS then
      (Sender as TcxDBTextEdit).Style.Color := COLOR_MODIFICA;
  end
  else if Sender is TcxComboBox then
  begin
    if (Sender as TcxComboBox).Style.Color = COLOR_FOCUS then
      (Sender as TcxComboBox).Style.Color := COLOR_MODIFICA;
  end
  else if Sender is TcxDBComboBox then
  begin
    if (Sender as TcxDBComboBox).Style.Color = COLOR_FOCUS then
      (Sender as TcxDBComboBox).Style.Color := COLOR_MODIFICA;
  end
  else if Sender is TcxDBDateEdit then
  begin
    if (Sender as TcxDBDateEdit).Style.Color = COLOR_FOCUS then
      (Sender as TcxDBDateEdit).Style.Color := COLOR_MODIFICA;
  end
  else if Sender is TcxTextEdit then
  begin
    if (Sender as TcxTextEdit).Style.Color = COLOR_FOCUS then
      (Sender as TcxTextEdit).Style.Color := COLOR_MODIFICA;
  end
  else if Sender is TcxDBImageComboBox then
  begin
    if (Sender as TcxDBImageComboBox).Style.Color = COLOR_FOCUS then
      (Sender as TcxDBImageComboBox).Style.Color := COLOR_MODIFICA;
  end;
end;

procedure TPreventiviOrdiniForm.AggiornaDescrizioniArticoliRighiSelezionati(AView: TcxGridTableView);
var
  i: Integer;
  Q: TIB_Cursor;
  LCodiceArticolo: Variant;
begin
  // Se non ci sono righi selezionati non fa nulla
  if AView.Controller.SelectedRecordCount = 0 then
  begin
    DM1.Messaggi('Levante', 'Non ci sono righi selezionati.', '', [mbOk], 0, nil);
    Exit;
  end;
  Q := TIB_Cursor.Create(Self);
  try
    Q.DatabaseName := DM1.ArcDBFile;
    Q.IB_Connection := DM1.DBAzienda;
    Q.SQL.Add('SELECT DESCRIZIONE FROM ARTICOLI WHERE CODICEARTICOLO = :P_CODICEARTICOLO');
    Q.Prepare;
    // Disabilita l'aggiornamento dello schermo
    GridCorpo.BeginUpdate;
    // Cicla per tutti i righi selezionati...
    for i := 0 to AView.Controller.SelectedRecordCount - 1 do
    begin
      LCodiceArticolo := AView.Controller.SelectedRecords[i].Values[tvCorpoCODICEARTICOLO.Index];
      if VarIsNull(LCodiceArticolo) or (Trim(LCodiceArticolo) = '') then
        Continue;
      Q.ParamByName('P_CODICEARTICOLO').AsString := AView.Controller.SelectedRecords[i].Values[tvCorpoCODICEARTICOLO.Index];
      Q.Open;
      if not Q.Eof then
        AView.Controller.SelectedRecords[i].Values[tvCorpoDESCRIZIONE.Index] := Q.Fields[0].AsString;
      Q.Close;
    end;
  finally
    Q.Free;
    GridCorpo.EndUpdate;
  end;
end;

// Procedura che effettua il totale a corpo solo dei righi selezionati.
procedure TPreventiviOrdiniForm.TotaleACorpoRighiSelezionati(AView: TcxGridTableView);
var
  i: Integer;
  TopRecordIndex, BottomRecordIndex: Integer;
  TopSelectedOrder, BottomSelectedOrder: Double;
  CurrRowSection: String;
begin
  // Se non ci sono righi selezionati non fa nulla
  if AView.Controller.SelectedRecordCount = 0 then
  begin
    DM1.Messaggi('Totale a corpo', 'Non ci sono righi selezionati.', '', [mbOk], 0, nil);
    Exit;
  end;
  // Verifica che tutti i righi selezionati siano consecutivi.
  if not RighiSelezionatiConsecutivi(AView) then
  begin
    DM1.Messaggi('Totale a corpo', 'I righi selezionati devono essere consecutivi e della stessa sezione.', '', [mbOk], 0, nil);
    Exit;
  end;
  // Per sicurezza rinfresca i calori della colonna "ORDER"
  // RefreshOrderValues(AView);
  // Inizializzazione
  TopRecordIndex := AView.Controller.SelectedRecords[0].RecordIndex;
  TopSelectedOrder := AView.Controller.SelectedRecords[0].Values[tvCorpoORDER.Index];
  BottomRecordIndex := AView.Controller.SelectedRecords[AView.Controller.SelectedRecordCount - 1].RecordIndex;
  BottomSelectedOrder := AView.Controller.SelectedRecords[AView.Controller.SelectedRecordCount - 1].Values[tvCorpoORDER.Index];
  // Disabilita l'aggiornamento dello schermo
  GridCorpo.BeginUpdate;
  try
    // Cicla per tutti i righi selezionati...
    for i := 0 to AView.Controller.SelectedRecordCount - 1 do
    begin
      // Imposta il RowType a "TC_Rigo_"
      AView.Controller.SelectedRecords[i].Values[tvCorpoROWTYPE.Index] := TIPORIGODOC_TC_Rigo;
      // Memorizza la sezione corrente
      CurrRowSection := VarToStr(AView.Controller.SelectedRecords[i].Values[tvCorpoROWSECTION.Index]);
    end;
    // Aggiunge la riga del totale a corpo e ne imposta il valore del
    // suo campo ORDER in modo che appaia sotto l'ultimo rigo selezionato
    i := AView.DataController.InsertRecord(BottomRecordIndex + 1);
    AView.DataController.Values[i, tvCorpoORDER.Index] := BottomSelectedOrder + 0.1;
    AView.DataController.Values[i, tvCorpoDESCRIZIONE.Index] := 'TOTALE A CORPO:';
    AView.DataController.Values[i, tvCorpoQTA.Index] := 1;
    AView.DataController.Values[i, tvCorpoCODICEIVA.Index] := DocIvaDefault.Codice;
    AView.DataController.Values[i, tvCorpoALIQUOTAIVA.Index] := DocIvaDefault.AliquotaIVA;
    AView.DataController.Values[i, tvCorpoDESCRIZIONEIVA.Index] := DocIvaDefault.Descrizione;
    AView.DataController.Values[i, tvCorpoROWSECTION.Index] := CurrRowSection;
    AView.DataController.Values[i, tvCorpoROWTYPE.Index] := TIPORIGODOC_TC_Totale;
    AView.DataController.Values[i, tvCorpoPREZZOUNITARIOAUTOCALC.Index] := 'T';
  finally
    GridCorpo.EndUpdate;
  end;
  // Effettua alcuni ricalcoli per il nuovo rigo.
  // CalcolaPerModificaPrezzoUnitario(I, AView.DataController);
  // CalcolaImportoRigo(AView.DataController, I);
  // Se abilitato e necessario ricalcola i totali del documento
  CalcolaTotali(False);
  // ---------------------------------------------------------------------------
  // Aggiunge anche un rigo vuoto per separazione
  // NB: Solo se non siamo già alla fine del documento
  // i := AView.DataController.InsertRecord(BottomRecordIndex + 2);
  // AView.DataController.Values[i, tvCorpoORDER.Index] := BottomSelectedOrder + 0.2;
  // AView.DataController.Values[i, tvCorpoDESCRIZIONE.Index] := '----------------------------------------';
  // AView.DataController.Values[i, tvCorpoROWSECTION.Index] := CurrRowSection;
  // ---------------------------------------------------------------------------
  // Aggiunge un rigo vuoto anche all'inizio dei righi selezionati per separazione.
  // NB:  Ovviamente solo se il primo rigo selezionato in alto non  il primo rigo della griglia.
  // i := AView.DataController.InsertRecord(TopRecordIndex);
  // AView.DataController.Values[i, tvCorpoORDER.Index] := TopSelectedOrder - 0.1;
  // AView.DataController.Values[i, tvCorpoDESCRIZIONE.Index] := '----------------------------------------';
  // AView.DataController.Values[i, tvCorpoROWSECTION.Index] := CurrRowSection;
  // ---------------------------------------------------------------------------
  // Per sicurezza rinfresca i calori della colonna "ORDER"
  RefreshOrderValues(AView);
end;

// Funzione che ritorna True se tutti i righi selezionati nella griglia sono
// consecutivi.
function TPreventiviOrdiniForm.RighiSelezionatiConsecutivi(AView: TcxGridTableView): Boolean;
var
  i, PrecOrderValue: Integer;
  CurrSectionValue, PrecSectionValue: String;
begin
  Result := True;
  PrecSectionValue := 'START';
  for i := 0 to AView.Controller.SelectedRecordCount - 1 do
  begin
    if not AView.Controller.SelectedRecords[i].IsData then
      Continue;
    if (i > 0) and (AView.Controller.SelectedRecords[i].Values[tvCorpoORDER.Index] <> (PrecOrderValue + 1)) then
      Exit(False);
    CurrSectionValue := VarToStr(AView.Controller.SelectedRecords[i].Values[tvCorpoROWSECTION.Index]);
    if (CurrSectionValue <> PrecSectionValue) and (PrecSectionValue <> 'START') then
      Exit(False);
    PrecOrderValue := AView.Controller.SelectedRecords[i].Values[tvCorpoORDER.Index];
    PrecSectionValue := CurrSectionValue;
  end;
end;

procedure TPreventiviOrdiniForm.MITotaleACorpoClick(Sender: TObject);
begin
  if DM1.Messaggi('Totale a corpo', 'Confermi di voler fare il totale a corpo di tutto il documento?', '', [mbYes, mbNo], 0, nil) <> mrYes then
    Exit;
  DM1.ShowWait('Totale a corpo', 'Operazione in corso...');
  try
    tvCorpo.Controller.SelectAllRecords;
    TotaleACorpoRighiSelezionati(tvCorpo);
    tvCorpo.Controller.ClearSelection;
  finally
    DM1.CloseWait;
  end;
end;

procedure TPreventiviOrdiniForm.Stampa2Click(Sender: TObject);
var
  NumCopie: Integer;
begin
  // Richiama la procedura che si occupa di stampare il documento
  DM1.Attendere;
  // Carica nella variabile NumCOpie il numero delle copie di default e se sono
  // = 0 le fa diventare 1
  NumCopie := DM1.CopieDocFisc(TipoDoc);
  if NumCopie = 0 then
    NumCopie := -1;
  if NumCopie > 0 then
    NumCopie := NumCopie * (-1);
  try
    StampaDocFisc(TipoDoc, Registro, NumeroDoc, DataDoc, 1, NumCopie, False);
  finally
    DM1.ChiudiAttendere;
  end;
end;

procedure TPreventiviOrdiniForm.Anteprimadistampa1Click(Sender: TObject);
begin
  // Richiama la preview di stampa
  StampaDocFisc(TipoDoc, Registro, NumeroDoc, DataDoc, 0, 1, False);
end;

procedure TPreventiviOrdiniForm.RxSpeedButtonHelpClick(Sender: TObject);
begin
  HelpForm.Aiuto('PREVENTIVI, DDT, FATTURE, ORDINI, ECC.');
end;

procedure TPreventiviOrdiniForm.QryDocumentoCODICECLIENTEChange(Sender: TField);
var
  QryCli: TIB_Cursor;
begin
  // Carica i dati del cliente
  QryCli := TIB_Cursor.Create(Self);
  try
    QryCli.DatabaseName := DM1.ArcDBFile;
    QryCli.IB_Connection := DM1.DBAzienda;
    QryCli.SQL.Add('SELECT RagioneSociale, Nome, Cognome, TipoPersona, Indirizzo, NumCivico, Citta, CAP, Provincia, PartitaIVA, CodiceFiscale, Listino, Sconto, Pagamento,  ABI, CAB,');
    QryCli.SQL.Add('RagSocDestinazMerci, IndirizzoDestinazMerci, NumCivicoDestinazMerci, CittaDestinazMerci, CAPDestinazMerci, ProvinciaDestinazMerci, RitAccPerc, ESIGIBILITAIVA,');
    QryCli.SQL.Add('ADG1_TIPODATO, ADG1_RIFERIMENTOTESTO, ADG1_RIFERIMENTONUMERO, ADG1_RIFERIMENTODATA,');
    QryCli.SQL.Add('ADG2_TIPODATO, ADG2_RIFERIMENTOTESTO, ADG2_RIFERIMENTONUMERO, ADG2_RIFERIMENTODATA');
    QryCli.SQL.Add('FROM Clienti WHERE Codice = ' + QryDocumentoCODICECLIENTE.AsString);
    QryCli.Open;
    // Carica i dati l'indirizzo del cliente come destinazione merci del documento attuale
    if not QryCli.Eof then
    begin
      QryDocumentoRAGSOCCLI.Value := DM2.GetDenominazioneSoggetto(QryCli);
      QryDocumentoINDIRIZZOCLI.Value := QryCli.FieldByName('Indirizzo').AsString;
      QryDocumentoNUMCIVICOCLI.Value := QryCli.FieldByName('NumCivico').AsString;
      QryDocumentoCITTACLI.Value := QryCli.FieldByName('Citta').AsString;
      QryDocumentoCAPCLI.Value := QryCli.FieldByName('CAP').AsString;
      QryDocumentoPROVINCIACLI.Value := QryCli.FieldByName('Provincia').AsString;

      // Carica i valori dell'aliquota IVA di default del documento
      QryDocumentoPARTITAIVACLI.Value := QryCli.FieldByName('PartitaIVA').AsString;
      QryDocumentoCODICEFISCALECLI.Value := QryCli.FieldByName('CodiceFIscale').AsString;
      QryDocumentoSPLITPAYMENT.Value := QryCli.FieldByName('ESIGIBILITAIVA').AsString;

      CaricaAliquotaIVADefaultDocumento;

      QryDocumentoLISTINO.Value := QryCli.FieldByName('Listino').AsInteger;

      // Se il flag che indica che gli sconti devono devono essere messi sui righi documenti
      // non è settato...
      ScontoSoggetto := QryCli.FieldByName('Sconto').AsFloat;
      if DM1.TableProgressiviSCONTOSOGGNELRIGO.AsString <> 'T' then
      begin
        QryDocumentoSCONTOALIQUOTA1.Value := ScontoSoggetto;
        QryDocumentoSCONTOALIQUOTA2.Value := ScontoSoggetto;
        QryDocumentoSCONTOALIQUOTA3.Value := ScontoSoggetto;
        QryDocumentoSCONTOALIQUOTA4.Value := ScontoSoggetto;
      end;

      // Se il cliente ha una modalità di pagamento specificata la carica anche nel documento
      // altrimenti azzera il tutto
      if QryCli.FieldByName('Pagamento').IsNull or (QryCli.FieldByName('Pagamento').AsInteger = 0) then
      begin
        QryDocumentoPAGAMENTO.Clear;
        DescrizionePagamento.Text := '';
      end
      else
      begin
        QryDocumentoPAGAMENTO.Value := QryCli.FieldByName('Pagamento').AsInteger;
        DM1.CaricaDescrizionePagamento(QryDocumentoPAGAMENTO.Value, DescrizionePagamento);
      end;

      // Se il cliente ha una banca specificata la carica anche sul documento, altrimenti
      // azzera i relativi campi
      if QryCli.FieldByName('ABI').IsNull or QryCli.FieldByName('CAB').IsNull or (Trim(QryCli.FieldByName('ABI').AsString) = '') or
        (Trim(QryCli.FieldByName('CAB').AsString) = '') then
      begin
        QryDocumentoABI.Clear;
        QryDocumentoCAB.Clear;
        Banca.Text := '';
        ABI.Text := '';
        CAB.Text := '';
        BIC.Text := '';
        QryDocumentoIBAN.AsString := '';
      end
      else
      begin
        QryDocumentoABI.Value := QryCli.FieldByName('ABI').AsString;
        QryDocumentoCAB.Value := QryCli.FieldByName('CAB').AsString;
        if (not QryDocumentoABI.IsNull) and (not QryDocumentoCAB.IsNull) then
          DM1.CaricaDatiBanca(QryDocumentoABI.Value, QryDocumentoCAB.Value, Banca, ABI, CAB, BIC);
      end;

      // Se il documento non fa parte dei un cantiere carica la destinazione della merce eventualmente
      // caricata nell'anagrafica del soggetto
      if QryDocumentoPRATICA.IsNull or (QryDocumentoPRATICA.AsInteger = 0) then
      begin
        QryDocumentoRAGSOCDESTMERCI.Value := QryCli.FieldByName('RagSocDestinazMerci').AsString;
        QryDocumentoINDIRIZZODESTMERCI.Value := QryCli.FieldByName('IndirizzoDestinazMerci').AsString;
        QryDocumentoNUMCIVICODESTMERCI.Value := QryCli.FieldByName('NumCivicoDestinazMerci').AsString;
        QryDocumentoCITTADESTMERCI.Value := QryCli.FieldByName('CittaDestinazMerci').AsString;
        QryDocumentoPROVINCIADESTMERCI.Value := QryCli.FieldByName('ProvinciaDestinazMerci').AsString;
        QryDocumentoCAPDESTMERCI.Value := QryCli.FieldByName('CAPDestinazMerci').AsString;
      end;

      // Se nell'anagrafica del cliente è specificata una RItenuta di acconto e siamo
      // in una Fattura lo imposta automaticamente
      if (QryDocumentoTIPODOCUMENTO.AsString = 'Fattura') or (QryDocumentoTIPODOCUMENTO.AsString = 'Fatt.R.F.') then
      begin
        QryDocumentoRITACCPERC.Value := QryCli.FieldByName('RITACCPERC').AsFloat;
      end;
    end;

    // Carica gli agenti
    DM1.SetAgenti(QryDocumento, 'CODICECLIENTE', 'PRATICA', 'DATAPRATICA1');

    // Se abilitato e necessario ricalcola i totali del documento
    CalcolaTotali(False);
    // Controlla se il soggetto è fuori fido ed eventualmente avvisa l'utente
    if ClientiForm.ControllaScopertoCliente(QryDocumentoTIPODOCUMENTO.AsString, QryDocumentoNUMORDPREV.AsInteger, QryDocumentoREGISTRO.AsString,
      QryDocumentoDATADOCUMENTO.AsDateTime, QryDocumentoCODICECLIENTE.AsString, QryDocumentoTOTALEDAPAGARE.AsCurrency, False) then
      DM1.Messaggi('ATTENZIONE !!! - Controllo fido cliente',
        'FIDO SUPERATO !!!'#13#13'Il debito accumulato dal soggetto ha superato l''importo del fido concesso.', '', [mbOk], 0, nil);

    // Aggiorna anche l'impegno se il documento è un impegno
    if Self.IsImpegno and (ImpegnoForm.QryImp.State <> dsBrowse) then
    begin
      PreventiviOrdiniForm.QryDocumentoCODICECLIENTE.OnChange := nil;
      ImpegnoForm.QryImpCLIENTE.Value := PreventiviOrdiniForm.QryDocumentoCODICECLIENTE.Value;
      PreventiviOrdiniForm.QryDocumentoCODICECLIENTE.OnChange := QryDocumentoCODICECLIENTEChange;
    end;

    // Aggiorna gli "AltriDatiGestionali" relativi alla fattura elettronica
    if QryCli.FieldByName('ADG1_TIPODATO').IsNull then
      QryDocumentoADG1_TIPODATO.Clear
    else
      QryDocumentoADG1_TIPODATO.Value := QryCli.FieldByName('ADG1_TIPODATO').AsString;

    if QryCli.FieldByName('ADG1_RIFERIMENTOTESTO').IsNull then
      QryDocumentoADG1_RIFERIMENTOTESTO.Clear
    else
      QryDocumentoADG1_RIFERIMENTOTESTO.Value := QryCli.FieldByName('ADG1_RIFERIMENTOTESTO').AsString;

    if QryCli.FieldByName('ADG1_RIFERIMENTONUMERO').IsNull then
      QryDocumentoADG1_RIFERIMENTONUMERO.Clear
    else
      QryDocumentoADG1_RIFERIMENTONUMERO.Value := QryCli.FieldByName('ADG1_RIFERIMENTONUMERO').AsFloat;

    if QryCli.FieldByName('ADG1_RIFERIMENTODATA').IsNull then
      QryDocumentoADG1_RIFERIMENTODATA.Clear
    else
      QryDocumentoADG1_RIFERIMENTODATA.Value := QryCli.FieldByName('ADG1_RIFERIMENTODATA').AsDateTime;

    if QryCli.FieldByName('ADG2_TIPODATO').IsNull then
      QryDocumentoADG2_TIPODATO.Clear
    else
      QryDocumentoADG2_TIPODATO.Value := QryCli.FieldByName('ADG2_TIPODATO').AsString;

    if QryCli.FieldByName('ADG2_RIFERIMENTOTESTO').IsNull then
      QryDocumentoADG2_RIFERIMENTOTESTO.Clear
    else
      QryDocumentoADG2_RIFERIMENTOTESTO.Value := QryCli.FieldByName('ADG2_RIFERIMENTOTESTO').AsString;

    if QryCli.FieldByName('ADG2_RIFERIMENTONUMERO').IsNull then
      QryDocumentoADG2_RIFERIMENTONUMERO.Clear
    else
      QryDocumentoADG2_RIFERIMENTONUMERO.Value := QryCli.FieldByName('ADG2_RIFERIMENTONUMERO').AsFloat;

    if QryCli.FieldByName('ADG2_RIFERIMENTODATA').IsNull then
      QryDocumentoADG2_RIFERIMENTODATA.Clear
    else
      QryDocumentoADG2_RIFERIMENTODATA.Value := QryCli.FieldByName('ADG2_RIFERIMENTODATA').AsDateTime;

  finally
    QryCli.Close;
    QryCli.Free;
    if BeforeNewDocForm <> nil then
      BeforeNewDocForm.SetFocus;
  end;
end;

procedure TPreventiviOrdiniForm.QryDocumentoCAUSALEChange(Sender: TField);
var
  Qry: TIB_Cursor;
begin
  // Carica i dati del cliente
  Qry := TIB_Cursor.Create(Self);
  try
    Qry.DatabaseName := DM1.ArcDBFile;
    Qry.IB_Connection := DM1.DBAzienda;
    Qry.SQL.Add('SELECT *');
    Qry.SQL.Add('FROM Causali WHERE Descrizione = ''' + QryDocumentoCAUSALE.AsString + '''');
    Qry.Open;
    // Carica i dati l'indirizzo del cliente come destinazione merci del documento attuale
    if not Qry.Eof then
    begin
      // CArica il flag DaFatturare
      QryDocumentoDAFATTURARE.Value := Qry.FieldByName('DaFatturare').AsString;
      // Se il registro specificato nella causale non è nullo o vuoto lo assegna
      // al documento.
      if (not Qry.FieldByName('REGISTRO').IsNull) and (Trim(Qry.FieldByName('REGISTRO').AsString) <> '') then
        QryDocumentoREGISTRO.Value := Trim(Qry.FieldByName('REGISTRO').AsString);
      // Se la causale è impostata per assegnare automaticamente le azioni di magazzino la assegna
      // NB: Ovviamente deve anche avere specificata una azione sensata)
      // NB: Se specificati nella csusale stessa assegna anche i magazzini
      if (Qry.FieldByName('ASSEGNAAZIONEMAGAZZINO').AsString = 'T') and (Qry.FieldByName('SEGNOOPERAZIONE').AsString <> '') then
      begin
        QryDocumentoSEGNOOPERAZIONE.Value := Qry.FieldByName('SEGNOOPERAZIONE').AsString;
        if Qry.FieldByName('CODICEMAGAZZINO1').AsInteger <> 0 then
          QryDocumentoCODICEMAGAZZINO.Value := Qry.FieldByName('CODICEMAGAZZINO1').AsInteger;
        if Qry.FieldByName('CODICEMAGAZZINO2').AsInteger <> 0 then
          QryDocumentoCODICEMAGAZZINO2.Value := Qry.FieldByName('CODICEMAGAZZINO2').AsInteger;
      end;
      // Se la causale è impostata per assegnare automaticamente le azioni di cantiere la assegna
      // NB: Ovviamente deve anche avere specificata una azione sensata)
      if (Qry.FieldByName('ASSEGNAAZIONECANTIERE').AsString = 'T') and (Qry.FieldByName('SEGNOOPERAZIONECANTIERE').AsString <> '') then
      begin
        QryDocumentoSEGNOOPERAZIONECANTIERE.Value := Qry.FieldByName('SEGNOOPERAZIONECANTIERE').AsString;
      end;
    end;
  finally
    Qry.Close;
    Qry.Free;
    dbeFETipoDocumento.DataField := '';
    dbeFETipoDocumento.DataField := 'FE_TIPODOCUMENTO';
  end;
end;

procedure TPreventiviOrdiniForm.QryDocumentoCODICEDESTMERCIChange(Sender: TField);
var
  QryCli: TIB_Cursor;
begin
  // Carica i dati del cliente
  QryCli := TIB_Cursor.Create(Self);
  try
    QryCli.DatabaseName := DM1.ArcDBFile;
    QryCli.IB_Connection := DM1.DBAzienda;
    QryCli.SQL.Add('SELECT RagioneSociale, Nome, Cognome, TipoPersona, Indirizzo, NumCivico, CAP, Citta, Provincia,');
    QryCli.SQL.Add('RagSocDestinazMerci, IndirizzoDestinazMerci, NumCivicoDestinazMerci, CittaDestinazMerci, CAPDestinazMerci, ProvinciaDestinazMerci');
    QryCli.SQL.Add('FROM Clienti WHERE Codice = ' + QryDocumentoCODICEDESTMERCI.AsString);
    QryCli.Open;
    // Carica i dati l'indirizzo del cliente come destinazione merci del documento attuale
    if not QryCli.Eof then
    begin
      // Se è inserito la destinazione merce diversa nell'anagrafica cliente importa quella, altrimenti importa l'indirizzo
      if QryCli.FieldByName('IndirizzoDestinazMerci').AsString = '' then
      begin
        QryDocumentoRAGSOCDESTMERCI.Value := DM2.GetDenominazioneSoggetto(QryCli);
        QryDocumentoINDIRIZZODESTMERCI.Value := QryCli.FieldByName('Indirizzo').AsString;
        QryDocumentoNUMCIVICODESTMERCI.Value := QryCli.FieldByName('NumCivico').AsString;
        QryDocumentoCAPDESTMERCI.Value := QryCli.FieldByName('CAP').AsString;
        QryDocumentoCITTADESTMERCI.Value := QryCli.FieldByName('Citta').AsString;
        QryDocumentoPROVINCIADESTMERCI.Value := QryCli.FieldByName('Provincia').AsString;
      end
      else
      begin
        QryDocumentoRAGSOCDESTMERCI.Value := QryCli.FieldByName('RagSocDestinazMerci').AsString;
        QryDocumentoINDIRIZZODESTMERCI.Value := QryCli.FieldByName('IndirizzoDestinazMerci').AsString;
        QryDocumentoNUMCIVICODESTMERCI.Value := QryCli.FieldByName('NumCivicoDestinazMerci').AsString;
        QryDocumentoCAPDESTMERCI.Value := QryCli.FieldByName('CAPDestinazMerci').AsString;
        QryDocumentoCITTADESTMERCI.Value := QryCli.FieldByName('CittaDestinazMerci').AsString;
        QryDocumentoPROVINCIADESTMERCI.Value := QryCli.FieldByName('ProvinciaDestinazMerci').AsString;
      end;
    end;
  finally
    QryCli.Close;
    QryCli.Free;
  end;
end;

procedure TPreventiviOrdiniForm.AssegnaPanelTotaliMarginiAlPiedeCorrente;
var
  P: TPanel;
begin
  // INizializzazione
  P := nil;
  // P Punta al pannello dei totali attivoin questo momento
  // NB: Il PanelPiede4 non deve ricevere il pannello dei TotaliMargini
  // perchè è quello della DistintaBase
  if PanelPiede1.Visible then
    P := PanelPiede1
  else if PanelPiede2.Visible then
    P := PanelPiede2
  else if PanelPiede3.Visible then
    P := PanelPiede3;
  // Ovviamente prosegue solamente se c'è un piede attivo
  if P <> nil then
  begin
    // PanelTotaliMargini ora è dentro il pannello attivo
    PanelTotaliMargini.Parent := P;
    // Anche il pannello che fa da finale del castelletto IVA ora è dentro
    // il pannello attivo
    PanelFinalePiede.Parent := P;
    PanelFinalePiede.BringToFront;
  end;
end;

procedure TPreventiviOrdiniForm.CambiaTipoDocumento;
var
  LO: TMemIniFile;
  IsEmptyGrid: Boolean;
  TmpStr: String;
begin
  // Aggiorna la LabelTipoDocumento (Se non è una DIstintaBase)
  if (not DistintaBase) and (not Self.IsImpegno) then
    AggiornaLabelTipoDocumento;
  // In base ai parametri di Layouts.ini carica o imposta alcuni campi
  LO := TMemIniFile.Create(DM1.Repository_Layouts.FullLocalFileName);
  // Se la griglia è vuota lo segnala con questo variabile per risolvere il problema che al cambiamento del tipo documento
  // si posizionava alla colonna più a dx della griglia e quindi scazzava la visualizzazione (solo a griglia vuota)
  IsEmptyGrid := (tvCorpo.DataController.RecordCount = 0);
  // Disabilita l'aggiornamento a video del controllo
  tvCorpo.DataController.BeginUpdate;
  try
    // Carica i titoli di labels e colonne
    CaricaTitoli;
    // Carica il layout del documento attuale
    CaricaLayoutDocumento;
    // FocusRefresh
    DM1.FocusRefresh;
    // In base ai permessi abilita o disabilita i pulsanti modifica/nuovo/elimina
    // NB Abilita il tutto anche se è una Distinta Base)
    // NB Abilita il tutto anche se è un impegno)
    if ((DM1.ControllaDocumento(TipoDoc) > 1) and (Tag <> MODE_KIOSK)) or (QryDocumentoREGISTRO.AsString = 'DIBA') or (Self.IsImpegno) then
    begin
      RxSpeedModifica.Enabled := True;
    end
    else
    begin
      RxSpeedModifica.Enabled := False;
    end;
    // Se si è in modalità di modifica aggiorna alcuni campi...
    if RxSpeedModifica.Down then
    begin
      // Imposta per default il nome esteso del documento = al primo della lista dei nomi del documento stesso
      TmpStr := LO.ReadString(TipoDoc, 'ListaNomiDoc', TipoDoc + ';');
      PreventiviOrdiniForm.QryDocumentoTIPODOCUMENTOESTESO.Value := DM1.RitornaTestoPrimaDi(';', TmpStr, False);
      // Carica le causali di default del documento
      // NB: Non se riceviamo un preventivo (da un fornitore si intende) altrimenti ci ha dato dei problemi
      // rif. utente LD IDROSANITARIA problema "Documento già presente nello stesso anno" perchè
      // loro assegnavano di default al preventivo una causale che modificava il registro.
      // NB: Solo se riceve un documento di acquisto perchè penso che il caso si applichi a tutti i documenti
      // di vendita (anche se di solito non ne riceviamo dal teletrasporto)
      // NB: E solo se NON siamo in modalità MODE_TELETRASPORTO
      if DM1.IsDocumentoDiIngresso(QryDocumentoTIPODOCUMENTO.AsString) and (Tag <> MODE_TELETRASPORTO) then
        PreventiviOrdiniForm.QryDocumentoCAUSALE.Value := LO.ReadString(TipoDoc, 'CausaleDefault', '');
    end;
  finally
    // Riabilita l'aggiornamento a video del controllo
    tvCorpo.DataController.EndUpdate;
    // Elimina LO
    LO.Free;
  end;
end;

procedure TPreventiviOrdiniForm.RxSpeedButtonTrovaClick(Sender: TObject);
var
  TmpStr: String;
begin
  // IN base al controlla atttivo in questo momento, abilita l'opportuna ricerca
  // ---------------------------------------------------------------------------
  // Se siamo sul corpo documento...
  // e se siamo o sui righi principali o sui sottorichi (Non nella CardView)
  if (ActiveControlName = 'GridCorpo') and (GridCorpo.FocusedView is TcxGridTableView) then
  begin
    // Punta alla vista corrente
    with GridCorpo.FocusedView as TcxGridTableView do
    begin
      // Se stiamo editando il CodiceArticolo...
      if (Controller.EditingItem.Index = tvCorpoCODICEARTICOLO.Index) or (Controller.EditingItem.Index = tvCorpoCODICEARTICOLOSTM.Index) then
      begin
        // Apre l'elenco articoli, imposta i filtri inserendo il valore attuale del campo ed esegue automaticamente la ricerca
        TmpStr := Controller.EditingController.Edit.EditingValue;
        DM1.SelezionaArticolo(TmpStr, '', AM_Edit, 0, QryDocumentoPRATICA.AsInteger, QryDocumentoDATAPRATICA1.AsDateTime);
        // Se invece stiamo editando la descrizione di rigo principale...
      end
      else if (Controller.EditingItem.Index = tvCorpoDESCRIZIONE.Index) then
      begin
        // Apre l'elenco articoli, imposta i filtri inserendo il valore attuale del campo ed esegue automaticamente la ricerca
        TmpStr := Controller.EditingController.Edit.EditingValue;
        DM1.SelezionaArticolo('', TmpStr, AM_Edit, 0, QryDocumentoPRATICA.AsInteger, QryDocumentoDATAPRATICA1.AsDateTime);
      end;
    end;

    // CODICE ARTICOLO DA AGGIUNGERE
  end
  else if ActiveControlName = 'AddArt' then
  begin
    // Apre l'elenco articoli, imposta i filtri inserendo il valore attuale del campo ed esegue automaticamente la ricerca
    TmpStr := Trim(AddArt.Text);
    DM1.SelezionaArticolo(TmpStr, '', AM_Edit, 0, QryDocumentoPRATICA.AsInteger, QryDocumentoDATAPRATICA1.AsDateTime);

    // DESCRIZIONE ARTICOLO DA AGGIUNGERE
  end
  else if ActiveControlName = 'TrovaArt' then
  begin
    // Apre l'elenco articoli, imposta i filtri inserendo il valore attuale del campo ed esegue automaticamente la ricerca
    TmpStr := Trim(TrovaArt.Text);
    DM1.SelezionaArticolo('', TmpStr, AM_Edit, 0, QryDocumentoPRATICA.AsInteger, QryDocumentoDATAPRATICA1.AsDateTime);

    // RAGIONE SOCIALE DESTINATARIO
  end
  else if ActiveControlName = 'DBERagSocCli' then
  begin
    DM1.SelezionaCliente(QryDocumentoCODICECLIENTE, QryDocumentoPRATICA, QryDocumentoDATAPRATICA1, DBERagSocCli.Text);

    // RAGIONE SOCIALE DEST MERCI
  end
  else if ActiveControlName = 'DBERagSocDest' then
  begin
    DM1.SelezionaCliente(QryDocumentoCODICEDESTMERCI, QryDocumentoPRATICA, QryDocumentoDATAPRATICA1, DBERagSocDest.Text);

  end;
  // ---------------------------------------------------------------------------
end;

procedure TPreventiviOrdiniForm.QryDocumentoDATADOCUMENTOValidate(Sender: TField);
begin
  // Se è la versione DEMO controlla che la data del documento inserita non sia successiva alla data di scadenza
  // del periodo di prova, nel qual caso visualizza un messaggio e forza la data alla data di fine del periodo stesso.
  // NB: Solo se il documento non è una distinta base
  if D_MODE and not DistintaBase then
  begin
    if (TDateField(Sender).AsDateTime < DM1.DemoFlags.DataPrimoAvvio) or (TDateField(Sender).AsDateTime > DM1.DemoFlags.DataScadenza) then
    begin
      raise Exception.Create('ATTENZIONE!!!' + #13#13'Nella versione dimostrativa di Lev@nte NON E'' POSSIBILE emettere documenti' +
        #13'con data antecedente o successiva al periodo di prova.' + #13#13'Il periodo di prova attuale è dal ' + DateToStr(DM1.DemoFlags.DataPrimoAvvio) +
        ' al ' + DateToStr(DM1.DemoFlags.DataScadenza) + '.');
    end;
  end;
end;

procedure TPreventiviOrdiniForm.QryDocumentoFE_TIPODOCUMENTOGetText(Sender: TField; var Text: string; DisplayText: Boolean);
begin
  if (QryDocumentoTIPODOCUMENTO.AsString = 'Fattura') or (QryDocumentoTIPODOCUMENTO.AsString = 'Nota_accre') then
    Text := Sender.AsString
  else
    Text := '';
  if not Text.IsEmpty then
    Exit;
  if QryDocumentoTIPODOCUMENTO.AsString = 'Fattura' then
    Text := 'TD01'
  else
  if QryDocumentoTIPODOCUMENTO.AsString = 'Nota_accre' then
    Text := 'TD04';
end;

procedure TPreventiviOrdiniForm.QryDocumentoBeforePost(DataSet: TDataSet);
begin
  // Marca il record come modificato
  DataSet.FieldByName('SINCHRO').Value := RECORD_MODIFIED;
end;

procedure TPreventiviOrdiniForm.QryDocumentoPAGAMENTOChange(Sender: TField);
var
  Qry, QryCli: TIB_Cursor;
begin
  // Carica i dati del cliente
  Qry := TIB_Cursor.Create(Self);
  QryCli := TIB_Cursor.Create(Self);
  try
    // IMposta la query che trova il flag di addebito spese o no sull'anagrafica clienti
    QryCli.DatabaseName := DM1.ArcDBFile;
    QryCli.IB_Connection := DM1.DBAzienda;
    QryCli.SQL.Add('SELECT ADDEBITASPESE, SPESEINCASSO FROM CLIENTI WHERE CODICE = ' + QryDocumentoCODICECLIENTE.AsString);
    QryCli.Open;
    // Imposta ed apre la query per i dati della Modalità di Pagamento (se il codicePagamento è valido)
    if (not Sender.IsNull) then
    begin
      Qry.DatabaseName := DM1.ArcDBFile;
      Qry.IB_Connection := DM1.DBAzienda;
      Qry.SQL.Add('SELECT SPESE FROM PAGAM  WHERE CODICE = ' + Sender.AsString);
      Qry.Open;
    end;
    // Se ha trovato il cliente e se l'addebito delle spese è abilitato, addebita le spese della modalità documento...
    // NB: Ho messo anche un flag che abilita o meno l'addeito delle spese documento per documento.
    if (not QryCli.Eof) and (QryCli.FieldByName('ADDEBITASPESE').AsString = 'T') and (QryDocumentoTIPODOCUMENTO.AsString <> 'Ricev.fisc') and CaricaSpeseIncasso
    then
    begin
      // Se è specificato un importo nell'anagrafica del cliente carica quello,
      if QryCli.FieldByName('SPESEINCASSO').AsFloat <> 0 then
        QryDocumentoSPESE.Value := QryCli.FieldByName('SPESEINCASSO').AsFloat
        // altrimenti carica quello specificato nella modalità di pagamento scelta.
        // NB: però solo se il codice del pagamento non è nullo altrimenti darebbe errore
      else if Qry.Active and not Qry.Eof then
        // Carica le spese della modalità di pagamento nel documento
        QryDocumentoSPESE.Value := Qry.FieldByName('SPESE').AsFloat;
      // Se invece non ha trovato il cliente oppure non era abilitato l'addebito...
    end
    else
    begin
      // Spese := 0
      QryDocumentoSPESE.Value := 0;
    end;
    // Se abilitato e necessario ricalcola i totali del documento
    CalcolaTotali(False);
    // Richiama l'OnChange della banca
    QryDocumentoABIChange(nil);
  finally
    Qry.Close;
    Qry.Free;
    QryCli.Close;
    QryCli.Free;
  end;
end;

procedure TPreventiviOrdiniForm.BitBtnMagazzinoClick(Sender: TObject);
begin
  DM1.Attendere;
  try
    // Visualizza la form che permette di selezionare il magazzino da inserire nel documento
    Application.CreateForm(TAnagMagaForm, AnagMagaForm);
    MainForm.SetParentComponent(AnagMagaForm);
    AnagMagaForm.Tag := 998; // Abilita la seleziona dell'aliquota IVA
    AnagMagaForm.Show;
  finally
    DM1.ChiudiAttendere;
  end;
end;

procedure TPreventiviOrdiniForm.BitBtnCausaleClick(Sender: TObject);
begin
  DM1.Attendere;
  try
    // Visualizza la form che permette di selezionare il magazzino da inserire nel documento
    Application.CreateForm(TCausaliForm, CausaliForm);
    MainForm.SetParentComponent(CausaliForm);
    CausaliForm.Tag := 999; // Abilita la selezione
    CausaliForm.Show;
  finally
    DM1.ChiudiAttendere;
  end;
end;

procedure TPreventiviOrdiniForm.BitBtnSelezioneStatoClick(Sender: TObject);
begin
  // Richiama la selezione dello stato del documento
  DM1.SelezionaStato(QryDocumentoTIPODOCUMENTO.Value, QryDocumento, 0);
  DBEditStatoDocumento.Font.Color := DM1.StrToColor(QryDocumentoSTATOFOREGROUND.Value, clBlack);
  DBEditStatoDocumento.Color := DM1.StrToColor(QryDocumentoSTATOBACKGROUND.Value, clSilver);
end;

procedure TPreventiviOrdiniForm.BitBtnSubSoggClick(Sender: TObject);
begin
  Application.CreateForm(TSubSoggForm, SubSoggForm);
  SubSoggForm.Parent := MainForm;
  SubSoggForm.CurrSogg := QryDocumentoCODICECLIENTE.AsInteger;
  SubSoggForm.Tag := 999;
  // Significa che è stata richiamata dall'interno di un documento e quindi abilita la selezione
  SubSoggForm.Show;
end;

procedure TPreventiviOrdiniForm.BitBtnPagamentoClick(Sender: TObject);
begin
  DM1.Attendere;
  try
    // Visualizza la form che permette di selezionare il magazzino da inserire nel documento
    Application.CreateForm(TPagamentiForm, PagamentiForm);
    MainForm.SetParentComponent(PagamentiForm);
    PagamentiForm.Tag := 998; // Abilita la selezione
    PagamentiForm.Show;
  finally
    DM1.ChiudiAttendere;
  end;
end;

procedure TPreventiviOrdiniForm.BitBtnBancaClick(Sender: TObject);
begin
  DM1.Attendere;

  // Visualizza la form che permette di selezionare il magazzino da inserire nel documento
  Application.CreateForm(TArchivioBancheForm, ArchivioBancheForm);
  MainForm.SetParentComponent(ArchivioBancheForm);
  ArchivioBancheForm.Tag := 998; // Abilita la selezione
  ArchivioBancheForm.Show;

  DM1.ChiudiAttendere;
end;

procedure TPreventiviOrdiniForm.BitBtnPratica1Click(Sender: TObject);
begin
  // Se non siamo un documento di aacquisto fa in modo che alla selezione del cantiere
  // se il soggetto del documento non è ancora stato assegnato gli assegna lo stesso soggetto
  // intestatario del cantiere appena scelto.
  if not DM1.IsDocumentoDiIngresso(QryDocumentoTIPODOCUMENTO.AsString) then
  begin
    DM1.SelezionaCantiereImpianto(QryDocumentoPRATICA, QryDocumentoDATAPRATICA1, nil, QryDocumentoCODICECLIENTE, QryDocumentoCODICECLIENTE.Value);
    // Se invece siamo in un documento di acquisto fa in modo che alla selezione del cantiere
    // non venga assegnato in nessun caso nessun soggetto perchè di solito quando si registra un
    // documento di acquisto questo viene intestato al fornitore e non ha senso invece assegnargli
    // il soggetto del cantiere cioè il cliente.
  end
  else
  begin
    DM1.SelezionaCantiereImpianto(QryDocumentoPRATICA, QryDocumentoDATAPRATICA1, nil, nil, QryDocumentoCODICECLIENTE.Value);
  end;
end;

procedure TPreventiviOrdiniForm.BitBtnPratica2Click(Sender: TObject);
begin
  DM1.SelezionaCantiereImpianto(QryDocumentoPRATICA2, QryDocumentoDATAPRATICA2, nil, nil, QryDocumentoCODICECLIENTE.Value);
end;

procedure TPreventiviOrdiniForm.BitBtnPratica3Click(Sender: TObject);
begin
  DM1.SelezionaCantiereImpianto(QryDocumentoPRATICA3, QryDocumentoDATAPRATICA3, nil, nil, QryDocumentoCODICECLIENTE.Value);
end;

procedure TPreventiviOrdiniForm.BitBtnClienteClick(Sender: TObject);
begin
  DM1.SelezionaCliente(QryDocumentoCODICECLIENTE, QryDocumentoPRATICA, QryDocumentoDATAPRATICA1, '');
end;

procedure TPreventiviOrdiniForm.BitBtnEspandiClienteClick(Sender: TObject);
begin
  DM1.VisualizzaCliente(QryDocumentoCODICECLIENTE.Value);
end;

procedure TPreventiviOrdiniForm.BitBtnDestinazioneMerciClick(Sender: TObject);
begin
  DM1.SelezionaCliente(QryDocumentoCODICEDESTMERCI, QryDocumentoPRATICA, QryDocumentoDATAPRATICA1, '');
end;

procedure TPreventiviOrdiniForm.SBKioskConfermaDocClick(Sender: TObject);
begin
  // Controlla che il docuemnto non sia vuoto
  if tvCorpo.DataController.RecordCount > 0 then
  begin
    // Chiede conferma
    if (MainForm.MagKioskMode and (not VendBancoSeleCantForm.VisualizzaDocumento)) or
      (DM1.Messaggi('Emissione Documento', 'Confermi il documento?', '', [mbYes, mbNo], 0, nil) = mrYes) then
    begin
      // Conferma il documento
      RxSpeedModifica.Down := False;
      RxSpeedModificaClick(Self);
      // Stampa il documento
      if (Tag = MODE_KIOSK) and (DM1.CopieDocFisc(TipoDoc) <> 0) then
        RxSpeedButtonStampaClick(Self);
      // Si predispone per un altro documento
      DM1.NuovoDocFisc(DM1.KioskTipoDocDefault, '', 0, 0, '', 4, 0, False, False);
    end;
    // Se invece il documento è vuoto...
  end
  else
  begin
    DM1.Messaggi('Emissione Documento', 'Il documento è vuoto.', 'NB: Non è possibile emettere documenti vuoti.', [mbOk], 0, nil);
  end;
  // Se siamo in una sessione EXPRESS_MAG risistema un pò di cose
  if VendBancoSeleCantForm <> nil then
  begin
    VendBancoSeleCantForm.ResetDocumentoSelezionato;
    VendBancoSeleCantForm.ButtonReloadDataClick(VendBancoSeleCantForm.ButtonReloadData);
  end;
end;

procedure TPreventiviOrdiniForm.RxSpeedButtonEliminaDragOver(Sender, Source: TObject; X, Y: Integer; State: TDragState; var Accept: Boolean);
begin
  Accept := False;
  // Cerca di riconoscere il mittente per accettare o meno l'operazione
  // ------------------------------------------------------------------
  // Se il mittente proviene da una TcxGrid o TcxView...
  // Controlla se il mittente è di tipo TcxDragControlObject che è il tipo di oggetto
  // che le griglie DevExpress passano surante il DragAndDrop.
  if Source is TcxDragControlObject then
  begin
    // Se il mittente è una vista (che è sempre contenuta in un GridSite)...
    if TcxDragControlObject(Source).Control is TcxGridSite then
    begin
      // La vista diventa il controllo predefinito per comodità
      with TcxGridSite(TcxDragControlObject(Source).Control).GridView do
      begin
        // Controlla se la vista è tra quelle da riconoscere
        if (Name = 'tvCorpo') then
          Accept := True;
      end;
    end;
  end;
end;

procedure TPreventiviOrdiniForm.RxSpeedButtonFaxClick(Sender: TObject);
begin
  // In base al parametro che attiva/disattiva l'invio/ricezione automatici delle fatture
  // elettroniche collega uno o l'altra azione al bottone RxSpeedButtonFax
  if (DM1.TableDatiAziendaFE_ENABLED.AsString = 'T') then
  begin
    if CanSendEInvoice then
      acInviaFatturaElettronica.Execute;
  end
  else
    acEsportaFileXML.Execute;
end;

// Mette lo 0 (zero) iniziale se si tratta di un numero con la virgola ma senza
// zero iniziale e inoltre elimina tutti gli spazi presenti.
function TPreventiviOrdiniForm.AggiustaQtaManodopera(Man: String): String;
var
  i: Integer;
begin
  Result := '';
  // Cicla per togliere tutti gli spazi
  for i := 1 to Length(Man) do
  begin
    if Man[i] <> ' ' then
      Result := Result + Man[i];
  end;
  // Se manca lo zero iniziale lo mette
  if LeftStr(Result, 1) = '.' then
    Result := '0' + Result;
end;

// Questa funzione ritorna False se la QtàEvasa + QtaInEvasione > Qta
function TPreventiviOrdiniForm.QtaEvasioneIsValid(Qta, QtaInEvasione, QtaEvasa: Variant): Boolean;
begin
  // Inizializzazione
  Result := False;
  // Defaultizzazione
  if VarIsNull(Qta) then
    Qta := 0;
  if VarIsNull(QtaInEvasione) then
    QtaInEvasione := 0;
  if VarIsNull(QtaEvasa) then
    QtaEvasa := 0;
  // Calcola il valore da ritornare
  Result := ((QtaInEvasione + QtaEvasa) <= Qta);
end;

// Funzione che ritorna True se il rigo è evaso
function TPreventiviOrdiniForm.RigoEvaso(DC: TcxCustomDataController; RI: Integer): Boolean;
var
  Qta, QtaInEvasione, QtaEvasa: Double;
begin
  // Defaultizzazione
  if VarIsNull(DC.Values[RI, tvCorpoQTA.Index]) then
    Qta := 0
  else
    Qta := DC.Values[RI, tvCorpoQTA.Index];
  if VarIsNull(DC.Values[RI, tvCorpoQTAINEVASIONE.Index]) then
    QtaInEvasione := 0
  else
    QtaInEvasione := DC.Values[RI, tvCorpoQTAINEVASIONE.Index];
  if VarIsNull(DC.Values[RI, tvCorpoQTAEVASA.Index]) then
    QtaEvasa := 0
  else
    QtaEvasa := DC.Values[RI, tvCorpoQTAEVASA.Index];
  // Calcola il valore di ritorno
  Result := (QtaInEvasione + QtaEvasa) >= Qta;
end;

procedure TPreventiviOrdiniForm.tvCorpoEditValueChanged(Sender: TcxCustomGridTableView; AItem: TcxCustomGridTableItem);
var
  Row: Integer;
  CodArt, TempValue: String;
  DC: TcxCustomDataController;
  PrecValue: Variant;
begin
  if (Sender is TcxGridTableView) and TcxGridTableView(Sender).Controller.FocusedRow.IsFilterRow then
    Exit;
  // Disabilita l'OnValidate delle Qtà della manodopera
  // NB: Ho dovuto mettere un meccanismo che abilitasse o meno il validate della QTA della manodopera perchè
  // quando nel documento c'erano tante righi che non ci stavano tutti contemporaneamente a video
  // e io modificavo un rigo manodopera che era nelle ultime righe (oltre la capacità della schermata)
  // l'evento OnValidate veniva richiamato due volte (boh!) e questo causava una doppia conversione
  // del valore che scazzava tutto. Siccome l'evento veniva richiamato 2 volte a causa di alcune elaborazioni
  // del dato stesso all'interno dell'evento "OnEditValueChanged" della TableView ho inserito questo flag
  // per disabilitare l'esecuzione del validate all'inizio della gestione "OnEditValueChanged" della TableView
  // per poi ripristinare tutto all'uscita dello stesso gestore di evento.
  DM1.GoValidateQtaOreMinuti := False;
  try
    // Per non so quale motivo, quando entro in editing di un campo (Descrizione) passa 2 o 3 volte di quà
    // e anche quando lo confermo passa altre due o tre volte di quà.
    // Però quando modificavo la descrizione (dopo aver messo il memo) premendo INVIO al secondo passaggio
    // mi dava Access Violation Error e ho visto che AItem era nil. Quindi per risolvere
    // ora controllo AItem e se è = nil esco subito.
    if AItem = nil then
      Exit;
    // Se è stata editata la descrizione esce subito altrimenti da quando ho messo il memo
    // come descrizione si pianta tutto.
    // NB: Ho provato a levare questa riga quando ho fatto la form laterale con i dati del rigo
    // perchè altrimenti non aggiornava correttamente la descrizione della form a sisnistra
    // quando si modificava la descrizione appunto. Sembra che non dia problemi
    // if AItem.Index = tvCorpoDESCRIZIONE.Index then Exit;
    // Questa linea fa in modo che se il DataController ha la proprieta "EditState"
    // di valore dceInsert senza anessun altro flag il programma esce senza fare nulla.
    // Questo è stato necessario perchè se un utente si metteva sull'ultima riga, iniziava a
    // editare il campo e poi premeva il tasto freccia giù, quanto inserito nel campo
    // andava perso e il campo stesso rimaneva vuoto. Ho verificato che in questo caso
    // questo evento veniva lanciato 2 volte, la prima volta in modo corretto, a seconda
    // con valore NULL che azzerava il campo. Così è a posto.
    if Sender.DataController.EditState = [dceInsert] then
      Exit;
    // DC Punta al DataCOntroller della TableView puntata da Sender
    DC := Sender.DataController;
    // Inizializzazione
    Row := DC.FocusedRecordIndex;
    // Blocca il painting della griglia sullo schermo per velocizzare l'esecuzione dei calcoli
    DC.BeginUpdate;
    try
      // Le righe quì sotto servono a risolvere l'errore quando un utente eliminava un precedente
      // valore Qtà, praticamente ho visto che quando l'utente cancellava (BackSpace) la precedente
      // Qtà il valore di 'Sender.Controller.EditingController.Edit.EditValue' che è un variant
      // era una Stringa nulla e quindi il variant diventava di 'varString', allora ho fatto in
      // modo che in questo caso reimposta il valore come 'NUll' e tutto sembra funzionare
      // correttamente.
      if ((AItem.Index = tvCorpoQTA.Index) or (AItem.Index = tvCorpoSCONTORIGO.Index) or (AItem.Index = tvCorpoSCONTORIGO2.Index) or
        (AItem.Index = tvCorpoSCONTORIGO3.Index)) and (Sender.Controller.EditingController.Edit <> nil) and
        (VarType(Sender.Controller.EditingController.Edit.EditValue) = varString) and (Sender.Controller.EditingController.Edit.EditValue = '') then
        Sender.Controller.EditingController.Edit.EditValue := NULL;

      // Le righe qui sotto servono a risolvere l'errore (Invalid variant type conversion) che
      // si verificava quando l'utente inseriva una qtà di manodopera inferiore a 10 min (00:01)
      // nel qual caso, non so perchè, Sender.Controller.EditingController.Edit.EditValue
      // assumeva il valore '1 . ' di tipo stringa e causava l'errore. In questo modo invece
      // non lo da più. Non so esattamente perchè il problema avveniva ma cosi l'ho risolto
      if (AItem.Index = tvCorpoQTA.Index) and (Sender.Controller.EditingController.Edit <> nil) and
        (VarType(Sender.Controller.EditingController.Edit.EditValue) = varString) and (Pos(' .', Sender.Controller.EditingController.Edit.EditValue) <> 0) then
      begin
        Sender.Controller.EditingController.Edit.EditValue := AggiustaQtaManodopera(Sender.Controller.EditingController.Edit.EditValue);
        // TempValue := Sender.Controller.EditingController.Edit.EditValue;
        // Sender.Controller.EditingController.Edit.EditValue := '0' + Trim(TempValue);
      end;

      // Se non si tratta del codice articolo...
      // Forza la scrittura del nuovo valore inserito dall'utente perchè altrimenti
      // le righe successive lavoravano con il valore antecedente la modifica.
      if AItem.Index <> tvCorpoCODICEARTICOLO.Index then
      begin
        // Prima salva il valore precedente del campo
        // NB: Nel caso il valore del campo sia stato variato dal pannella laterale, PrecValue sarà uguale
        // al nuovo valore inserito e quindi potrebbero esserci problemi se un giorno metteremo
        // anche i campi QtaInEvasione e QtaEvasa nel pannello laterale con i dati del rigo. Infatti
        // usano PrecValue per ripristinare in caso di necessità il valore precedente alla modifica
        // e ovviamente in caso di modifica dal pannello laterale questa cosa non sarà possibile.
        // Non mi sembra che PrecValue venga usato in altro modo per cui al momento semplicemente
        // non metterò le colonne QtaInEvasione e QtaEvasa nel pannello laterale.
        PrecValue := DC.Values[Row, AItem.Index];
        if Sender.Controller.EditingController.Edit <> nil then
          DC.Values[Row, AItem.Index] := Sender.Controller.EditingController.Edit.EditValue;
      end;

      // In base alla colonna modificata esegue gli eventuali calcoli per aggiornare ad es. il totale del rigo, i margini ecc.
      if AItem.Index = tvCorpoQTA.Index then
      begin
        // Controlla la giacenza di magazzino dell'articolo e segnala se si va sottoscorta.
        if (not VarIsNull(DC.Values[Row, tvCorpoCODICEARTICOLO.Index])) and (not VarIsNull(DC.Values[Row, tvCorpoQTA.Index])) and
          (not VarIsNull(DC.Values[Row, tvCorpoCODICEMAGAZZINO.Index])) then
        begin
          ControlloSottoscortaArticolo(DC.Values[Row, tvCorpoCODICEARTICOLO.Index], DC.Values[Row, tvCorpoQTA.Index],
            DC.Values[Row, tvCorpoCODICEMAGAZZINO.Index], QryDocumentoSEGNOOPERAZIONE.AsString);
        end;
        // NB: Solo se è un rigo principale (non i sottorighi)
        if not DC.IsDetailMode then
          AggiornaCondVendArticolo(VarToStr(DC.Values[Row, tvCorpoCODICEARTICOLO.Index]), QryDocumentoCODICECLIENTE.AsInteger, TipoDoc, Row);

      end
      else if (AItem.Index = tvCorpoQTAEVASA.Index) or (AItem.Index = tvCorpoQTAINEVASIONE.Index) then
      begin
        if not QtaEvasioneIsValid(DC.Values[Row, tvCorpoQTA.Index], DC.Values[Row, tvCorpoQTAINEVASIONE.Index], DC.Values[Row, tvCorpoQTAEVASA.Index]) then
        begin
          DM1.Messaggi('ATTENZIONE !!!', 'La quantità evasa è superiore alla quantità.'#13#13'MODIFICA ANNULLATA!!!', '', [mbOk], 0, nil);
          DC.Values[Row, AItem.Index] := PrecValue;
          Sender.Controller.EditingController.Edit.EditValue := PrecValue;
        end;

      end
      else if AItem.Index = tvCorpoPREZZOUNITARIO.Index then
      begin
        // Se il prezzo inserito <> null e la Qtà = null mette Qtà = 1 per default
        with DC do
        begin
          if (Values[Row, tvCorpoPREZZOUNITARIO.Index] <> NULL) and (Values[Row, tvCorpoQTA.Index] = NULL) then
            Values[Row, tvCorpoQTA.Index] := 1;
        end;
        // Esegue i calcoli necessari
        CalcolaPerModificaPrezzoUnitario(Row, DC);
        // Se è un rigo di manodopera con dei sottorighi presenti, provvede ad
        // aggiornare i prezzi di vendita anche dei sottorighi perchè il prezzo di vendita
        // dei sottorighi deve sempre essere uguale al prezzo di vendita
        // del rigo principale.
        if (not VarIsNull(DC.Values[Row, tvCorpoCODICEARTICOLO.Index])) and (DM1.CodiceIsManodopera(DC.Values[Row, tvCorpoCODICEARTICOLO.Index])) then
          AggiornaPrzUnitVendSottorighiOpera(DC, Row);

      end
      else if AItem.Index = tvCorpoPREZZOUNITARIOIVACOMPRESA.Index then
      begin
        // Se il prezzo inserito <> null e la Qtà = null mette Qtà = 1 per default
        with DC do
        begin
          if (Values[Row, tvCorpoPREZZOUNITARIOIVACOMPRESA.Index] <> NULL) and (Values[Row, tvCorpoQTA.Index] = NULL) then
            Values[Row, tvCorpoQTA.Index] := 1;
        end;
        CalcolaPerModificaPrezzoUnitarioIVACompresa(Row, DC);
        // Se è un rigo di manodopera con dei sottorighi presenti, provvede ad
        // aggiornare i prezzi di vendita anche dei sottorighi perchè il prezzo di vendita
        // dei sottorighi deve sempre essere uguale al prezzo di vendita
        // del rigo principale.
        if (not VarIsNull(DC.Values[Row, tvCorpoCODICEARTICOLO.Index])) and (DM1.CodiceIsManodopera(DC.Values[Row, tvCorpoCODICEARTICOLO.Index])) then
          AggiornaPrzUnitVendSottorighiOpera(DC, Row);

      end
      else if (AItem.Index = tvCorpoSCONTORIGO.Index) or (AItem.Index = tvCorpoSCONTORIGO2.Index) or (AItem.Index = tvCorpoSCONTORIGO3.Index) then
      begin
        // Se il prezzo inserito <> null e la Qtà = null mette Qtà = 1 per default
        with DC do
        begin
          if ((Values[Row, tvCorpoSCONTORIGO.Index] <> NULL) or (Values[Row, tvCorpoSCONTORIGO2.Index] <> NULL) or
            (Values[Row, tvCorpoSCONTORIGO3.Index] <> NULL)) and (Values[Row, tvCorpoQTA.Index] = NULL) then
            Values[Row, tvCorpoQTA.Index] := 1;
        end;
        // Richiama il ricalcolo di alcuni campi del rigo come conseguenza del cambio di valore del campo
        CalcolaPerModificaPrezzoUnitario(Row, DC);
        // Se è un rigo di manodopera con dei sottorighi presenti, provvede ad
        // aggiornare i prezzi di vendita anche dei sottorighi perchè il prezzo di vendita
        // dei sottorighi deve sempre essere uguale al prezzo di vendita
        // del rigo principale.
        if (not VarIsNull(DC.Values[Row, tvCorpoCODICEARTICOLO.Index])) and (DM1.CodiceIsManodopera(DC.Values[Row, tvCorpoCODICEARTICOLO.Index])) then
          AggiornaPrzUnitVendSottorighiOpera(DC, Row);

      end
      else if AItem.Index = tvCorpoPREZZOACQUISTOARTICOLO.Index then
      begin
        // Se il prezzo inserito <> null e la Qtà = null mette Qtà = 1 per default
        with DC do
        begin
          if (Values[Row, tvCorpoPREZZOACQUISTOARTICOLO.Index] <> NULL) and (Values[Row, tvCorpoQTA.Index] = NULL) then
            Values[Row, tvCorpoQTA.Index] := 1;
        end;
        CalcolaPerModificaPrezzoAcquistoArticolo(Row, DC);
        // Se è un rigo di manodopera con dei sottorighi presenti, provvede ad
        // aggiornare i prezzi di vendita anche dei sottorighi perchè il prezzo di vendita
        // dei sottorighi deve sempre essere uguale al prezzo di vendita
        // del rigo principale.
        if (not VarIsNull(DC.Values[Row, tvCorpoCODICEARTICOLO.Index])) and (DM1.CodiceIsManodopera(DC.Values[Row, tvCorpoCODICEARTICOLO.Index])) then
          AggiornaPrzUnitVendSottorighiOpera(DC, Row);

      end
      else if AItem.Index = tvCorpoMARGINE.Index then
      begin
        // Se il prezzo inserito <> null e la Qtà = null mette Qtà = 1 per default
        with DC do
        begin
          if (Values[Row, tvCorpoMARGINE.Index] <> NULL) and (Values[Row, tvCorpoQTA.Index] = NULL) then
            Values[Row, tvCorpoQTA.Index] := 1;
        end;
        CalcolaPerModificaMargine(Row, DC);
        // Se è un rigo di manodopera con dei sottorighi presenti, provvede ad
        // aggiornare i prezzi di vendita anche dei sottorighi perchè il prezzo di vendita
        // dei sottorighi deve sempre essere uguale al prezzo di vendita
        // del rigo principale.
        if (not VarIsNull(DC.Values[Row, tvCorpoCODICEARTICOLO.Index])) and (DM1.CodiceIsManodopera(DC.Values[Row, tvCorpoCODICEARTICOLO.Index])) then
          AggiornaPrzUnitVendSottorighiOpera(DC, Row);

      end
      else if (AItem.Index = tvCorpoCODICEIVA.Index) or (AItem.Index = tvCorpoDESCRIZIONEIVA.Index) or (AItem.Index = tvCorpoALIQUOTAIVA.Index) then
      begin
        // Esegue il ricalcolo del rigo a seguito della variazione dell'aliquota IVA
        // CalcolaPerModificaPrezzoAcquistoArticolo(Row,DC);
        CalcolaPerModificaPrezzoUnitario(Row, DC);

      end
      else if (AItem.Index = tvCorpoCODICEARTICOLO.Index) and (DM1.TableProgressiviRICERCAARTICOLOSURIGODOC.AsString = 'T') then
      begin
        // Inserisce il nuovo rigo nel documento.
        CodArt := Sender.Controller.EditingController.Edit.EditValue;
        NuovoRigoDocumento(CodArt, '', '', '', QryDocumentoCODICEMAGAZZINO.AsString, AM_Edit);
        // Siccome se era stato richiamato l'articolo con un codice secondario rimaneva il codice
        // secondario stesso scritto nel campo, questo impedive il corretto funzionamento dello
        // carico/scarico di magazzino, allora qui forzo l'inserimento del codice articolo principale
        // per risolvere il tutto.
        // NB: Solo se il valore da ripristinare non è nullo, altrimenti mi cancello il codice inserito dal cliente
        // (potrebbe darsi anche che il cliente voleva inserire un articolo al volo) e inoltre in caso di
        // codice articolo non trovato dava pure un errore perchè cercava di assegnare un Variant nullo)
        if not VarIsNull(DC.Values[Row, tvCorpoCODICEARTICOLO.Index]) then
          Sender.Controller.EditingController.Edit.EditValue := DC.Values[Row, tvCorpoCODICEARTICOLO.Index];
        // Se non è abilitata la gestione dei sottoarticoli di fornitori secondari si assicura che anche l'altra colonna codice
        // sia sempre uguale e quindi la aggiorna.
        if DM1.TableProgressiviDOCGESTARTFORNSECONDARI.AsString <> 'T' then
          DC.Values[Row, tvCorpoCODICEARTICOLOSTM.Index] := DC.Values[Row, tvCorpoCODICEARTICOLO.Index];

      end
      else if (AItem.Index = tvCorpoCODICEARTICOLOSTM.Index) and (DM1.TableProgressiviRICERCAARTICOLOSURIGODOC.AsString = 'T') then
      begin
        // Inserisce il nuovo rigo nel documento.
        CodArt := Sender.Controller.EditingController.Edit.EditValue;
        NuovoRigoDocumento(CodArt, '', '', '', QryDocumentoCODICEMAGAZZINO.AsString, AM_Edit);
        // Siccome se era stato richiamato l'articolo con un codice secondario rimaneva il codice
        // secondario stesso scritto nel campo, questo impedive il corretto funzionamento dello
        // carico/scarico di magazzino, allora qui forzo l'inserimento del codice articolo principale
        // per risolvere il tutto.
        // NB: Solo se il valore da ripristinare non è nullo, altrimenti mi cancello il codice inserito dal cliente
        // (potrebbe darsi anche che il cliente voleva inserire un articolo al volo) e inoltre in caso di
        // codice articolo non trovato dava pure un errore perchè cercava di assegnare un Variant nullo)
        if not VarIsNull(DC.Values[Row, tvCorpoCODICEARTICOLOSTM.Index]) and
          (Uppercase(VarToStr(Sender.Controller.EditingController.Edit.EditValue)) <> Uppercase(VarToStr(DC.Values[Row, tvCorpoCODICEARTICOLOSTM.Index]))) then
          Sender.Controller.EditingController.Edit.EditValue := DC.Values[Row, tvCorpoCODICEARTICOLOSTM.Index];
        // Se non è abilitata la gestione dei sottoarticoli di fornitori secondari si assicura che anche l'altra colonna codice
        // sia sempre uguale e quindi la aggiorna.
        if DM1.TableProgressiviDOCGESTARTFORNSECONDARI.AsString <> 'T' then
          DC.Values[Row, tvCorpoCODICEARTICOLO.Index] := DC.Values[Row, tvCorpoCODICEARTICOLOSTM.Index];
      end;

      // Calcola IMPORTO RIGO
      CalcolaImportoRigo(DC, Row);
      // Se siamo su un sottorigo causa il ricalcolo anche del rigo primcipale
      if DC.IsDetailMode then
        CalcolaTotaliSottorighi(tvCorpo.DataController, DC.GetMasterRecordIndex);
      // Se abilitato e necessario ricalcola i totali del documento
      CalcolaTotali(False);
    finally
      // Riabilita il painting del componente forzando così l'aggiornamento dello schermo
      DC.EndUpdate;
    end;
  finally
    DM1.GoValidateQtaOreMinuti := True;
    // Aggiorna i dati del rigo nella form a destra
    if not fModificandoDaDatiRigoForm then
      AggiornaDatiRigoForm(QryDocumento);
  end;
end;

// Aggiorna il prezzo unitario di vendita dei sottorighi di un rigo di manodopera
// in seguito alla sua variazione sul rigo principale.
procedure TPreventiviOrdiniForm.AggiornaPrzUnitVendSottorighiOpera(MDC: TcxCustomDataController; Row: Integer);
var
  DC: TcxCustomDataController;
  NuovoPrezzoDiVendita, S1, S2, S3: Double;
  Y: Integer;
begin
  // Se è un rigo di manodopera senza sottorighi (in pratica è già un sottorigo di un
  // articolo composto oppure una DIBA).
  // Ovviamente partiamo dal presupposto che se siamo qui è perchè è già certo che
  // si tratta di un rigo di manodopera.
  if not DM1.CheckIfExpandable(MDC, Row, True) then
    Exit;
  // Prima di tutto calcola il nuovo prezzo di vendita al netto degli eventuali sconti.
  NuovoPrezzoDiVendita := DM1.NoNullFloatValue(MDC, Row, tvCorpoPREZZOUNITARIO.Index);
  S1 := DM1.NoNullFloatValue(MDC, Row, tvCorpoSCONTORIGO.Index);
  S2 := DM1.NoNullFloatValue(MDC, Row, tvCorpoSCONTORIGO2.Index);
  S3 := DM1.NoNullFloatValue(MDC, Row, tvCorpoSCONTORIGO3.Index);
  NuovoPrezzoDiVendita := DM1.CalcolaImportoScontato(NuovoPrezzoDiVendita, S1, S2, S3, DM1.DecMicroPrz);
  // DC ora punta al Detail Datacontroller dei sottorighi che conpongono l'articolo composto
  DC := MDC.GetDetailDataController(Row, RELATION_IDX_SOTTORIGHI_ORE);
  // Continua solo se il Detail DataController non è vuoto
  if DC.RecordCount > 0 then
  begin
    // CIcla per tutti i sottorighi e ne aggiorna il prz di vendita
    for Y := 0 to DC.RecordCount - 1 do
    begin
      // Se il sottorigo attuale è una manodopera (non il rigo obbligatorio e quindi esiste almeno un sottorigo valido)
      if DM1.NoNullIntValue(DC, Y, tvOreCODDIPENDENTE.Index) <> -1 then
      begin
        DC.Values[Y, tvOrePRZUNITVEND.Index] := NuovoPrezzoDiVendita;
        CalcolaImportoOrario(DC, Y);
      end;
    end;
  end;
end;

// Controlla se con la qtà digitata l'articolo va sotoscorta ed eventualmente visualizza
// un messaggio per avvisare l'utente
procedure TPreventiviOrdiniForm.ControlloSottoscortaArticolo(CodArt: String; Qt: Double; CM: Integer; SegnoOperazione: String);
var
  Giacenza, Impegnato, Disponibile, Ordinato, PuntoRiordino, ScortaMinima, LottoRiordino: Double;
  Messaggio: String;
begin
  if not DM1.AvvertiSottoscorta then
    Exit;
  // Ovviamente il codice articolo non deve essere vuoto
  if Trim(CodArt) = '' then
    Exit;
  // Solo se è un documento che scarica, altrimenti niente
  if SegnoOperazione <> '-' then
    Exit;
  // Carica in apposite variabili di appoggio i dati del magazzino dell'articolo
  DM1.GetDatiMagazzinoArticolo(CodArt, CM, Giacenza, Impegnato, Ordinato, Disponibile, PuntoRiordino, ScortaMinima, LottoRiordino);
  // Effettua il controllo e imposta il testo del messaggio in base alla situazione.
  // Oppure esce se non c'è da visualizzare nessun messaggio.
  if (Giacenza - Qt) < ScortaMinima then
    Messaggio := 'La giacenza andrà sotto la SCORTA MINIMA !!!'
  else if (Giacenza - Qt) < PuntoRiordino then
    Messaggio := 'La giacenza andrà sotto il PUNTO DI RIORDINO.'
  else
    Exit;
  // Visualizza il messaggio di avvertimento per l'utente
  MessageBeep(MB_ICONEXCLAMATION);
  MessageDlg('A T T E N Z I O  N E !!!'#13#13 + Messaggio + #13#13#13'Situazione attuale:'#13 + #13'-Giacenza   =   ' + FloatToStr(Giacenza) +
    #13'-Impegnato   =   ' + FloatToStr(Impegnato) + #13'-Disponibile   =   ' + FloatToStr(Disponibile) + #13'-Ordinato   =   ' + FloatToStr(Ordinato) +
    #13#13'-Punto di riordino   =   ' + FloatToStr(PuntoRiordino) + #13'-ScortaMinima   =   ' + FloatToStr(ScortaMinima), mtInformation, [mbOk], 0);
end;

// Procedura che controlla rigo per rigo (per tutti i righi) e solo per i documenti
// di ingresso se i prezzi unitari sono guguali ai prezzi di acquisto indicati
// nell'angrafica dei rispettivi articoli e se sono diversi propone di
// aggiornarli automaticamente.
procedure TPreventiviOrdiniForm.ControllaCOrrispondenzaPrezzoDiAcquistoDiTuttiIRighi;
var
  i: Integer;
  DC: TcxCustomDataController;
  CurrQta: Double;
  CurrSconto1, CurrSconto2, CurrSconto3: Double;
  RichiediConfermaAlProseguimento: Boolean;
begin
  // inizializzazione
  RichiediConfermaAlProseguimento := True;

  tvCorpo.BeginUpdate;
  try
    DC := tvCorpo.DataController;
    // Cicla per tutti i righi del documento
    for i := 0 to DC.RecordCount - 1 do
    begin
      // Solo se il rigo corrente contiene un codiuce articolo
      if (not VarIsNull(DC.Values[i, tvCorpoCODICEARTICOLO.Index])) and (Trim(DC.Values[i, tvCorpoCODICEARTICOLO.Index]) <> '') and
        (not VarIsNull(DC.Values[i, tvCorpoPREZZOUNITARIO.Index])) and (DC.Values[i, tvCorpoPREZZOUNITARIO.Index] > 0) then
      begin
        // Carica i valori su alcune variabili facendo anche il controllo della nullità
        if VarIsNull(DC.Values[i, tvCorpoQTA.Index]) then
          CurrQta := 0
        else
          CurrQta := DC.Values[i, tvCorpoQTA.Index];
        if VarIsNull(DC.Values[i, tvCorpoSCONTORIGO.Index]) then
          CurrSconto1 := 0
        else
          CurrSconto1 := DC.Values[i, tvCorpoSCONTORIGO.Index];
        if VarIsNull(DC.Values[i, tvCorpoSCONTORIGO2.Index]) then
          CurrSconto2 := 0
        else
          CurrSconto2 := DC.Values[i, tvCorpoSCONTORIGO2.Index];
        if VarIsNull(DC.Values[i, tvCorpoSCONTORIGO3.Index]) then
          CurrSconto3 := 0
        else
          CurrSconto3 := DC.Values[i, tvCorpoSCONTORIGO3.Index];
        // Effettua il controllo
        if not ControllaCorrispondenzaPrezzoDiAcquisto(DC.DisplayTexts[i, tvCorpoCODICEARTICOLO.Index], DC.DisplayTexts[i, tvCorpoCODICEARTICOLOSTM.Index],
          DC.Values[i, tvCorpoPREZZOUNITARIO.Index], CurrQta, CurrSconto1, CurrSconto2, CurrSconto3, RichiediConfermaAlProseguimento) then
          Exit;
      end;
    end;
  finally
    tvCorpo.EndUpdate;
  end;
end;

// Richiama la procedura che controlla se il prezzo inserito (nei soli documenti di acquisto)
// è diverso dall'ultimo prezo di acquisto impostato nella scheda dell'articolo.
// Eventualmente avvert l'utente e chiede conferma per l'aggiornamento automatico.
function TPreventiviOrdiniForm.ControllaCorrispondenzaPrezzoDiAcquisto(CodArt, CodArtStm: String; NuovoPrezzoListino: Currency; Q, S1, S2, S3: Real;
  var RichiediConfermaPerProseguire: Boolean): Boolean;
var
  Qry: TIB_Cursor;
  NuovoPrezzo: Currency;
  StrVecchioPrz, StrNuovoPrz: String;
  SottoarticoloDiAltroFornitore: Boolean;
  LMsg: String;
begin
  // SOlo se è un documento di acquisto, altrimenti esce subito e non fa nulla
  if not DM1.IsDocumentoDiIngresso(TipoDoc) then
    Exit;

  // Verifica la validità dei paramtri ricevuti
  // NB: Almeno il codice articolo principale deve essere valido altrimenti esce subito.
  if (CodArt = '') then
    Exit;

  // Inizializzazione
  Result := True;
  if CodArtStm = '' then
    CodArtStm := CodArt;
  SottoarticoloDiAltroFornitore := (CodArtStm <> CodArt);

  Qry := TIB_Cursor.Create(nil);
  try
    // ====================================================================================
    // OTTIENE IL PREZZO UNITARIO SCONTATO IN BASE A PREZZO UNITARIO, QTA, SCONTO1,2,3
    // ------------------------------------------------------------------------------------
    // Poi applica gli sconti sul totale rigo
    NuovoPrezzo := DM1.CalcolaImportoScontato(NuovoPrezzoListino, S1, S2, S3, DM1.DecMicroPrz);
    // ====================================================================================
    // INizializzazione oggetto query
    Qry.DatabaseName := DM1.ArcDBFile;
    Qry.IB_Connection := DM1.DBAzienda;
    // IMposta la query che ritornerà il prezzo di acuisto attualmente memorizzato
    // nell'anagrafica dell'articolo.
    Qry.SQL.Add('SELECT COSTOREALE, DESCRIZIONE, PREZZODILISTINO, SCONTODIACQUISTO, SCONTODIACQUISTO2, SCONTODIACQUISTO3 FROM DOC_NUOVO_RIGO_DOCUMENTO(' +
      QuotedStr(CodArt) + ',' + QuotedStr(CodArtStm) + ', ''F'')');
    Qry.Open;
    // Effettua il controllo di corrispondenza dei prezzi
    if (not Qry.Eof) and (NuovoPrezzo <> Qry.Fields[0].AsCurrency) then
    begin
      // Se specificato nel parametro apposito visualizza una richiesta di conferma al proseguimento
      // dell'operazione (da visualizzare solo la prima volta)
      // NB: Se l'utente decide di non proseguire con l'operazione esce subito.
      if RichiediConfermaPerProseguire then
      begin
        Result := (DM1.Messaggi('Controllo prezzi di acquisto',
          'A T T E N Z I O N E !!!'#13#13'Sono presenti alcuni articoli con prezzo diverso'#13'da quanto risulta nell''archivio articoli.'#13#13'Vuoi che li elenco per decidere se aggiornarli?',
          'NB: Se si risponde "NO" le schede anagrafiche degli articoli non verranno aggiornate; cliccando invece su "SI" verranno elencati gli articoli interessati e si potrà decidere singolarmente se aggiornare la relativa scheda oppure no.',
          [mbYes, mbNo], 0, nil) = mrYes);
        RichiediConfermaPerProseguire := False;
        if not Result then
          Exit;
      end;
      // Costruisce la parte di messaggio relativo al prezoz nuovo e vecchio su delle variabili per comodità
      StrVecchioPrz := CurrToStrF(Qry.FieldByName('PREZZODILISTINO').AsDouble, ffCurrency, DM1.DecMicroPrz);
      if (Qry.FieldByName('SCONTODIACQUISTO').AsFloat <> 0) or (Qry.FieldByName('SCONTODIACQUISTO2').AsFloat <> 0) or
        (Qry.FieldByName('SCONTODIACQUISTO3').AsFloat <> 0) then
      begin
        StrVecchioPrz := StrVecchioPrz + ' sconto';
        if (Qry.FieldByName('SCONTODIACQUISTO').AsFloat <> 0) then
          StrVecchioPrz := StrVecchioPrz + ' ' + Qry.FieldByName('SCONTODIACQUISTO').AsString + '%';
        if (Qry.FieldByName('SCONTODIACQUISTO2').AsFloat <> 0) then
          StrVecchioPrz := StrVecchioPrz + ' + ' + Qry.FieldByName('SCONTODIACQUISTO2').AsString + '%';
        if (Qry.FieldByName('SCONTODIACQUISTO3').AsFloat <> 0) then
          StrVecchioPrz := StrVecchioPrz + ' + ' + Qry.FieldByName('SCONTODIACQUISTO3').AsString + '%';
        StrVecchioPrz := StrVecchioPrz + ' = ' + CurrToStrF(Qry.FieldByName('COSTOREALE').AsDouble, ffCurrency, DM1.DecMicroPrz);
      end;
      // Costruisce la parte di messaggio relativo al prezoz nuovo e vecchio su delle variabili per comodità
      StrNuovoPrz := CurrToStrF(NuovoPrezzoListino, ffCurrency, DM1.DecMicroPrz);
      if (Qry.FieldByName('SCONTODIACQUISTO').AsFloat <> 0) or (Qry.FieldByName('SCONTODIACQUISTO2').AsFloat <> 0) or
        (Qry.FieldByName('SCONTODIACQUISTO3').AsFloat <> 0) then
      begin
        StrNuovoPrz := StrNuovoPrz + ' sconto';
        if (S1 <> 0) then
          StrNuovoPrz := StrNuovoPrz + ' ' + CurrToStr(S1) + '%';
        if (S2 <> 0) then
          StrNuovoPrz := StrNuovoPrz + '+' + CurrToStr(S2) + '%';
        if (S3 <> 0) then
          StrNuovoPrz := StrNuovoPrz + '+' + CurrToStr(S3) + '%';
        StrNuovoPrz := StrNuovoPrz + ' = ' + CurrToStrF(NuovoPrezzo, ffCurrency, DM1.DecMicroPrz);
      end;
      // Visualizza un messaggio per l'utente e chiede cosa si vuol fare
      if (not RichiediConfermaAggiornamentoAutomaticoPrezziDiAcquisto) or
        (DM1.Messaggi('Aggiornamento prezzo di acquisto', 'Codice articolo:  ' + CodArt + #13'Descrizione:  ' + Qry.FieldByName('DESCRIZIONE').AsString +
        #13#13#13'IL PREZZO E'' CAMBIATO.'#13#13#13'Vecchio --->  ' + StrVecchioPrz + #13'Nuovo -->  ' + StrNuovoPrz + #13#13#13'Aggiornare la scheda?', '',
        [mbYes, mbNo], 0, nil) = mrYes) then
      begin
        // Se non si tratta di un sottoarticolo di un fornitore secondario...
        // Aggiorna il prezzo della scheda principale dell'articolo
        if not SottoarticoloDiAltroFornitore then
        begin

          // Crea, apre la form dell'anagrafica articolo e modifica i dati e poi li conferma
          Application.CreateForm(TAnagArtForm, AnagArtForm);
          DM1.ShowWait('Aggiornamento prezzo di acquisto', 'Attendere...');
          try
            // La riga sottostante è stata sostituita con la successiva per risolvere l'errore
            // che dava il programma quando girava su Win95/98/ME (Questo programma ha eseguito una operazione non valida...)
            // Il problema lo dava solo quando assegnavo la proprietà Parent della form AnagArtForm.
            // con le altre form andava bene.
            // AnagArtForm.Parent := MainForm;
            MainForm.FormSetParentPlatformDependent(AnagArtForm, MainForm);
            Windows.SetParent(AnagArtForm.Handle, MainForm.Handle);
            AnagArtForm.CodiceArticolo := CodArt;
            AnagArtForm.Tag := 1;
            AnagArtForm.Show;

            AnagArtForm.QryArt.Edit;
            // Impoasta il flag GoValidate dell'anagrafica articoli in modo da non eseguire
            // l'evento OnValidate dalla modifica di ogni campo.
            AnagArtForm.GoValidate := False;
            // Modifica i prezzi di listino e acquisto
            AnagArtForm.QryArtPREZZODILISTINO.Value := NuovoPrezzoListino;
            AnagArtForm.QryArtCOSTOREALE.Value := NuovoPrezzo;
            // Aggiorna gli sconti di acquisto dopo aver già effettuato il ricalcolo dei listini
            // di vendita perchè altrimenti la procedura di calcolo dei listini di vendita in base
            // al prezzo di acquisto trasformi gli sconti in un unico sconto.
            AnagArtForm.QryArtSCONTODIACQUISTO.Value := S1;
            AnagArtForm.QryArtSCONTODIACQUISTO2.Value := S2;
            AnagArtForm.QryArtSCONTODIACQUISTO3.Value := S3;
            // Richiama il gestore di evento che ricalcola i listini di vendita
            AnagArtForm.GoValidate := True;
            AnagArtForm.QryArtCOSTOREALEValidate(AnagArtForm.QryArtCOSTOREALE);
            // Conferma le variazioni
            AnagArtForm.QryArt.Post;
          finally
            DM1.CloseWait;
            // Si assicura che sia rimesso a posto il flag GoValidate
            AnagArtForm.GoValidate := True;
            // Chiude l'anagrafica dell'articolo
            AnagArtForm.Close;
          end;

          // Se inveve si tratta di un sottoarticolo selativo ad un fornitore secondario...
          // Aggiorna il record relativo proprio al sottoarticolo dello specifico fornitore
        end
        else
        begin

          DM1.ShowWait('Aggiornamento prezzo di acquisto', 'Attendere...');
          try
            // Chiude la query
            Qry.Close;
            // IMposta la query per aggiornare il sottoarticolo del fornitore secondario
            Qry.SQL.Clear;
            Qry.SQL.Add('UPDATE LISTFORN LF SET');
            Qry.SQL.Add('  LF.PREZZODILISTINO = :P_PREZZODILISTINO');
            Qry.SQL.Add(' ,LF.SCONTODIACQUISTO1 = :P_SCONTODIACQUISTO1');
            Qry.SQL.Add(' ,LF.SCONTODIACQUISTO2 = :P_SCONTODIACQUISTO2');
            Qry.SQL.Add(' ,LF.SCONTODIACQUISTO3 = :P_SCONTODIACQUISTO3');
            Qry.SQL.Add(' ,LF.PREZZODIACQUISTO = :P_PREZZODIACQUISTO');
            Qry.SQL.Add('WHERE LF.CODICEARTICOLO = :P_CODICEARTICOLO');
            Qry.SQL.Add('  AND LF.CODICEARTICOLOFORNITORE = :P_CODICEARTICOLOFORNITORE');
            // Imposta i parametri
            Qry.Prepare;
            Qry.Params.ParamByName('P_PREZZODILISTINO').AsDouble := NuovoPrezzoListino;
            Qry.Params.ParamByName('P_SCONTODIACQUISTO1').AsDouble := S1;
            Qry.Params.ParamByName('P_SCONTODIACQUISTO2').AsDouble := S2;
            Qry.Params.ParamByName('P_SCONTODIACQUISTO3').AsDouble := S3;
            Qry.Params.ParamByName('P_PREZZODIACQUISTO').AsDouble := NuovoPrezzo;
            Qry.Params.ParamByName('P_CODICEARTICOLO').AsString := CodArt;
            Qry.Params.ParamByName('P_CODICEARTICOLOFORNITORE').AsString := CodArtStm;
            // Esegue la query
            Qry.ExecSQL;
          finally
            DM1.CloseWait;
          end;

        end;
      end;
    end;
  finally
    Qry.Close;
    Qry.Free;
  end;
end;

function TPreventiviOrdiniForm.IsPrzUnitAutocalc(const DC: TcxCustomDataController; const RI: Integer): Boolean;
begin
  Result := DM1.NoNullBoolValue(DC, RI, tvCorpoPREZZOUNITARIOAUTOCALC.Index, False);
end;

function TPreventiviOrdiniForm.IsSplitPayment: Boolean;
begin
  Result := FSplitPayment and (QryDocumentoSPLITPAYMENT.AsString = 'S');
end;

procedure TPreventiviOrdiniForm.ControllaSottoscortaCantiere;
var
  i: Integer;
  DC: TcxCustomDataController;
  QtaResiduoCantiere: Double;
  CurrQta: Double;
  CurrCodiceArticolo, CurrDescrizioneArticolo, Messaggio: String;
  CurrCodiceCantiere: Integer;
  CurrDataCantiere: TDate;
  Qry: TIB_Cursor;
begin
  // Solo se l'azione di cantiere del documento è lo Scarico di cantiere altrimenti esce subito
  if QryDocumentoSEGNOOPERAZIONECANTIERE.AsString <> '-' then
    Exit;
  // Solo se il documento è parte di una pratica/cantiere
  if QryDocumentoPRATICA.IsNull or (QryDocumentoPRATICA.AsInteger = 0) or (QryDocumentoDATAPRATICA1.IsNull) then
    Exit;

  // Inizializzazione
  CurrCodiceCantiere := QryDocumentoPRATICA.AsInteger;
  CurrDataCantiere := QryDocumentoDATAPRATICA1.AsDateTime;

  // Imposta la query che interrogherà il database per ottentere il residuo da montare
  // rispetto alla giacenza
  Qry := TIB_Cursor.Create(nil);
  try
    // INizializzazione oggetto query
    Qry.DatabaseName := DM1.ArcDBFile;
    Qry.IB_Connection := DM1.DBAzienda;
    Qry.SQL.Add('SELECT * FROM GET_DA_MONTARE_ARTICOLO(:P_CODART, :P_CODCANT, :P_DATACANT, :P_TIPODOC, :P_NUMDOC, :P_REGDOC, :P_DATADOC)');
    Qry.Prepare;

    tvCorpo.BeginUpdate;
    DC := tvCorpo.DataController;
    // Cicla per tutti i righi del documento
    for i := 0 to DC.RecordCount - 1 do
    begin
      // Solo se il rigo corrente contiene un codiuce articolo
      if (not VarIsNull(DC.Values[i, tvCorpoCODICEARTICOLO.Index])) and (Trim(DC.Values[i, tvCorpoCODICEARTICOLO.Index]) <> '') and
        (not VarIsNull(DC.Values[i, tvCorpoQTA.Index])) and (DC.Values[i, tvCorpoQTA.Index] <> 0) then
      begin
        // Carica il codice articolo del rigo attuale
        CurrCodiceArticolo := DC.Values[i, tvCorpoCODICEARTICOLO.Index];
        CurrQta := DC.Values[i, tvCorpoQTA.Index];
        if not VarIsNull(DC.Values[i, tvCorpoDESCRIZIONE.Index]) then
          CurrDescrizioneArticolo := DC.Values[i, tvCorpoDESCRIZIONE.Index]
        else
          CurrDescrizioneArticolo := '';
        CurrDescrizioneArticolo := LeftStr(CurrDescrizioneArticolo, 60);
        // Prepara i parametri per la query
        Qry.Params.ParamByName('P_CODART').AsString := CurrCodiceArticolo;
        Qry.Params.ParamByName('P_CODCANT').AsInteger := CurrCodiceCantiere;
        Qry.Params.ParamByName('P_DATACANT').AsDate := CurrDataCantiere;
        Qry.Params.ParamByName('P_TIPODOC').AsString := Self.TipoDoc;
        Qry.Params.ParamByName('P_NUMDOC').AsInteger := Self.NumeroDoc;
        Qry.Params.ParamByName('P_REGDOC').AsString := Self.Registro;
        Qry.Params.ParamByName('P_DATADOC').AsDate := Self.DataDoc;
        // Apre l'interrogazione e memorizza il risultato
        Qry.Open;
        QtaResiduoCantiere := Qry.Fields[0].AsFloat;
        // Se la Qtà che stiamo scaricando è superiore al residuo risultante sul cantiere
        // avvisa l'utente con un messaggio.
        if CurrQta > QtaResiduoCantiere then
        begin
          Messaggio := 'A T T E N Z I O N E !!!'#13#13'Il documento sta scaricando dal cantiere una quantità'#13'superiore al residuo disponibile.';
          Messaggio := Messaggio + #13#13#13'Articolo:  ' + CurrCodiceArticolo + ' - ' + CurrDescrizioneArticolo;
          Messaggio := Messaggio + #13#13'Quantità residua disponibile sul cantiere = ' + FloatToStr(QtaResiduoCantiere);
          Messaggio := Messaggio + #13#13'Quantità scaricata dal documento = ' + FloatToStr(CurrQta);
          DM1.Messaggi('Controllo scarico cantiere/pratica', Messaggio,
            'NB: Annotare il codice articolo sopra riportato e verificare la situazione nel giornale di cantiere', [mbYes], 0, nil);
        end;
        // Chiude la query.
        Qry.Close;
      end;
    end;

  finally
    tvCorpo.EndUpdate;
    Qry.Free;
  end;
end;

// Esegue il calcolo dei totali sottorighi relativi ad un rigo contenente un articolo composto.
procedure TPreventiviOrdiniForm.CalcolaTotaliSottorighiDiBa(MDC: TcxCustomDataController; MasterRow: Integer);
var
  TotQtaOperaUnit, TotOperaUnit, TotCostoOperaUnit: Double;
  TotComponentiUnit, TotCostoComponentiUnit: Double;
  TotMinutiPrevistiUnit: Double;
  Y: Integer;
  DC: TcxCustomDataController;
  TempRowIndex: Integer;
begin
  // inizializzazione
  TempRowIndex := -1;

  // DC ora punta al Detail Datacontroller dei sottorighi che conpongono l'articolo composto
  DC := MDC.GetDetailDataController(MasterRow, RELATION_IDX_SOTTORIGHI_NORMALI);

  // Continua solo se il Detail DataController non è vuoto
  if DC.RecordCount > 0 then
  begin
    // Cicla per tutti i sottorighi del DataController (Prima azzera il totale)
    TotQtaOperaUnit := 0;
    TotOperaUnit := 0;
    TotCostoOperaUnit := 0;
    TotComponentiUnit := 0;
    TotCostoComponentiUnit := 0;
    TotMinutiPrevistiUnit := 0;
    for Y := 0 to DC.RecordCount - 1 do
    begin
      // Se il rigo corrente è il rigo temporaneo e ci sono almeno due righe (quindi c'è almeno un altro
      // rigo effettivo oltre a quello temporaneo) provvede ad eliminarlo
      if DM1.NoNullStringValue(DC, Y, tvCorpoROWTYPE.Index) = TIPORIGODOC_SottorigoTemporaneo then
        TempRowIndex := Y;
      // Se il rigo corrente è un rigo di manodopera aggiorna i totali relativi alla manodopera
      if DM1.CodiceIsManodopera(DM1.NoNullStringValue(DC, Y, tvCorpoCODICEARTICOLO.Index)) then
      begin
        // Aggiorna i totali del rigo principale relativi alla manodopera
        TotQtaOperaUnit := TotQtaOperaUnit + DM1.NoNullFloatValue(DC, Y, tvCorpoQTA.Index);
        TotOperaUnit := TotOperaUnit + DM1.NoNullFloatValue(DC, Y, tvCorpoIMPORTORIGO.Index);
        TotCostoOperaUnit := TotCostoOperaUnit + DM1.Arrotonda(DM1.NoNullFloatValue(DC, Y, tvCorpoPREZZOACQUISTOARTICOLO.Index) * DM1.NoNullFloatValue(DC, Y,
          tvCorpoQTA.Index), DM1.DecMicroPrz);
      end
      // Se invece il rigo corrente è un rigo normale (componenti) allora aggiorna i totali relativi ai componenti
      else
      begin
        TotComponentiUnit := TotComponentiUnit + DM1.NoNullFloatValue(DC, Y, tvCorpoIMPORTORIGO.Index);
        TotCostoComponentiUnit := TotCostoComponentiUnit + DM1.Arrotonda(DM1.NoNullFloatValue(DC, Y, tvCorpoPREZZOACQUISTOARTICOLO.Index) *
          DM1.NoNullFloatValue(DC, Y, tvCorpoQTA.Index), DM1.DecMicroPrz);
        TotMinutiPrevistiUnit := TotMinutiPrevistiUnit + Round(DM1.NoNullFloatValue(DC, Y, tvCorpoMINUTIPREVISTI.Index) * DM1.NoNullFloatValue(DC, Y,
          tvCorpoQTA.Index));
      end;
    end;
    // Aggiorna i totali del rigo principale
    MDC.Values[MasterRow, tvCorpoQTAOPERAUNIT.Index] := TotQtaOperaUnit;
    MDC.Values[MasterRow, tvCorpoOPERAUNIT.Index] := TotOperaUnit;
    MDC.Values[MasterRow, tvCorpoCOSTOOPERAUNIT.Index] := TotCostoOperaUnit;

    // MDC.Values[MasterRow, tvCorpoCOMPONENTIUNIT.Index] := TotComponentiUnit; // NB: Spostato più sotto e dipende se PrzUnit Autocalc...
    MDC.Values[MasterRow, tvCorpoCOSTOCOMPONENTIUNIT.Index] := TotCostoComponentiUnit;

    MDC.Values[MasterRow, tvCorpoMINUTIPREVISTI.Index] := TotMinutiPrevistiUnit;

    MDC.Values[MasterRow, tvCorpoPREZZOACQUISTOARTICOLO.Index] := TotCostoComponentiUnit + TotCostoOperaUnit;
    // IL prezzo unitario solo se è a True il flag del PrezzoUnitario Autocalcolato
    if IsPrzUnitAutocalc(MDC, MasterRow) then
    begin
      MDC.Values[MasterRow, tvCorpoPREZZOUNITARIO.Index] := TotComponentiUnit + TotOperaUnit;
      MDC.Values[MasterRow, tvCorpoCOMPONENTIUNIT.Index] := TotComponentiUnit;
      CalcolaPerModificaPrezzoUnitario(MasterRow, MDC);
    end
    else
    begin
      MDC.Values[MasterRow, tvCorpoCOMPONENTIUNIT.Index] := MDC.Values[MasterRow, tvCorpoPREZZOUNITARIO.Index] - TotOperaUnit;
      CalcolaPerModificaPrezzoAcquistoArticolo(MasterRow, MDC);
    end;

    // Ricalcola i totali del rigo
    CalcolaImportoRigo(MDC, MasterRow);
  end;
  // Se è presente il rigo temporaneo e ci sono anche altri righi normali oltre a lui
  // allora lo elimina
  // NB: La condizione finale (not DC.IsEditing) è stata ggiunta per risolvere
  // l'errore che dava (Index out of range) quando si confermava ad es. descrizione articolo scritta a mano
  // dopo avere aggiundo il primo rigo di un nuovo articolo composto a mano.
  if (TempRowIndex > -1) and (DC.RowCount > 1) and not DC.IsEditing then
    DC.DeleteRecord(TempRowIndex);
end;

// Esegue il calcolo dei totali sottorighi relativi ad un rigo contenente un rigo MANODOPERA
procedure TPreventiviOrdiniForm.CalcolaTotaliSottorighiOre(MDC: TcxCustomDataController; MasterRow: Integer; AggiornaRigoMasterAncheSeVuoto: Boolean = False);
var
  TotQta: Double;
  Y: Integer;
  DC: TcxCustomDataController;
  TempRowIndex: Integer;
begin
  // inizializzazione
  TempRowIndex := -1;
  // DC ora punta al Detail Datacontroller dei sottorighi che conpongono l'articolo composto
  DC := MDC.GetDetailDataController(MasterRow, RELATION_IDX_SOTTORIGHI_ORE);
  // Continua solo se il Detail DataController non è vuoto
  // in questo modo se non ci sono sottorighi (nemmeno il temporaneo) la qtà del rigo
  // principale rimane editabile liberamente, se invece ci sono sottorighi allora no.
  if DC.RecordCount > 0 then
  begin
    // Cicla per tutti i sottorighi del DataController (Prima azzera il totale)
    TotQta := 0;
    for Y := 0 to DC.RecordCount - 1 do
    begin
      // Se il rigo corrente è il rigo temporaneo e ci sono almeno due righe (quindi c'è almeno un altro
      // rigo effettivo oltre a quello temporaneo) provvede ad eliminarlo
      if DM1.NoNullIntValue(DC, Y, tvOreCODDIPENDENTE.Index) = -1 then
        TempRowIndex := Y;
      // Aggiorna i Totali con gli importi del rigo corrente
      TotQta := TotQta + DM1.NoNullFloatValue(DC, Y, tvOreQTA.Index);
    end;
    // Aggiorna i totali del rigo principale
    MDC.Values[MasterRow, tvCorpoQTA.Index] := TotQta;
    // Ricalcola i totali del rigo principale
    CalcolaImportoRigo(MDC, MasterRow);
    // Se è presente il rigo temporaneo e ci sono anche altri righi normali oltre a lui
    // allora lo elimina
    if (TempRowIndex > -1) and (DC.RowCount > 1) then
      DC.DeleteRecord(TempRowIndex);
  end;
end;

procedure TPreventiviOrdiniForm.CalcolaTotaliSottorighi(MDC: TcxCustomDataController; MasterRow: Integer);
begin
  // Se il rigo principale non è espandibile esce subito senza fare nulla
  // anche perchè altrimenti il GetDetailDataController sotto eseguito
  // è una operazione lenta che con documenti particolarmente lunghi
  // causa una lentezza che sembra che il programma sia bloccato.
  // NB: L'ho racchiuso in un try except perchè in alcuni casi e cioè quando
  // importavo le VARIE provenienti dal giornale di cantiere e poi facevo l'esplosione articoli
  // mi dava un ListIndexOutOfBound che invece in questo modo non appare all'utente, cmq
  // i calcoli vengono giusti.
  try
    if not(DM1.CheckIfExpandable(MDC, MasterRow, True)) then
      Exit;
  except
  end;
  // Se si tratta di un rigo relativo alla manodopera richiama il calcolo dei
  // totali dei sottorighi di manodopera.
  if DM1.CodiceIsManodopera(DM1.NoNullStringValue(MDC, MasterRow, tvCorpoCODICEARTICOLO.Index)) then
    CalcolaTotaliSottorighiOre(MDC, MasterRow)
    // Se si tratta di un rigo relativo ad un articolo composto richiama il calcolo dei
    // totali relativi ad un articolo composto.
  else
    CalcolaTotaliSottorighiDiBa(MDC, MasterRow);
end;

procedure TPreventiviOrdiniForm.tvCorpoEditing(Sender: TcxCustomGridTableView; AItem: TcxCustomGridTableItem; var AAllow: Boolean);
var
  RI: Longint;
  DC: TcxCustomDataController;
begin
  // DC Punta al DataController corrente
  DC := Sender.DataController;
  // RI contiene l'indice al record corrente
  RI := DC.FocusedRecordIndex;
  // Fà in modo che le NoteRigo non possano essere modificate se è un rigo di riferimento
  // ------------------------------------------------------------------------------------
  // Se si tratta di un rigo di riferimento ad un documento importato non permette nessuna modifica
  // (NB: Riconosce che si trova su un riferimento di un rigo importato perchè
  // in questo caso il campo 'CodiceIVA' = -9 e la descrizione dell'articolo
  // inizia con '---'
  AAllow := not((DM1.NoNullIntValue(DC, RI, tvCorpoCODICEIVA.Index) = -9) and (DM1.StrLeft(DM1.NoNullStringValue(DC, RI, tvCorpoDESCRIZIONE.Index),
    3) = '---'));

  // Se si tratta di un documento di acquisto le colonne relative al CostoUNitario, al Margine % e al Margine Importo
  // non devono essere editabili, in quanto vengono automaticamente valorizzate alla modifica del prezzo unitario e degli
  // sconti in modo che il costo sia sempre uguale al prezzo unitario eventualmente al netto degli sconti e il margine
  // sempre uguale a zero.
  if (AItem.Index = tvCorpoPREZZOACQUISTOARTICOLO.Index) or (AItem.Index = tvCorpoMARGINE.Index) or (AItem.Index = tvCorpoIMPORTOMARGINE.Index) then
  begin
    AAllow := (not DM1.IsDocumentoDiIngresso(QryDocumentoTIPODOCUMENTO.AsString)) and
      (not DM1.CodiceIsManodopera(DM1.NoNullStringValue(DC, RI, tvCorpoCODICEARTICOLO.Index)));
    if not AAllow then
      DM1.Messaggi('Levante', 'Non è possibile modificare questo dato nei documenti di acquisto o nella manodopera.', '', [mbOk], 0, nil);
  end;

  // Se si sta cercando di modificare il prezzo unitario di vendita
  // lo permette solo se il Flag PREZZOUNITARIOAUTOCALC è False
  if ((AItem.Index = tvCorpoPREZZOUNITARIO.Index) or (AItem.Index = tvCorpoPREZZOUNITARIOIVACOMPRESA.Index) or (AItem.Index = tvCorpoMARGINE.Index)) and
    IsPrzUnitAutocalc(DC, RI) then
    AAllow := False;

  // Se si tratta di un rigo principale  di manodopera e sono presenti anche dei sottorighi validi
  // impedisce la modifica della Qta perchè in questo caso può essere solo calcolata dal programma
  // se invece non ci sono sottorighi validi allora si può specificare a mano
  // NB: Anche per i sottocantieri
  if DM1.CheckIfExpandable(DC, RI, True) and ((AItem.Index = tvCorpoQTA.Index) or (AItem.Index = tvCorpoSOTTOCANTIERE1.Index) or
    (AItem.Index = tvCorpoSOTTOCANTIERE2.Index) or (AItem.Index = tvCorpoSOTTOCANTIERE3.Index)) and
    (DM1.CodiceIsManodopera(DM1.NoNullStringValue(DC, RI, tvCorpoCODICEARTICOLO.Index))) and SottorighiManodoperaPresenti(DC, RI) then
    AAllow := False;

  // Se si tratta di un sottorigo temporaneo ne impedisce la modifica
  if VarToStr(DC.Values[RI, tvCorpoROWTYPE.Index]) = TIPORIGODOC_SottorigoTemporaneo then
    AAllow := False;
end;

procedure TPreventiviOrdiniForm.tvCorpoEndDrag(Sender, Target: TObject; X, Y: Integer);
begin
  // Prima di tutto controlla che il bersaglio non sia nullo
  if Target <> nil then
  begin
    // In base al bersagio attiva la funzione corretta.
    // Se il target è la TListView che contiene i documenti esportati, esporta i documenti
    // selezionati
    if Target is TListView then
    begin
      if (Target as TListView).Name = 'ListViewExpDoc' then
      begin
        MICopiaRighiSelezionatiClick(Self);
      end;
      // Se il Target è uno SpeedButton della toolbar esegue la relativa operazione
    end
    else if Target is TSpeedButton then
    begin
      TSpeedButton(Target).OnClick(Self);
    end;
  end;
end;

procedure TPreventiviOrdiniForm.tvCorpoDragOver(Sender, Source: TObject; X, Y: Integer; State: TDragState; var Accept: Boolean);
var
  HT: TcxCustomGridHitTest;
begin
  Accept := False;
  // Controlla il mittente per accettare o meno l'operazione
  if (Source is TListView) and (RxSpeedModifica.Down) then
  begin
    if (Source as TListView).Name = 'ListViewExpDoc' then
    begin
      Accept := True;
    end;
  end
  else
  begin
    // ===========================================================================
    // GESTIONE DEL DRAG AND DROP INTERNO ALLA GRIGLIA STESSA
    // ---------------------------------------------------------------------------
    with TcxGridSite(Sender) do
    begin
      HT := ViewInfo.GetHitTest(X, Y);
      Accept := (HT is TcxGridRecordCellHitTest)
      // and (TcxGridRecordCellHitTest(HT).GridRecord.RecordIndex <> GridView.DataController.FocusedRecordIndex)
        and RxSpeedModifica.Down;
    end;
    // ===========================================================================
  end;
end;

procedure TPreventiviOrdiniForm.tvCorpoDragDrop(Sender, Source: TObject; X, Y: Integer);
var
  HT: TcxCustomGridHitTest;
  LSourceView, LDestView: TcxGridTableView;
begin
  // In base al tipo del mittente
  if Source is TListView then
  begin
    // Se il mittente è la Bacheca...
    if (Source as TListView).Name = 'ListViewExpDoc' then
    begin
      // Provvede all'importazione
      PreventiviOrdiniForm.MIIncollaRighiSelezionatiClick(Self);
    end;
  end
  else
  begin
    // ===========================================================================
    // GESTIONE DEL DRAG AND DROP INTERNO ALLA GRIGLIA STESSA
    // ---------------------------------------------------------------------------
    LSourceView := ((Source as TcxDragControlObject).Control as TcxGridSite).GridView as TcxGridTableView;
    LDestView := (Sender as TcxGridSite).GridView as TcxGridTableView;
    HT := LDestView.ViewInfo.GetHitTest(X, Y);
    ReorderRows(LSourceView, LDestView, TcxGridRecordCellHitTest(HT).GridRecord);
    // ===========================================================================
  end;
end;

// Procedura che esegue la selezione dell'IVA per il rigo corrente
procedure TPreventiviOrdiniForm.SelectIVAFocusedRow;
begin
  try
    DM1.Attendere;
    // Visualizza la form che permette di selezionare l'aliquota IVA da inserire nel rigo
    Application.CreateForm(TAliquoteIVAForm, AliquoteIVAForm);
    AliquoteIVAForm.Parent := MainForm;
    AliquoteIVAForm.Tag := 999; // Abilita la seleziona dell'aliquota IVA
    AliquoteIVAForm.Show;
  finally
    DM1.ChiudiAttendere;
  end;
end;

procedure TPreventiviOrdiniForm.tvCorpoDblClick(Sender: TObject);
var
  c: Integer;
  Vai: Boolean;
begin
  c := tvCorpo.Controller.FocusedItem.Index;
  // Solo se si è in modalità di modifica
  if RxSpeedModifica.Down then
  begin
    // =======================================================================
    // ALIQUOTA IVA
    // -----------------------------------------------------------------------
    // Se la colonna selezionata è una di quelle che riguarda l'aliquota IVA
    if (c = tvCorpoCODICEIVA.Index) or (c = tvCorpoDESCRIZIONEIVA.Index) or (c = tvCorpoALIQUOTAIVA.Index) then
    begin
      SelectIVAFocusedRow;
      // =======================================================================

      // =======================================================================
      // MAGAZZINO 1
      // -----------------------------------------------------------------------
      // Se la colonna selezionata è una di quelle che riguarda la seleziona del magazzino
    end
    else if (c = tvCorpoCODICEMAGAZZINO.Index) and DM1.SalvaMagazzinoDocumentoDalRigo then
    begin
      Vai := True;
      // Abilita la modifica del magazzino del rigo SOLO se non si è attivata l'aggiunta dei codici chiave ai codici per la sincronizzazione
      // perchè ovviamente in questo caso si rischia che la postazione vada a movimentare magazzini di altri e sarebbe un casino.
      if DM1.AggiungiCodiceChiaveAiCodici then
      begin
        // Se è abilitato il blocco totale del cambio di magazzino per via della sincronizzazione, impedisce la modifica del magazzino del rigo
        // e visualizza un messaggio per spiegare la cosa all'utente
        if DM1.BloccaModificaRecordsAltreStazioni then
        begin
          Vai := False;
          MessageBeep(0);
          MessageDlg('A T T E N Z I O N E !!!'#13#13 + 'Essendoci la funzione di SINCRONIZZAZIONE attivata, NON E'' POSSIBILE'#13 +
            'modificare il magazzino del rigo per evitare POSSIBILI PERDITE DI DATI.'#13#13 +
            'ASSICURARSI CHE TUTTI I RIGHI DEL DOCUMENTO MOVIMENTINO SOLO IL MAGAZZINO ASSEGNATO ALLA POSTAZIONE !!!'#13#13 +
            'Per ulteriori informazioni o istruzioni chiamare il CENTRO SERVIZI.', mtInformation, [mbOk], 0);
          // Se invece njon è completamente disablitato il cambio del magazzino visualizza un messaggio di avvertimento dei pericoli che ci sono
          // ma lascia la scelta se continuare o meno all'utente.
        end
        else
        begin
          MessageBeep(0);
          if MessageDlg('A T T E N Z I O N E !!!'#13#13 + 'Essendoci la funzione di SINCRONIZZAZIONE attivata, esiste il pericolo'#13 +
            'che vengano movimentati altri magazzini oltre a quello assegnato a questa postazione'#13 +
            'causando in questo modo POSSIBILI PERDITE DI DATI.'#13#13 +
            'ASSICURARSI CHE TUTTI I RIGHI DEL DOCUMENTO MOVIMENTINO SOLO IL MAGAZZINO ASSEGNATO ALLA POSTAZIONE !!!'#13#13 +
            'Per ulteriori informazioni o istruzioni chiamare il CENTRO SERVIZI.'#13#13 + 'Si desidera modificare ugualmente il magazzino del rigo?',
            mtInformation, [mbOk, mbNo], 0) = mrOk then
            Vai := True
          else
            Vai := False;
        end;
      end;
      // Se autorizzata dalle righe precedenti avvia la selezione del magazzino da assegnare al rigo
      if Vai then
      begin
        DM1.Attendere;
        try
          // Visualizza la form che permette di selezionare il magazzino da inserire nel rigo
          Application.CreateForm(TAnagMagaForm, AnagMagaForm);
          AnagMagaForm.Parent := MainForm;
          AnagMagaForm.Tag := 999; // Abilita la seleziona dell'aliquota IVA
          AnagMagaForm.Show;
        finally
          DM1.ChiudiAttendere;
        end;
      end;
      // =======================================================================

      // =======================================================================
      // MAGAZZINO 2
      // -----------------------------------------------------------------------
      // Se la colonna selezionata è una di quelle che riguarda la seleziona del magazzino
    end
    else if (c = tvCorpoCODICEMAGAZZINO2.Index) and DM1.SalvaMagazzinoDocumentoDalRigo then
    begin
      Vai := True;
      // Abilita la modifica del magazzino del rigo SOLO se non si è attivata l'aggiunta dei codici chiave ai codici per la sincronizzazione
      // perchè ovviamente in questo caso si rischia che la postazione vada a movimentare magazzini di altri e sarebbe un casino.
      if DM1.AggiungiCodiceChiaveAiCodici then
      begin
        // Se è abilitato il blocco totale del cambio di magazzino per via della sincronizzazione, impedisce la modifica del magazzino del rigo
        // e visualizza un messaggio per spiegare la cosa all'utente
        if DM1.BloccaModificaRecordsAltreStazioni then
        begin
          Vai := False;
          MessageBeep(0);
          MessageDlg('A T T E N Z I O N E !!!'#13#13 + 'Essendoci la funzione di SINCRONIZZAZIONE attivata, NON E'' POSSIBILE'#13 +
            'modificare il magazzino del rigo per evitare POSSIBILI PERDITE DI DATI.'#13#13 +
            'ASSICURARSI CHE TUTTI I RIGHI DEL DOCUMENTO MOVIMENTINO SOLO IL MAGAZZINO ASSEGNATO ALLA POSTAZIONE !!!'#13#13 +
            'Per ulteriori informazioni o istruzioni chiamare il CENTRO SERVIZI.', mtInformation, [mbOk], 0);
          // Se invece njon è completamente disablitato il cambio del magazzino visualizza un messaggio di avvertimento dei pericoli che ci sono
          // ma lascia la scelta se continuare o meno all'utente.
        end
        else
        begin
          MessageBeep(0);
          if MessageDlg('A T T E N Z I O N E !!!'#13#13 + 'Essendoci la funzione di SINCRONIZZAZIONE attivata, esiste il pericolo'#13 +
            'che vengano movimentati altri magazzini oltre a quello assegnato a questa postazione'#13 +
            'causando in questo modo POSSIBILI PERDITE DI DATI.'#13#13 +
            'ASSICURARSI CHE TUTTI I RIGHI DEL DOCUMENTO MOVIMENTINO SOLO IL MAGAZZINO ASSEGNATO ALLA POSTAZIONE !!!'#13#13 +
            'Per ulteriori informazioni o istruzioni chiamare il CENTRO SERVIZI.'#13#13 + 'Si desidera modificare ugualmente il magazzino del rigo?',
            mtInformation, [mbOk, mbNo], 0) = mrOk then
            Vai := True
          else
            Vai := False;
        end;
      end;
      // Se autorizzata dalle righe precedenti avvia la selezione del magazzino da assegnare al rigo
      if Vai then
      begin
        DM1.Attendere;
        try
          // Visualizza la form che permette di selezionare il magazzino da inserire nel rigo
          Application.CreateForm(TAnagMagaForm, AnagMagaForm);
          AnagMagaForm.Parent := MainForm;
          AnagMagaForm.Tag := 994; // Abilita la seleziona dell'aliquota IVA
          AnagMagaForm.Show;
        finally
          DM1.ChiudiAttendere;
        end;
      end;
      // =======================================================================

      // =======================================================================
      // ALTRE COLONNE
      // -----------------------------------------------------------------------
      // Se non è una delle colonne sopra indicate e non è nemmeno una colonna relativa ai sottoncatieri
    end
    else if (c <> tvCorpoSOTTOCANTIERE1.Index) and (c <> tvCorpoSOTTOCANTIERE2.Index) and (c <> tvCorpoSOTTOCANTIERE3.Index) then
    begin
      // Visualizza l'anagrafica dell'articolo
      if RxSpeedButtonVisualizza.Enabled then
        RxSpeedButtonVisualizzaClick(Self);
    end;
    // =======================================================================
  end;
end;

procedure TPreventiviOrdiniForm.tvCorpoKeyPress(Sender: TObject; var Key: Char);
begin
  // Solo se non è in modifica
  if not RxSpeedModifica.Down then
  begin
    // Se viene premuto il INVIO con il focus nella griglia
    // è come se fosse stato fatto doppio click.
    if Key = Chr(13) then
      (Sender as TcxGridSite).GridView.OnDblClick(Self);
  end;
end;

procedure TPreventiviOrdiniForm.tvCorpoLeftPosChanged(Sender: TObject);
var
  i: Integer;
begin
  // Sincronizza le scrollbars orizzontali della MasterView e di tutti i suoi dettagli
  // (solo dettagli di componenti)
  for i := 0 to tvDiBa.CloneCount - 1 do
    (tvDiBa.Clones[i] as TcxGridTableView).Controller.LeftPos := (Sender as TcxGridTableView).Controller.LeftPos;
end;

procedure TPreventiviOrdiniForm.SBAddArtClick(Sender: TObject);
begin
  // Se la view attuale è quella relativa alle ore si rifiuta
  // di aggiungere il rigo altrimenti darebbe errore.
  if GridCorpo.FocusedView.PatternGridView.Name = 'tvOre' then
    raise Exception.Create('Operazione non consentita nei sottorighi di manodopera.');
  // Inserisce il nuovo rigo
  NuovoRigoDocumento(Trim(AddArt.Text), '', '', '', QryDocumentoCODICEMAGAZZINO.AsString, AM_Append);
  // Azzera il dato inserito
  AddArt.Text := '';
end;

procedure TPreventiviOrdiniForm.acCreaRigoCompostoExecute(Sender: TObject);
begin
  // CreaSottorigoTemporaneo(tvCorpo.DataController, tvCorpo.Controller.FocusedRecordIndex);
  CreaSottorigoTemporaneo(tvCorpo.DataController, tvCorpo.DataController.FocusedRecordIndex);
end;

procedure TPreventiviOrdiniForm.acCreaRigoCompostoUpdate(Sender: TObject);
begin
  acCreaRigoComposto.Enabled := RxSpeedModifica.Down;
end;

procedure TPreventiviOrdiniForm.acEsportaFatturaPAUpdate(Sender: TObject);
begin
  (Sender as TAction).Enabled := not RxSpeedModifica.Down;
end;

procedure TPreventiviOrdiniForm.acEsportaFileXMLExecute(Sender: TObject);
var
  AFatturaPA: TFatturaPA;
begin
  // Forza il caricamento dei documenti correlati altrimenti la fattura potrebbe partire senza il codice CIG o altro
  CaricaDocumentiCorrelatiPA;
  DM1.ShowWait('Fattura elettronica', 'Compilo la fattura elettronica...');
  try
    AFatturaPA := TFatturaPA.Create(Self);
    AFatturaPA.CompilaFatturaElettronica;
    DM1.CloseWait;
    if AFatturaPA.SaveToFile then
    begin
      DM1.CloseWait;
      DM1.Messaggi('Levante', 'Fattura esportata', '', [mbOk], 0, nil);
    end;
  finally
    DM1.CloseWait;
    AFatturaPA.Free;
  end;
end;

//procedure TPreventiviOrdiniForm.acInviaFatturaElettronicaExecute(Sender: TObject);
//var
//  AFatturaPA: TFatturaPA;
//begin
//  // Chiede prima conferma
//  if DM1.Messaggi('Levante', 'Preparare la fattura elettronica (XML) per l''invio?',
//    'A T T E N Z I O N E !!!'#13#13'Una volta inviata e accettata dal S.D.I. non sarà più possibile annullare o modificare la fattura.', [mbYes, mbNo], 0, nil)
//    <> mrYes then
//    Exit;
//  // Forza il caricamento dei documenti correlati altrimenti la fattura potrebbe partire senza il codice CIG o altro
//  CaricaDocumentiCorrelatiPA;
//  // Crea la fattura elettronica come da inviare
//  DM1.ShowWait('Fattura elettronica', 'Creo e invio la fattura elettronica...');
//  try
//    AFatturaPA := TFatturaPA.Create(Self);
//    AFatturaPA.CompilaFatturaElettronica;
//    DM1.CloseWait;
//    AFatturaPA.SendToProvider;
//    QryDocumento.Refresh;
//    DM1.Messaggi('Levante', 'Fattura preparata per l''invio'#13#13'NB: La fattura verrà inviata effettivamente con Caronte F.E. in un secondo momento.',
//      'NB: L''invio effettivo verrà effettuato da Caronte F.E. automaticamente o manualmente in base alle impostazioni.'#13#13'Se impostato manualmente fare doppio-click sull''iconcina di Caronte F.E.',
//      [mbOk], 0, nil);
//  finally
//    DM1.CloseWait;
//    AFatturaPA.Free;
//  end;
//end;
procedure TPreventiviOrdiniForm.acInviaFatturaElettronicaExecute(Sender: TObject);
begin
  if DM1.Messaggi('Levante', 'Preparare la fattura elettronica (XML) per l''invio?',
    'A T T E N Z I O N E !!!'#13#13'Una volta inviata e accettata dal S.D.I. non sarà più possibile annullare o modificare la fattura.', [mbYes, mbNo], 0, nil)
    <> mrYes then
    Exit;
  DM1.ShowWait('Fattura elettronica', 'Creo e invio la fattura elettronica...');
  try
    InviaFatturaElettronica;
    DM1.Messaggi('Levante', 'Fattura preparata per l''invio'#13#13'NB: La fattura verrà inviata effettivamente con Caronte F.E. in un secondo momento.',
      'NB: L''invio effettivo verrà effettuato da Caronte F.E. automaticamente o manualmente in base alle impostazioni.'#13#13'Se impostato manualmente fare doppio-click sull''iconcina di Caronte F.E.',
      [mbOk], 0, nil);
  finally
    DM1.CloseWait;
  end;
end;

procedure TPreventiviOrdiniForm.acInviaFatturaElettronicaUpdate(Sender: TObject);
begin
  acInviaFatturaElettronica.Enabled := (not RxSpeedModifica.Down) and (DM1.TableDatiAziendaFE_ENABLED.AsString = 'T') and
    (QryDocumentoFE_STATUS.AsString <> 'rtReadyToSend') and (QryDocumentoFE_STATUS.AsString <> 'rtAcceptedByProvider') and
    (QryDocumentoFE_STATUS.AsString <> 'rtSDIMessageRC') and (QryDocumentoFE_STATUS.AsString <> 'rtSDIMessageMC') and
    (QryDocumentoFE_STATUS.AsString <> 'rtSDIMessageAT') and (QryDocumentoFE_STATUS.AsString <> 'rtSDIMessageNEAccepted') and
    (QryDocumentoFE_STATUS.AsString <> 'rtSDIMessageDT');
end;

procedure TPreventiviOrdiniForm.AddArtChange(Sender: TObject);
begin
  // Abilita il pulsante aggiungi solo se l'utente ha inserito qualcosa nel
  // campo apposito
  SBAddArt.Enabled := (AddArt.Text <> '');
end;

procedure TPreventiviOrdiniForm.tvCorpoCustomDrawColumnHeader(Sender: TcxGridTableView; ACanvas: TcxCanvas; AViewInfo: TcxGridColumnHeaderViewInfo;
  var ADone: Boolean);
begin
  // Richiama la gestione predefinita dell'evento
  DM1.QGridCustomDrawColumnHeader(Sender, ACanvas, AViewInfo, ADone);
end;

procedure TPreventiviOrdiniForm.tvCorpoCustomDrawPartBackground(Sender: TcxCustomGridTableView; ACanvas: TcxCanvas; AViewInfo: TcxCustomGridCellViewInfo;
  var ADone: Boolean);
begin
  inherited;
  // In questo modo scrive il testo sul Group Box in italiano
  DM1.QGridCustomDrawPartBackground((Sender as TcxGridTableView), ACanvas, AViewInfo, ADone);
end;

procedure TPreventiviOrdiniForm.tvCorpoColumnSizeChanged(Sender: TcxGridTableView; AColumn: TcxGridColumn);
begin
  RefreshImpostazioniColonne;
end;

function TPreventiviOrdiniForm.ExpandedRecordCount(TV: TcxGridTableView): Integer;
var
  i: Integer;
begin
  // Questa funzione ritorna il numero dei records espansi della View ricevuta
  // -------------------------------------------------------------------------
  Result := 0;
  for i := 0 to TV.ViewData.RecordCount - 1 do
  begin
    if TV.ViewData.Records[i].Expanded then
      Inc(Result, 1);
  end;
end;

procedure TPreventiviOrdiniForm.tvDiBaKeyDown(Sender: TObject; var Key: Word; Shift: TShiftState);
begin
  // NB: Ho eliminato le righe sotto perchè non permettevano di aggiungere una riga
  // di dettaglio premendo il tasto "freccia giù" sulla tastiera".
  // Così facendo però ora è possibile uscire dalla vista dei sottorighi ma cmq
  // la cosa non mi dispiace più di tanto, anzi.
  // -------------------------------------------------------------------------------
  // // Fà in modo che non si possa uscire dal Dettaglio con la tastiera
  // if ((Key = 38) and ((Sender as TcxGridSite).GridView.DataController.IsBOF)) or
  // ((Key = 40) and ((Sender as TcxGridSite).GridView.DataController.IsEOF))
  // then
  // Key := 0;
  // -------------------------------------------------------------------------------
  // Richiama il gestore dello stesso evento della view principale per il
  // richiamo dell'editor della descrizione dell'articolo
  tvCorpoKeyDown(Sender, Key, Shift);
end;

procedure TPreventiviOrdiniForm.tvCorpoSCONTORIGOCustomDrawCell(Sender: TcxCustomGridTableView; ACanvas: TcxCanvas; AViewInfo: TcxGridTableDataCellViewInfo;
  var ADone: Boolean);
begin
  // Se il RowType finisce con il carattere che indica che i prezzi e gli importi del rigo devono essere
  // visualizzati in grigio o cmq in secondo piano...
  if RightStr(VarToStr(AViewInfo.GridRecord.Values[tvCorpoROWTYPE.Index]), 1) = TIPORIGODOC_CHAR_GRAYED then
  begin
    ACanvas.Font.Color := clGray;
    ACanvas.Font.Style := [fsItalic];
  end;
  // Se il campo = 0 non lo visualizza altrimenti rompe le balle
  if (not VarIsNull(AViewInfo.Value)) and (AViewInfo.Value = 0) and
    not(((AViewInfo.Item.Index = tvCorpoIMPORTORIGO.Index) or (AViewInfo.Item.Index = tvCorpoIMPORTORIGOIVACOMPRESA.Index)) and
    ((AViewInfo.GridRecord.Values[tvCorpoROWTYPE.Index] = TIPORIGODOC_BS_IvaAgevolata) or
    (AViewInfo.GridRecord.Values[tvCorpoROWTYPE.Index] = TIPORIGODOC_BS_IvaOrdinaria) or
    (AViewInfo.GridRecord.Values[tvCorpoROWTYPE.Index] = TIPORIGODOC_BS_AltriCosti))) then
  begin
    // Sfondo
    ACanvas.FillRect(AViewInfo.Bounds);
    ADone := True;
  end;
end;

procedure TPreventiviOrdiniForm.ApplicaVariazioniMargini(MDC: TcxCustomDataController);
var
  DC: TcxCustomDataController;
  Y: Integer;
  TmpMarg: Double;
  ManIndex: Byte;
  CodArt: string;
  procedure NestedApplicaVariazioniMarginiRighiNormali;
  begin
    // Se il tipo di variazione scelta è in % sul margine e se il margine non è zero...
    // NB: La variazione margine è in percentuale sul margine di ogni rigo
    // (es: se il margine rigo attuale è 25% e dedico un aumento del marghine del 10%
    // il nuovo margine sarà del 27,5%).
    if rbMargineVariaz.Checked then
    begin
      if not VarIsNull(MDC.Values[Y, tvCorpoMARGINE.Index]) then
      begin
        TmpMarg := MDC.Values[Y, tvCorpoMARGINE.Index];
        MDC.Values[Y, tvCorpoMARGINE.Index] := DM1.Arrotonda(TmpMarg + (TmpMarg * EditVariazioneMargine.Value / 100), 2);
      end;
    end
    // Se invece il tipo di variazione scelta è in % assoluta allora imposta direttamente il % scelto
    else
      MDC.Values[Y, tvCorpoMARGINE.Index] := EditVariazioneMargine.Value;
    // Esegue i ricalcoli del rigo
    CalcolaPerModificaMargine(Y, MDC);
    CalcolaImportoRigo(MDC, Y);
  end;

begin
  // Cicla per tutte le righe principali...
  for Y := 0 to MDC.RecordCount - 1 do
  begin
    CodArt := VarToStr(MDC.Values[Y, tvCorpoCODICEARTICOLO.Index]);
    // Se è un rigo normale (non espandibile)...
    if not DM1.CheckIfExpandable(MDC, Y, False) then
    begin
      // Se è un rigo di manodopera...
      if DM1.CodiceIsManodopera(CodArt) then
      begin
        // Ricava l'indice del tipo di manodopera a cui il rigo fa riferimento
        ManIndex := DM1.CodiceToIndexManodopera(CodArt);
        // Assegna il prezzo della manodopera appropriata
        case ManIndex of
          0:
            begin
              MDC.Values[Y, tvCorpoPREZZOUNITARIO.Index] := QryDocumentoPRZUNITOPERA.AsCurrency;
              MDC.Values[Y, tvCorpoPREZZOACQUISTOARTICOLO.Index] := QryDocumentoCOSTOUNITOPERA.AsCurrency;
            end;
          1:
            begin
              MDC.Values[Y, tvCorpoPREZZOUNITARIO.Index] := QryDocumentoPRZUNITOPERA1.AsCurrency;
              MDC.Values[Y, tvCorpoPREZZOACQUISTOARTICOLO.Index] := QryDocumentoCOSTOUNITOPERA1.AsCurrency;
            end;
          2:
            begin
              MDC.Values[Y, tvCorpoPREZZOUNITARIO.Index] := QryDocumentoPRZUNITOPERA2.AsCurrency;
              MDC.Values[Y, tvCorpoPREZZOACQUISTOARTICOLO.Index] := QryDocumentoCOSTOUNITOPERA2.AsCurrency;
            end;
          3:
            begin
              MDC.Values[Y, tvCorpoPREZZOUNITARIO.Index] := QryDocumentoPRZUNITOPERA3.AsCurrency;
              MDC.Values[Y, tvCorpoPREZZOACQUISTOARTICOLO.Index] := QryDocumentoCOSTOUNITOPERA3.AsCurrency;
            end;
          4:
            begin
              MDC.Values[Y, tvCorpoPREZZOUNITARIO.Index] := QryDocumentoPRZUNITOPERA4.AsCurrency;
              MDC.Values[Y, tvCorpoPREZZOACQUISTOARTICOLO.Index] := QryDocumentoCOSTOUNITOPERA4.AsCurrency;
            end;
        end;
        CalcolaPerModificaPrezzoUnitario(Y, MDC);
        CalcolaImportoRigo(MDC, Y);
      end
      // Se invece è un rigo normale (non di manodopera)...
      else
        NestedApplicaVariazioniMarginiRighiNormali;
    end
    // Se invece è un rigo composto (ha dei dettagli) provvede a midificarne il margine
    // applicando le variazioni ai suoi sottorighi
    else
    begin
      // Get the detail DataController
      DC := MDC.GetDetailDataController(Y, RELATION_IDX_SOTTORIGHI_NORMALI);
      ApplicaVariazioniMargini(DC);
      // Se rigo (master) corrente e con flag PUA = False allora modifica il margine anche a lui
      // NB: PER IL MOMENTO HO DISATTIVATO LE RIGHE SOTTO PERCHE' APPLICANDO LA VARIAZIONE AL RICARICO
      // ANCHE AI RIGHI MASTER CON IL FLAG PUA NON CHECKATO VENIVA APPLICATO IL MARGINE
      // VOLUTO A TUTTO IL RIGO COMPOSTO (NEL SENSO AL RIGO MASTER) E IN QUESTO MODO E' COME
      // SE SI RICARICASSE ANCHE LA MANODOPERA (COMPRESA NEI SOTTORIGHI) CON LO STESSO
      // RICARICO E QUESTO VA CONTRO AL FATTO CHE SI E' SEMPRE SCELTO DI SEPARARE IL RICARICO
      // DELLA MANODOPERA RISPETTO AL RICARICO DEI MATERIALI
      // if MDC.DisplayTexts[Y, tvCorpoPREZZOUNITARIOAUTOCALC.Index] <> 'True' then
      // NestedApplicaVariazioniMarginiRighiNormali;
    end;
  end;
end;

procedure TPreventiviOrdiniForm.TBVariazioneMarginePropertiesChange(Sender: TObject);
begin
  // Se siamo in modalità di MOdifica fà wditare il valore, altrimenti no
  if RxSpeedModifica.Down then
  begin
    EditVariazioneMargine.Properties.OnEditValueChanged := nil;
    EditVariazioneMargine.Value := TBVariazioneMargine.Position * -1;
    EditVariazioneMargine.Properties.OnEditValueChanged := EditVariazioneMarginePropertiesEditValueChanged;
  end
  else
    TBVariazioneMargine.Position := 0;
end;

procedure TPreventiviOrdiniForm.Anteprimadistampa3Click(Sender: TObject);
begin
  // Richiama la preview di stampa
  StampaDocFisc(TipoDoc, Registro, NumeroDoc, DataDoc, 0, 1, True);
end;

procedure TPreventiviOrdiniForm.Stampa3Click(Sender: TObject);
var
  NumCopie: Integer;
begin
  // Richiama la procedura che si occupa di stampare il documento
  DM1.Attendere;
  // Carica nella variabile NumCOpie il numero delle copie di default e se sono
  // = 0 le fa diventare 1
  NumCopie := DM1.CopieDocFisc(TipoDoc);
  if NumCopie = 0 then
    NumCopie := -1;
  if NumCopie > 0 then
    NumCopie := NumCopie * (-1);
  try
    StampaDocFisc(TipoDoc, Registro, NumeroDoc, DataDoc, 1, NumCopie, True);
  finally
    DM1.ChiudiAttendere;
  end;
end;

procedure TPreventiviOrdiniForm.Esplodiirighiselezionati1Click(Sender: TObject);
var
  i: Integer;
begin
  // Chiede prima conferma all'operatore
  if DM1.Messaggi('Esplosione Articoli Composti', 'Confermi di voler effettuare l''esplosione degli articoli composti selezionati?', '', [mbYes, mbNo], 0, nil)
    = mrYes then
  begin
    DM1.ShowWait('Esplosione Articoli Composti', 'Esplosione articoli selezionati in corso...');
    try
      tvCorpo.DataController.BeginUpdate;
      // Cicla per tutti i righi selezionati
      // NB: Cicla alla rovescia perchè altrimenti darebbe dei problemi perchè sposterebbe i righi selezionati successivi
      // più in basso per via dell'inserimento dei sottorighi esplosi e quindi i riferimenti ai righi selezionati successivi scazzerebbe.
      for i := tvCorpo.Controller.SelectedRecordCount - 1 downto 0 do
      begin
        // Esplode il rigo corrente
        EsplodiArticoloComposto(tvCorpo.DataController, tvCorpo.Controller.SelectedRecords[i].RecordIndex);
      end;
      // Se abilitato e necessario ricalcola i totali del documento
      CalcolaTotali(False);
    finally
      tvCorpo.EndUpdate;
      DM1.CloseWait;
    end;
  end;
end;

procedure TPreventiviOrdiniForm.Esplodituttiirighideldocumento1Click(Sender: TObject);
var
  i: Integer;
begin
  // Chiede prima conferma all'operatore
  if DM1.Messaggi('Esplosione Articoli Composti', 'Confermi di voler effettuare l''esplosione di tutti gli articoli composti del documento?', '', [mbYes, mbNo],
    0, nil) = mrYes then
  begin
    DM1.ShowWait('Esplosione Articoli Composti', 'Esplosione articoli del documento in corso...');
    try
      tvCorpo.DataController.BeginUpdate;
      // Cicla per tutti i righi selezionati
      // NB: Cicla alla rovescia perchè altrimenti darebbe dei problemi perchè sposterebbe i righi selezionati successivi
      // più in basso per via dell'inserimento dei sottorighi esplosi e quindi i riferimenti ai righi selezionati successivi scazzerebbe.
      for i := tvCorpo.DataController.RecordCount - 1 downto 0 do
      begin
        // Esplode il rigo corrente
        EsplodiArticoloComposto(tvCorpo.DataController, i);
      end;
      // Se abilitato e necessario ricalcola i totali del documento
      CalcolaTotali(False);
    finally
      tvCorpo.EndUpdate;
      DM1.CloseWait;
    end;
  end;
end;

procedure TPreventiviOrdiniForm.OpenPanelTotaliMargini(Open: Boolean);
const
  DELAY = 5;
  STEPS1 = 20;
var
  i, Passo: Integer;
  P: TPanel;
begin
  // P punta al TPanel che contiene il PanelTotaliMargini
  P := PanelTotaliMargini.Parent as TPanel;
  // Questa procedura si ocupa di far apparire o scomparire un TPanel ricevuto come parametro alle coordinate specificate
  // con un effetto gradevole di animazione.
  // -------------------------------------------------------------------------------------------------------
  // Calcolo del passo dell'animazione
  Passo := Round((P.Height - SBApriChiudiTotaliMargini1.Height) / STEPS1);
  // Prima di tutto dipende se il TPanel deve aparire o scomparire
  if Open then
  begin
    // *** APERTURA ***
    // Posizionamento iniziale
    PanelTotaliMargini.Top := P.Height;
    PanelTotaliMargini.Visible := True;
    // Cicla per i passi dell'animazione
    for i := 1 to STEPS1 do
    begin
      // Ritardo
      Sleep(DELAY);
      // Aggiorna la posizione del pannello
      PanelTotaliMargini.Top := PanelTotaliMargini.Top - Passo;
      PanelTotaliMargini.Update;
    end;
    // Posizione finale totalmente aperto
    PanelTotaliMargini.Top := 0;
    PanelTotaliMargini.Update;
  end
  else
  begin
    // *** CHIUSURA ***
    // Cicla per i passi dell'animazione
    for i := 1 to STEPS1 do
    begin
      // Ritardo
      Sleep(DELAY);
      // Aggiorna la posizione del pannello
      PanelTotaliMargini.Top := PanelTotaliMargini.Top + Passo;
      P.Update;
    end;
    // Posizione finale chiuso
    PanelTotaliMargini.Visible := False;
    PanelTotaliMargini.Update;
  end;
end;

{
  procedure TPreventiviOrdiniForm.OpenPanelTotaliMargini(Open:Boolean);
  const
  DELAY  = 5;
  STEPS1 = 40;
  var
  i, Passo:Integer;
  P:TPanel;
  begin
  // P Punta al pannello dei totali attivoin questo momento
  if      PanelPiede1.Visible then P := PanelPiede1
  else if PanelPiede2.Visible then P := PanelPiede2
  else if PanelPiede3.Visible then P := PanelPiede3
  else if PanelPiede4.Visible then P := PanelPiede4;
  // PanelTotaliMargini ora è dentro il pannello attivo
  PanelTotaliMargini.Parent := P;
  // Questa procedura si ocupa di far apparire o scomparire un TPanel ricevuto come parametro alle coordinate specificate
  //  con un effetto gradevole di animazione.
  // -------------------------------------------------------------------------------------------------------
  // Prima di tutto dipende se il TPanel deve aparire o scomparire
  if Open then begin

  // *** APERTURA ***
  // Posizionamento iniziale
  PanelTotaliMargini.Top      := 0;
  PanelTotaliMargini.Height   := P.Height;
  PanelTotaliMargini.Left     := 0 - P.Width;
  PanelTotaliMargini.Width    := P.Width;
  PanelTotaliMargini.Visible  := True;
  PanelTotaliMargini.Update;
  // Calcolo del passo dell'animazione
  Passo := Trunc(P.Width / STEPS1);
  // Cicla per i passi dell'animazione
  for i := 1 to STEPS1 do begin
  // Ritardo
  Sleep(DELAY);
  // Aggiorna la posizione del pannello
  PanelTotaliMargini.Left := PanelTotaliMargini.Left + Passo;
  PanelTotaliMargini.Update;
  end;
  // Posizione finale totalmente aperto
  PanelTotaliMargini.Left := 0;
  PanelTotaliMargini.Update;

  end else begin

  // *** CHIUSURA ***
  // Calcolo del passo dell'animazione
  Passo := Trunc(P.Width / STEPS1);
  // Cicla per i passi dell'animazione
  for i := 1 to STEPS1 do begin
  // Ritardo
  Sleep(DELAY);
  // Aggiorna la posizione del pannello
  PanelTotaliMargini.Left := PanelTotaliMargini.Left - Passo;
  P.Update;
  end;
  // Posizione finale totalmente aperto
  PanelTotaliMargini.Visible := False;
  PanelTotaliMargini.Update;

  end;
  end;
}

procedure TPreventiviOrdiniForm.SBApriChiudiTotaliMargini1Click(Sender: TObject);
begin
  // Apre o chiude il pannello
  OpenPanelTotaliMargini(not PanelTotaliMargini.Visible);
end;

procedure TPreventiviOrdiniForm.tvCorpoMARGINECustomDrawFooterCell(Sender: TcxGridTableView; ACanvas: TcxCanvas; AViewInfo: TcxGridColumnHeaderViewInfo;
  var ADone: Boolean);
begin
  // Se il valore è maggiore a zero lo visualizza in rosso (variazione del costo in aumento)
  if (LeftStr(AViewInfo.Text, 1) = '-') then
    ACanvas.Font.Color := clRed
  else
    ACanvas.Font.Color := clBlack;
end;

procedure TPreventiviOrdiniForm.tvCorpoMouseDown(Sender: TObject; Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
begin
// ===========================================================
// NB: Questa era la modifica fatta per Marica della Deltacom
// (insieme alla proprietà DramMode := dmManual invece che dbAuto...)
// La modifica funzionava per il problema segnalato da Marica, il suo
// era un problema che si verificava in circostanze molto articolari
// ma poi questa soluzione causava un effeto collatrale che rendeva difficile
// selezionare più righe da un documento per portarle in bacheca e siccome
// questa è una funzionalità molto usata abbiamo deciso di rimettere
// il tutto come prima.
// -----------------------------------------------------------
//  if Button = mbLeft then
//  begin
//    with TcxGridSite(Sender) do
//    begin
//      if ViewInfo.GetHitTest(X, Y).HitTestCode = htCell then
//        BeginDrag(False, 10);
//    end;
//  end;
// ===========================================================
end;

procedure TPreventiviOrdiniForm.tvCorpoMOVMAGCustomDrawCell(Sender: TcxCustomGridTableView; ACanvas: TcxCanvas; AViewInfo: TcxGridTableDataCellViewInfo;
  var ADone: Boolean);
var
  XX, yy, IconTopPosition, IconIndex: Integer;
  B: TBitmap;
  T: String;
begin
  ADone := True;
  // Sfondo
  // ACanvas.Brush.Color := clWhite;
  ACanvas.FillRect(AViewInfo.Bounds);
  // INizializzazione delle variabili per le coordinate
  XX := AViewInfo.Bounds.Left + DS_LEFT_MARGIN;
  yy := AViewInfo.Bounds.Top + DS_TOP_MARGIN + 10;

  // IconTopPosition := (AViewInfo.Bounds.Bottom - AViewInfo.Bounds.Top - DM1.ImgListStatiDoc.Height) div 2;
  // YY := AViewInfo.Bounds.Top + IconTopPosition;

  // T contiene il valore del campo SELEZIONATO per poi controllare lo stato di Importazione/Esportazione
  T := AViewInfo.GridRecord.DisplayTexts[tvCorpoSELEZIONATO.Index];
  // Se T non è nulla la adegua
  if T = '' then
    T := ' ';

  // ==========================================================================
  // VISUALIZZAZIONE ICONA IMPORTATO/ESPORTATO
  // --------------------------------------------------------------------------
  // Ottiene l'indice dell' icona da visualizzare in base allo stato
  IconIndex := 0;
  if (T = FLAG_VALUE_IMPORTED) then
    IconIndex := IDX_DS_IMPORT
  else if (T = FLAG_VALUE_EXPORTED) then
    IconIndex := IDX_DS_EXPORT
  else if (T = FLAG_VALUE_IMPORTED_EXPORTED) then
    IconIndex := IDX_DS_IMPORT_EXPORT;
  // Se l'indice ottenuto è valido visualizza l'icona relativa
  if IconIndex > 0 then
  begin
    B := TBitmap.Create;
    DM1.ImgListStatiDoc.GetBitmap(IconIndex, B);
    ACanvas.Draw(XX, yy, B);
    B.Free;
  end;
  // Aggiorna la variabile per il posizionamento orizzontale della prossima icona
  Inc(XX, DS_ICON_WIDTH + DS_ICON_SEPARATION);
  // ==========================================================================

  // ==========================================================================
  // VISUALIZZAZIONE ICONA DELLA MOVIMENTAZIONE DI MAGAZZINO
  // --------------------------------------------------------------------------
  // Ottiene l'indice dell' icona da visualizzare in base allo stato
  IconIndex := Pos(AViewInfo.Text, '=-IO+');
  // Se l'indice ottenuto è valido visualizza l'icona relativa
  if IconIndex > 0 then
  begin
    B := TBitmap.Create;
    DM1.ImgListStatiDoc.GetBitmap(IconIndex - 1, B);
    ACanvas.Draw(XX, yy, B);
    B.Free;
  end;
  // Aggiorna la variabile per il posizionamento orizzontale della prossima icona
  Inc(XX, DS_ICON_WIDTH + DS_ICON_SEPARATION);
  // ==========================================================================
end;

procedure TPreventiviOrdiniForm.AddArtKeyPress(Sender: TObject; var Key: Char);
begin
  // Se non si è in modalità di modifica annulla qualunque inserimento
  if (not RxSpeedModifica.Down) or SolaLettura then
  begin
    Key := Chr(0);
  end;
end;

procedure TPreventiviOrdiniForm.AddArtKeyUp(Sender: TObject; var Key: Word; Shift: TShiftState);
begin
  // Se non si è in modalità di modifica annulla qualunque inserimento
  if RxSpeedModifica.Down then
  begin
    // Se viene premuto il pulsante INVIO preme il pulsante aggiungi
    if Key = 13 then
    begin
      SBAddArtClick(Self);
    end;
  end;
end;

procedure TPreventiviOrdiniForm.QryDocumentoCODICEIVAFORZATAChange(Sender: TField);
var
  Qry: TIB_Cursor;
begin
  if QryDocumentoCODICEIVAFORZATA.IsNull then
    Exit;
  // Crea la query per prelevare i valori della tabella delle aliquote IVA
  Qry := TIB_Cursor.Create(Self);
  try
    Qry.DatabaseName := DM1.ArcDBFile;
    Qry.IB_Connection := DM1.DBAzienda;
    Qry.SQL.Add('SELECT CODICEIVA, DESCRIZIONEIVA, ALIQUOTAIVA FROM ALIQIVA WHERE CODICEIVA = ' + QryDocumentoCODICEIVAFORZATA.AsString);
    Qry.Open;
    if Qry.Eof then
      raise Exception.Create('Aliquota IVA non trovata!');
    QryDocumentoDESCRIZIONEIVAFORZATA.Value := Qry.FieldByName('DESCRIZIONEIVA').AsString;
    QryDocumentoALIQUOTAIVAFORZATA.Value := Qry.FieldByName('ALIQUOTAIVA').AsFloat;
    // Aggiorna l'aliquota iva di default del documento stesso
    CaricaAliquotaIVADefaultDocumento;
  finally
    Qry.Free;
  end;
end;

procedure TPreventiviOrdiniForm.BitBtnForzaIvaClick(Sender: TObject);
begin
  try
    DM1.Attendere;
    // Visualizza la form che permette di selezionare l'aliquota IVA da inserire come
    // aliqouta IVA forzata del documento
    Application.CreateForm(TAliquoteIVAForm, AliquoteIVAForm);
    MainForm.SetParentComponent(AliquoteIVAForm);
    AliquoteIVAForm.Tag := 998; // Abilita la seleziona dell'aliquota IVA
    AliquoteIVAForm.Show;
  finally
    DM1.ChiudiAttendere;
  end;
end;

// Apre il pannello dei dati dell'intestatario del documento
procedure TPreventiviOrdiniForm.ApriPannelloIntestatario(P: TPanel);
const
  SPEED = 1;
begin
  // Se risulta già aperto esce subito
  if P.Height = INTESTATARIO_OPEN then
    Exit;
  // Effettua l'apertura del pannello
  P.BorderStyle := bsSingle;
  while P.Height < INTESTATARIO_OPEN do
  begin
    P.Height := P.Height + 1;
    P.Update;
    // Sleep(SPEED);
  end;
end;

// Apre il pannello dei dati dell'intestatario del documento
procedure TPreventiviOrdiniForm.ChiudiPannelloIntestatario(P: TPanel);
const
  SPEED = 1;
begin
  // Se risulta già aperto esce subito
  if P.Height = INTESTATARIO_CLOSE then
    Exit;
  // Effettua l'apertura del pannello
  while P.Height > INTESTATARIO_CLOSE do
  begin
    P.Height := P.Height - 1;
    P.Update;
    // Sleep(SPEED);
  end;
  P.BorderStyle := bsNone;
end;

procedure TPreventiviOrdiniForm.Editordescrizione1Click(Sender: TObject);
var
  RI: Longint;
  DC: TcxCustomDataController;
  LeftDesc: Integer;
  i: Integer;
begin
  if not(GridCorpo.FocusedView is TcxCustomGridView) then
    Exit;

  // --------------------------------------------------------------------------
  // Se è abilitato l'editor dei viaggi per le aziende di trasporto
  // visualizza quello altrimenti l'editor standard della descrione
  // del rigo.
  if DM1.ViaggioEditorEnabled then
  begin
    VisualizzaEditorViaggio;
    Exit;
  end;
  // --------------------------------------------------------------------------

  // DC punta al Datacontroller della TableView
  DC := GridCorpo.FocusedView.DataController;
  // RI contiene l'indice al record corrente
  RI := DC.FocusedRecordIndex;
  // Se si tratta du un rigo di riferimento ad un documento importato non permette nessuna modifica
  // (NB: Riconosce che si trova su un riferimento di un rigo importato perchè
  // in questo caso il campo 'CodiceIVA' = -9 e la descrizione dell'articolo
  // inizia con '--->'
  if ((DM1.NoNullIntValue(DC, RI, tvCorpoCODICEIVA.Index) = -9) and (DM1.StrLeft(DM1.NoNullStringValue(DC, RI, tvCorpoDESCRIZIONE.Index), 4) = '--->')) then
  begin
    DM1.Messaggi('Levante', 'Non è possibile modificare un rigo di riferimento ad altro documento.', '', [mbOk], 0, nil);
    Exit;
  end;
  // Richiama l'editor della descrizione lunga degli articoli
  LeftDesc := GridCorpo.Left + 15;
  for i := 0 to tvCorpo.ColumnCount - 1 do
  begin
    if tvCorpo.Columns[i].Name = 'tvCorpoDESCRIZIONE' then
    begin
      break;
    end
    else
    begin
      if tvCorpo.Columns[i].Visible then
        Inc(LeftDesc, tvCorpo.Columns[i].Width);
    end;
  end;
  // POsiziona e dimensiona l'editor
  PanelDescrizione.Left := LeftDesc;
  PanelDescrizione.Width := tvCorpoDESCRIZIONE.Width + 1;
  PanelDescrizione.Top := GridCorpo.Top + 18;
  PanelDescrizione.Height := 0;
  MemoDescrizione.Lines.Clear;
  PanelDescrizione.Visible := True;
  // Posiziona il focus sull'editor
  MemoDescrizione.SetFocus;
  // Animazione di apertura
  while PanelDescrizione.Height < GridCorpo.Height - 36 do
  begin
    PanelDescrizione.Height := PanelDescrizione.Height + 20;
    PanelDescrizione.Update;
    Sleep(5);
  end;
  PanelDescrizione.Height := GridCorpo.Height - 36;
  PanelDescrizione.Update;
  // Caricamento dati
  // NB: Siccome c'erano problemi al richiamo dell'editor delle descrizione lunghe
  // quando si stava inserendo una nuova riga (riga non ancora postata), dava
  // errore oppure la eliminava.
  // Adesso nell'if quì sotto verifico se si tratta di una nuova Row e in questo caso
  // faccio l'append di un rigo (in sostituzione di quello che sconpare quando sposto il focus
  // sul MemoDescrizione) e metto il suo Indice nella proprietà Tag del MemoDescrizione; Quando
  // l'utente conferma il tutto verifica se la proprietà Tag <> -1 e da li capisce che deve
  // salvare il testo digitato nel record puntato.
  // Se invece Tag = -1 significa che non si trattava di un nuovo record e quindi salva il testo digitato
  // sul FocuseRecord della TableView normalmente.
  if DC.RecordCount < (RI + 1) then
  begin
    RI := DC.AppendRecord;
    MemoDescrizione.Tag := RI;
  end
  else
  begin
    MemoDescrizione.Tag := -1;
    MemoDescrizione.Lines.Add(DM1.NoNullStringValue(DC, RI, tvCorpoDESCRIZIONE.Index));
  end;
  // Disabilita il pulsante F2 Modifica
  RxSpeedModifica.Enabled := False;
  RxSpeedButtonHelp.Enabled := False;
  RxSpeedButtonNuovo.Enabled := False;
  RxSpeedButtonElimina.Enabled := False;
  RxSpeedButtonVisualizza.Enabled := False;
end;

procedure TPreventiviOrdiniForm.EditVariazioneMarginePropertiesEditValueChanged(Sender: TObject);
begin
  TBVariazioneMargine.Properties.OnChange := nil;
  TBVariazioneMargine.Position := Round(EditVariazioneMargine.Value * -1);
  TBVariazioneMargine.Properties.OnChange := TBVariazioneMarginePropertiesChange;
end;

procedure TPreventiviOrdiniForm.BtnDescrizioneCancelClick(Sender: TObject);
begin
  // Riabilita il pulsante F2 Modifica
  RxSpeedModifica.Enabled := True;
  RxSpeedButtonHelp.Enabled := True;
  RxSpeedButtonNuovo.Enabled := True;
  RxSpeedButtonElimina.Enabled := True;
  RxSpeedButtonVisualizza.Enabled := True;
  // Animazione di chiusura editor
  while PanelDescrizione.Height > 0 do
  begin
    PanelDescrizione.Height := PanelDescrizione.Height - 20;
    PanelDescrizione.Update;
    GridCorpo.Update;
    Sleep(5);
  end;
  // Chiude l'editor della descrizione articolo
  PanelDescrizione.Visible := False;
  GridCorpo.SetFocus;
end;

procedure TPreventiviOrdiniForm.BtnDescrizioneOkClick(Sender: TObject);
var
  RI: Longint;
  DC: TcxCustomDataController;
begin
  if not(GridCorpo.FocusedView is TcxCustomGridView) then
    Exit;
  // DC punta al Datacontroller della TableView
  DC := GridCorpo.FocusedView.DataController;

  // RI contiene l'indice al record corrente
  // NB: Siccome c'erano problemi al richiamo dell'editor delle descrizione lunghe
  // quando si stava inserendo una nuova riga (riga non ancora postata), dava
  // errore oppure la eliminava.
  // Adesso nell'if quì sotto verifico se si tratta di una nuova Row e in questo caso
  // faccio l'append di un rigo (in sostituzione di quello che sconpare quando sposto il focus
  // sul MemoDescrizione) e metto il suo Indice nella proprietà Tag del MemoDescrizione; Quando
  // l'utente conferma il tutto verifica se la proprietà Tag <> -1 e da li capisce che deve
  // salvare il testo digitato nel record puntato.
  // Se invece Tag = -1 significa che non si trattava di un nuovo record e quindi salva il testo digitato
  // sul FocuseRecord della TableView normalmente.
  if MemoDescrizione.Tag = -1 then
  begin
    RI := DC.FocusedRecordIndex;
  end
  else
  begin
    RI := MemoDescrizione.Tag;
  end;

  // Copia il testo inserito nel memo dentro la cella descrizione.
  DC.Values[RI, tvCorpoDESCRIZIONE.Index] := MemoDescrizione.Lines.Text;
  // Chiude l'editor.
  BtnDescrizioneCancelClick(Sender);
end;

procedure TPreventiviOrdiniForm.tvCorpoKeyDown(Sender: TObject; var Key: Word; Shift: TShiftState);
begin
  // Se l'utente preme Alt+E mentre è attivo il corpo documento richiama l'editor.
  if (ssAlt in Shift) and (Key = 69) and RxSpeedModifica.Down then
  begin
    // Se è abilitato l'editor dei viaggi per le aziende di trasporto
    // visualizza quello altrimenti l'editor standard della descrione
    // del rigo.
    Editordescrizione1Click(Editordescrizione1);
  end;
end;

procedure TPreventiviOrdiniForm.PanelDescrizioneExit(Sender: TObject);
begin
  // Fà in modo che non si possa uscire dall'editor
  if PanelDescrizione.Visible then
  begin
    MemoDescrizione.SetFocus;
  end;
end;

procedure TPreventiviOrdiniForm.AzzeraAliquotaIVA1Click(Sender: TObject);
begin
  if not RxSpeedModifica.Down then
    DM1.Messaggi('Levante', 'Devi essere in modalità di modifica', '', [mbOk], 0, nil);
  if DM1.Messaggi('Azzera aliquota IVA', 'Confermi di voler azzerare l''aliquota IVA?', '', [mbYes, mbNo], 0, nil) = mrYes then
  begin
    QryDocumentoCODICEIVAFORZATA.Clear;
    QryDocumentoDESCRIZIONEIVAFORZATA.Clear;
    QryDocumentoALIQUOTAIVAFORZATA.Clear;
    dbeListino.SetFocus;
    DBEFOrzaIVA.SetFocus;
  end;
end;

procedure TPreventiviOrdiniForm.Azzeragliscontideirighiselezionati1Click(Sender: TObject);
var
  i: Integer;
  MDC: TcxCustomDataController;
  Row: Integer;
begin
  // Chiede prima conferma all'operatore
  if DM1.Messaggi('Azzeramento sconti', 'Confermi di voler azzerare gli sconti dei righi selezionati?', '', [mbYes, mbNo], 0, nil) = mrYes then
  begin
    DM1.ShowWait('Azzeramento sconti', 'Azzeramento sconti dei righi selezionati in corso...');
    try

      // Per comodità
      MDC := tvCorpo.DataController;
      // Controlla che qualche rigo selezionato ci sia altrimenti esce
      if tvCorpo.Controller.SelectedRecordCount = 0 then
        raise Exception.Create('Non ci sono righi selezionati.');
      // Cicla per tutti i righi selezionati
      for i := 0 to tvCorpo.Controller.SelectedRecordCount - 1 do
      begin
        Row := tvCorpo.Controller.SelectedRecords[i].RecordIndex;
        // Azzera gli sconti del rigo
        MDC.Values[Row, tvCorpoSCONTORIGO.Index] := 0;
        MDC.Values[Row, tvCorpoSCONTORIGO2.Index] := 0;
        MDC.Values[Row, tvCorpoSCONTORIGO3.Index] := 0;
        // Calcola IMPORTO RIGO
        CalcolaImportoRigo(MDC, Row);
      end;
      // Se abilitato e necessario ricalcola i totali del documento
      CalcolaTotali(False);

    finally
      DM1.CloseWait;
    end;
  end;
end;

procedure TPreventiviOrdiniForm.Azzeragliscontidituttiirighi1Click(Sender: TObject);
var
  i: Integer;
  MDC: TcxCustomDataController;
  Row: Integer;
begin
  // Chiede prima conferma all'operatore
  if DM1.Messaggi('Azzeramento sconti', 'Confermi di voler azzerare gli sconti di tutti i righi del documento?', '', [mbYes, mbNo], 0, nil) = mrYes then
  begin
    DM1.ShowWait('Azzeramento sconti', 'Azzeramento sconti di tutti i righi del documento in corso...');
    try

      // Per comodità
      MDC := tvCorpo.DataController;
      // Cicla per tutti i righi selezionati
      for i := 0 to MDC.RecordCount - 1 do
      begin
        // Azzera gli sconti del rigo
        MDC.Values[i, tvCorpoSCONTORIGO.Index] := 0;
        MDC.Values[i, tvCorpoSCONTORIGO2.Index] := 0;
        MDC.Values[i, tvCorpoSCONTORIGO3.Index] := 0;
        // Calcola IMPORTO RIGO
        CalcolaImportoRigo(MDC, i);
      end;
      // Se abilitato e necessario ricalcola i totali del documento
      CalcolaTotali(False);

    finally
      DM1.CloseWait;
    end;
  end;
end;

procedure TPreventiviOrdiniForm.AzzeraStato1Click(Sender: TObject);
begin
  if not RxSpeedModifica.Down then
  begin
    DM1.Messaggi('Levante', 'Devi essere in modalità di modifica', '', [mbOk], 0, nil);
    Exit;
  end;

  if DM1.Messaggi('Azzera stato', 'Confermi di voler azzerare lo stato?', '', [mbYes, mbNo], 0, nil) = mrYes then
  begin
    QryDocumentoSTATODESCRIZIONE.Clear;
    QryDocumentoSTATOFOREGROUND.Clear;
    QryDocumentoSTATOBACKGROUND.Clear;
    DBEditNumDoc.SetFocus;
    DBEditStatoDocumento.SetFocus;
  end;
end;

procedure TPreventiviOrdiniForm.QryDocumentoPRATICAChange(Sender: TField);
begin
  DM1.ShowWait('Levante', 'Opeazione in corso...');
  try
    // Carica la descrizione delle pratiche
    // Carica anche la destinazione della merce (se non è un documento di ingresso)
    // NB: La Termoidraulica Adriatica ha chiesto che anche nei documenti di acquisto
    // venga caricata la destinazione della merce dal cantiere e penso sia giusto così
    if (not QryDocumentoPRATICA.IsNull) and (not QryDocumentoDATAPRATICA1.IsNull) then
    begin
      DM1.CaricaDescrizionePratica(QryDocumentoPRATICA.Value, QryDocumentoDATAPRATICA1.Value, EditDescrizionePratica1);
      EditDescrizionePratica1Change(EditDescrizionePratica1);
      // FOrza l'aggiornamento della descrizione della pratica altrimenti se la descrizione della pratica precedente e quella nuova combaciano non la aggiornava (nemmeno il codice e la data)
      CaricaDestinazioneMerceDaPratica(QryDocumentoPRATICA.Value, QryDocumentoDATAPRATICA1.Value);
    end;
    // Se la form inizialre di richiesta dei dati del soggetto e cantiere del documento
    // è visualizzata la aggiorna con il cambiamento e ne reimposta il focus.
    if BeforeNewDocForm <> nil then
    begin
      BeforeNewDocForm.fDescrizioneCantiere.Text := Self.DbeDescrizioneCantiere.Text;
      BeforeNewDocForm.SetFocus;
    end;

    // Carica gli agenti
    DM1.SetAgenti(QryDocumento, 'CODICECLIENTE', 'PRATICA', 'DATAPRATICA1');

    // Riapre la query con i dati degli apparecchi da usare nelle OP
    ApriQueryApparecchiPratica;

    // Carica i sottocantieri del cantiere attuale  nelle ComboBox delle colonne
    // relative ai sottocantieri
    CaricaItemsSottocantieri;
    CaricaItemsSottocantieriDatiRigo;
    // Se è un impegno aggiorna l'impegno stesso
    if Self.IsImpegno and (ImpegnoForm.QryImp.State <> dsBrowse) then
    begin
      QryDocumentoPRATICA.OnChange := nil;
      ImpegnoForm.QryImpDATAPRATICA1.Value := QryDocumentoDATAPRATICA1.Value;
      ImpegnoForm.QryImpPRATICA.Value := QryDocumentoPRATICA.Value;
      QryDocumentoPRATICA.OnChange := QryDocumentoPRATICAChange;
    end;
  finally
    DM1.CloseWait;
    if BeforeNewDocForm <> nil then
      BeforeNewDocForm.SetFocus;
  end;
end;

procedure TPreventiviOrdiniForm.QryDocumentoPRATICA2Change(Sender: TField);
begin
  // Carica la descrizione delle pratiche
  if (not QryDocumentoPRATICA2.IsNull) and (not QryDocumentoDATAPRATICA2.IsNull) then
    DM1.CaricaDescrizionePratica(QryDocumentoPRATICA2.Value, QryDocumentoDATAPRATICA2.Value, EditDescrizionePratica2);
end;

procedure TPreventiviOrdiniForm.QryDocumentoPRATICA3Change(Sender: TField);
begin
  // Carica la descrizione delle pratiche
  if (not QryDocumentoPRATICA3.IsNull) and (not QryDocumentoDATAPRATICA3.IsNull) then
    DM1.CaricaDescrizionePratica(QryDocumentoPRATICA3.Value, QryDocumentoDATAPRATICA3.Value, EditDescrizionePratica3);
end;

procedure TPreventiviOrdiniForm.tvCorpoFocusedItemChanged(Sender: TcxCustomGridTableView; APrevFocusedItem, AFocusedItem: TcxCustomGridTableItem);
begin
  // Se il focus è andato in una colonna relativa ai sottocantieri abilita l'ImmediateEditor della TableView perchè altrimenti
  // non si comportava bene per quanto riguarda il comparire del pulsante del DropDown della ComboBox (appariva in ritardo,
  // dovevo cliccare 3 volte e non troppo veloce, e altri casini) così sembra andare meglio.
  // Altrimenti rimette tutto a posto
  if (AFocusedItem.Index = tvCorpoSOTTOCANTIERE1.Index) or (AFocusedItem.Index = tvCorpoSOTTOCANTIERE2.Index) or
    (AFocusedItem.Index = tvCorpoSOTTOCANTIERE3.Index) or (AFocusedItem.Index = tvCorpoIDAPPARECCHIO.Index) then
  begin
    Sender.OptionsBehavior.ImmediateEditor := True;
  end
  else
  begin
    Sender.OptionsBehavior.ImmediateEditor := False;
  end;
end;

procedure TPreventiviOrdiniForm.CaricaItemsTipiRighi;
var
  Qry: TIB_Cursor;
  i, CurrLev, PrecLev: Integer;
  CMP1, CMP2, CMP3: TcxComboBoxProperties;
begin
  // Inizializzazione
  PrecLev := 0;
  // Altrimenti provvede a caricare i dati
  Qry := TIB_Cursor.Create(nil);
  try
    Qry.DatabaseName := DM1.ArcDBFile;
    Qry.IB_Connection := DM1.DBAzienda;
    // Imposta la query che ricaverà l'elenco dei tipi di rigo disponibili
    Qry.SQL.Add('SELECT DESCRIZIONE, LIVELLO FROM TIPIRIGHI WHERE ABILITATO <> ''F'' ORDER BY LIVELLO, DESCRIZIONE');
    Qry.Open;
    // Carica il livello del record prima di entrare nel ciclo
    CurrLev := Qry.FieldByName('LIVELLO').AsInteger;
    while (not Qry.Eof) do
    begin
      // Se il livello del record attuale è diverso dal livello del record precedente
      // imposta i riferimenti ai controlli del livello corretto e azzera
      // le combobox
      if CurrLev <> PrecLev then
      begin
        // Trova le colonne giuste
        CMP1 := tvCorpo.FindItemByName('tvCorpoTIPO' + IntToStr(CurrLev)).Properties as TcxComboBoxProperties;
        CMP2 := tvDiBa.FindItemByName('tvDiBaTIPO' + IntToStr(CurrLev)).Properties as TcxComboBoxProperties;
        CMP3 := tvOre.FindItemByName('tvOreTIPO' + IntToStr(CurrLev)).Properties as TcxComboBoxProperties;
        // svuota le proprietà Items de combo box
        CMP1.Items.Clear;
        CMP2.Items.Clear;
        CMP3.Items.Clear;
        // Inserisce la possibilità di togliere il dato
        CMP1.Items.Add('');
        CMP2.Items.Add('');
        CMP3.Items.Add('');
        // Aggiorna la variabile che contiene il riferimento all'ultimo livello caricato
        PrecLev := CurrLev;
      end;
      // Carica il Tipo Rigo attuale
      CMP1.Items.Add(Trim(Qry.FieldByName('DESCRIZIONE').AsString));
      CMP2.Items.Add(Trim(Qry.FieldByName('DESCRIZIONE').AsString));
      CMP3.Items.Add(Trim(Qry.FieldByName('DESCRIZIONE').AsString));
      // Avanti il prossimo record
      Qry.Next;
      // Carica il livello del prossimo record
      if not Qry.Eof then
        CurrLev := Qry.FieldByName('LIVELLO').AsInteger;
    end;
    // Chiude la query
    Qry.Close;
  finally
    Qry.Free;
  end;
end;

procedure TPreventiviOrdiniForm.CaricaItemsSottocantieri;
var
  Qry: TIB_Cursor;
  i: Integer;
begin
  // Se il documento non appartiene ad una pratica esce subito
  if (QryDocumentoPRATICA.AsInteger = 0) or ((QryDocumentoDATAPRATICA1.IsNull)) then
    Exit;
  // Altrimenti provvede a caricare i dati
  Qry := TIB_Cursor.Create(nil);
  try
    Qry.DatabaseName := DM1.ArcDBFile;
    Qry.IB_Connection := DM1.DBAzienda;
    // =========================================================================
    // SOTTOCANTIERI 1
    // -------------------------------------------------------------------------
    // Imposta query
    Qry.SQL.Clear;
    Qry.SQL.Add('SELECT ID FROM SOTTOCANTIERI1 WHERE');
    Qry.SQL.Add('TIPOCANTIERE = ''P''');
    Qry.SQL.Add('AND CODICECANTIERE = ' + QryDocumentoPRATICA.AsString);
    Qry.SQL.Add('AND DATAAPERTURACANTIERE = ''' + FormatDateTime('mm/dd/yyyy', QryDocumentoDATAPRATICA1.AsDateTime) + '''');
    Qry.Open;
    // Caricamento dati
    (tvCorpoSOTTOCANTIERE1.Properties as TcxComboBoxProperties).Items.Clear;
    (tvDiBaSOTTOCANTIERE1.Properties as TcxComboBoxProperties).Items.Clear;
    // Inserisce la possibilità di eliminare il sottocantiere
    (tvCorpoSOTTOCANTIERE1.Properties as TcxComboBoxProperties).Items.Add('');
    (tvDiBaSOTTOCANTIERE1.Properties as TcxComboBoxProperties).Items.Add('');
    while not Qry.Eof do
    begin
      (tvCorpoSOTTOCANTIERE1.Properties as TcxComboBoxProperties).Items.Add(Qry.Fields[0].AsString);
      (tvDiBaSOTTOCANTIERE1.Properties as TcxComboBoxProperties).Items.Add(Qry.Fields[0].AsString);
      Qry.Next;
    end;
    // Carica i dati anche nei combobox del pannello di selezione cumulativa sottocantieri
    SCC1.Properties.Items := (tvCorpoSOTTOCANTIERE1.Properties as TcxComboBoxProperties).Items;
    // =========================================================================
    // =========================================================================
    // SOTTOCANTIERI 2
    // -------------------------------------------------------------------------
    // Imposta query
    Qry.SQL.Clear;
    Qry.SQL.Add('SELECT ID FROM SOTTOCANTIERI2 WHERE');
    Qry.SQL.Add('TIPOCANTIERE = ''P''');
    Qry.SQL.Add('AND CODICECANTIERE = ' + QryDocumentoPRATICA.AsString);
    Qry.SQL.Add('AND DATAAPERTURACANTIERE = ''' + FormatDateTime('mm/dd/yyyy', QryDocumentoDATAPRATICA1.AsDateTime) + '''');
    Qry.Open;
    // Caricamento dati
    (tvCorpoSOTTOCANTIERE2.Properties as TcxComboBoxProperties).Items.Clear;
    (tvDiBaSOTTOCANTIERE2.Properties as TcxComboBoxProperties).Items.Clear;
    // Inserisce la possibilità di eliminare il sottocantiere
    (tvCorpoSOTTOCANTIERE2.Properties as TcxComboBoxProperties).Items.Add('');
    (tvDiBaSOTTOCANTIERE2.Properties as TcxComboBoxProperties).Items.Add('');
    while not Qry.Eof do
    begin
      (tvCorpoSOTTOCANTIERE2.Properties as TcxComboBoxProperties).Items.Add(Qry.Fields[0].AsString);
      (tvDiBaSOTTOCANTIERE2.Properties as TcxComboBoxProperties).Items.Add(Qry.Fields[0].AsString);
      Qry.Next;
    end;
    // Carica i dati anche nei combobox del pannello di selezione cumulativa sottocantieri
    SCC2.Properties.Items := (tvCorpoSOTTOCANTIERE2.Properties as TcxComboBoxProperties).Items;
    // =========================================================================
    // =========================================================================
    // SOTTOCANTIERI 3
    // -------------------------------------------------------------------------
    // Imposta query
    Qry.SQL.Clear;
    Qry.SQL.Add('SELECT ID FROM SOTTOCANTIERI3 WHERE');
    Qry.SQL.Add('TIPOCANTIERE = ''P''');
    Qry.SQL.Add('AND CODICECANTIERE = ' + QryDocumentoPRATICA.AsString);
    Qry.SQL.Add('AND DATAAPERTURACANTIERE = ''' + FormatDateTime('mm/dd/yyyy', QryDocumentoDATAPRATICA1.AsDateTime) + '''');
    Qry.Open;
    // Caricamento dati
    (tvCorpoSOTTOCANTIERE3.Properties as TcxComboBoxProperties).Items.Clear;
    (tvDiBaSOTTOCANTIERE3.Properties as TcxComboBoxProperties).Items.Clear;
    // Inserisce la possibilità di eliminare il sottocantiere
    (tvCorpoSOTTOCANTIERE3.Properties as TcxComboBoxProperties).Items.Add('');
    (tvDiBaSOTTOCANTIERE3.Properties as TcxComboBoxProperties).Items.Add('');
    while not Qry.Eof do
    begin
      (tvCorpoSOTTOCANTIERE3.Properties as TcxComboBoxProperties).Items.Add(Qry.Fields[0].AsString);
      (tvDiBaSOTTOCANTIERE3.Properties as TcxComboBoxProperties).Items.Add(Qry.Fields[0].AsString);
      Qry.Next;
    end;
    // Carica i dati anche nei combobox del pannello di selezione cumulativa sottocantieri
    SCC3.Properties.Items := (tvCorpoSOTTOCANTIERE3.Properties as TcxComboBoxProperties).Items;
    // =========================================================================
    {
      // =========================================================================
      // SOTTOCANTIERI 4
      // -------------------------------------------------------------------------
      // Imposta query
      Qry.SQL.Clear;
      Qry.SQL.Add('SELECT UNITAIMMOBILIARI FROM PRATICHE WHERE');
      Qry.SQL.Add('TIPO = ''P''');
      Qry.SQL.Add('AND CODICE = ' + QryDocumentoPRATICA.AsString);
      Qry.SQL.Add('AND DATAAPERTURA = ''' + FormatDateTime('mm/dd/yyyy', QryDocumentoDATAPRATICA1.AsDateTime) + '''');
      Qry.Open;
      // Caricamento dati
      (tvCorpoSOTTOCANTIERE4.Properties as TcxComboBoxProperties).Items.Clear;
      (tvDiBaSOTTOCANTIERE4.Properties as TcxComboBoxProperties).Items.Clear;
      // Inserisce la possibilità di eliminare il sottocantiere
      (tvCorpoSOTTOCANTIERE4.Properties as TcxComboBoxProperties).Items.Add('');
      (tvDiBaSOTTOCANTIERE4.Properties as TcxComboBoxProperties).Items.Add('');
      for i := 1 to Qry.Fields[0].AsInteger do begin
      (tvCorpoSOTTOCANTIERE4.Properties as TcxComboBoxProperties).Items.Add('Unità ' + IntToStr(i));
      (tvDiBaSOTTOCANTIERE4.Properties as TcxComboBoxProperties).Items.Add('Unità ' + IntToStr(i));
      end;
      // =========================================================================
    }
    {
      // =========================================================================
      // SOTTOCANTIERI 5
      // -------------------------------------------------------------------------
      // Imposta query
      Qry.SQL.Clear;
      Qry.SQL.Add('SELECT ID FROM SOTTOCANTIERI5 WHERE');
      Qry.SQL.Add('TIPOCANTIERE = ''P''');
      Qry.SQL.Add('AND CODICECANTIERE = ' + QryDocumentoPRATICA.AsString);
      Qry.SQL.Add('AND DATAAPERTURACANTIERE = ''' + FormatDateTime('mm/dd/yyyy', QryDocumentoDATAPRATICA1.AsDateTime) + '''');
      Qry.Open;
      // Caricamento dati
      (tvCorpoSOTTOCANTIERE5.Properties as TcxComboBoxProperties).Items.Clear;
      (tvDiBaSOTTOCANTIERE5.Properties as TcxComboBoxProperties).Items.Clear;
      while not Qry.Eof do
      begin
      (tvCorpoSOTTOCANTIERE5.Properties as TcxComboBoxProperties).Items.Add(Qry.Fields[0].AsString);
      (tvDiBaSOTTOCANTIERE5.Properties as TcxComboBoxProperties).Items.Add(Qry.Fields[0].AsString);
      Qry.Next;
      end;
      // =========================================================================
    }
    {
      // =========================================================================
      // SOTTOCANTIERI 6
      // -------------------------------------------------------------------------
      // Imposta query
      Qry.SQL.Clear;
      Qry.SQL.Add('SELECT DESCRIZIONE, MATERIALEAPPARECCHIO FROM APPARECCHI');
      Qry.Open;
      // Caricamento dati
      (tvCorpoSOTTOCANTIERE6.Properties as TcxComboBoxProperties).Items.Clear;
      (tvDiBaSOTTOCANTIERE6.Properties as TcxComboBoxProperties).Items.Clear;
      // Inserisce la possibilità di eliminare il sottocantiere
      (tvCorpoSOTTOCANTIERE6.Properties as TcxComboBoxProperties).Items.Add('');
      (tvDiBaSOTTOCANTIERE6.Properties as TcxComboBoxProperties).Items.Add('');
      while not Qry.Eof do
      begin
      (tvCorpoSOTTOCANTIERE6.Properties as TcxComboBoxProperties).Items.Add(Qry.FieldByName('DESCRIZIONE').AsString + '   -' + Qry.FieldByName('MATERIALEAPPARECCHIO').AsString);
      (tvDiBaSOTTOCANTIERE6.Properties as TcxComboBoxProperties).Items.Add(Qry.FieldByName('DESCRIZIONE').AsString + '   -' + Qry.FieldByName('MATERIALEAPPARECCHIO').AsString);
      Qry.Next;
      end;
      // =========================================================================
    }
  finally
    Qry.Free;
  end;
end;

procedure TPreventiviOrdiniForm.QryDocumentoCalcFields(DataSet: TDataSet);
begin
  if IsSplitPayment then
    QryDocumentoTOTALESPLITPAYMENT.Value := QryDocumentoTOTALEIVA.Value
  else
    QryDocumentoTOTALESPLITPAYMENT.Value := 0;

  // Solo se è una fattura
  if (QryDocumentoTIPODOCUMENTO.AsString = 'Fattura') or (QryDocumentoTIPODOCUMENTO.AsString = 'Nota_accre') or
    (QryDocumentoTIPODOCUMENTO.AsString = 'Fatt.acqui') or (QryDocumentoTIPODOCUMENTO.AsString = 'N.C.fornit') then
  begin
    // Calcola lo Stato Esteso, cioè che comprende anche l'indicazione sul fatto che il destinatario della fatture
    // sia una PA oppure no
    if (QryDocumentoTIPOPERSONA.AsString = 'P') and ((QryDocumentoFE_STATUS.AsString = 'rtSDIMessageRC') or (QryDocumentoFE_STATUS.AsString = 'rtSDIMessageMC'))
    then
      QryDocumentoFE_STATUS_EXT.Value := QryDocumentoFE_STATUS.AsString + '_PA'
    else
      QryDocumentoFE_STATUS_EXT.Value := QryDocumentoFE_STATUS.AsString;
  end;
end;

procedure TPreventiviOrdiniForm.QryDocumentoCAUSALECANTIEREChange(Sender: TField);
var
  Qry: TIB_Cursor;
begin
  // Carica i dati del cliente
  Qry := TIB_Cursor.Create(Self);
  try
    Qry.DatabaseName := DM1.ArcDBFile;
    Qry.IB_Connection := DM1.DBAzienda;
    Qry.SQL.Add('SELECT *');
    Qry.SQL.Add('FROM CAUSALICANTIERI WHERE DESCRIZIONE = ''' + QryDocumentoCAUSALECANTIERE.AsString + '''');
    Qry.Open;
    // Carica i dati l'indirizzo del cliente come destinazione merci del documento attuale
    if not Qry.Eof then
    begin
      // QryDocumentoSegnoOperazioneCantiere.Value          := Qry.FieldByName('SegnoOperazione').AsString;
    end;
  finally
    Qry.Close;
    Qry.Free;
  end;
end;

procedure TPreventiviOrdiniForm.Convertinomearticoloinnomegruppo1Click(Sender: TObject);
begin
  // Chiede prima conferma
  MessageBeep(0);
  if MessageDlg('Sei sicuro/a ?', mtWarning, [mbOk, mbNo], 0) = mrOk then
  begin
    DM1.Attendere;
    try
      ConvertiDescArtInDescGruppo(tvCorpo.DataController);
    finally
      DM1.ChiudiAttendere;
    end;
  end;
end;

procedure TPreventiviOrdiniForm.QryDocumentoDATADOCUMENTOChange(Sender: TField);
begin
  // Ricalcola i campi ValiditaData e ConsegnaData se sono stati inseriti
  // i campi ValiditaGG e ConsegnaGG rispettivamente.
  if not QryDocumentoDATADOCUMENTO.IsNull then
  begin
    // =========================================================================
    // VALIDITADATA
    // -------------------------------------------------------------------------
    // Disabilita il gestore dell'evento OnChange
    QryDocumentoVALIDITADATA.OnChange := nil;
    try
      // Se la ValiditaGG non è nullo provvede ad calcolare automaticamente
      // la Validità del documneto
      if (not QryDocumentoVALIDITAGG.IsNull) and (QryDocumentoVALIDITAGG.AsInteger > 0) then
      begin
        QryDocumentoVALIDITADATA.Value := QryDocumentoDATADOCUMENTO.Value + QryDocumentoVALIDITAGG.AsInteger;
      end
      else
      begin
        QryDocumentoVALIDITADATA.Clear;
      end;
    finally
      // Ripristina il gestore dell.evento
      QryDocumentoVALIDITADATA.OnChange := QryDocumentoVALIDITADATAChange;
    end;
    // =========================================================================

    // =========================================================================
    // CONSEGNADATA
    // -------------------------------------------------------------------------
    // Disabilita il gestore dell'evento OnChange
    QryDocumentoCONSEGNADATA.OnChange := nil;
    try
      // Se la cONSEGNAGG non è nullo provvede ad calcolare automaticamente
      // la Validità del documneto
      if (not QryDocumentoCONSEGNAGG.IsNull) and (QryDocumentoCONSEGNAGG.AsInteger > 0) then
      begin
        QryDocumentoCONSEGNADATA.Value := QryDocumentoDATADOCUMENTO.Value + QryDocumentoCONSEGNAGG.AsInteger;
      end
      else
      begin
        QryDocumentoCONSEGNADATA.Clear;
      end;
    finally
      // Ripristina il gestore dell.evento
      QryDocumentoCONSEGNADATA.OnChange := QryDocumentoCONSEGNADATAChange;
    end;
    // =========================================================================

  end;

  // =========================================================================
  // AGGIORNAMENTO DELL'EVENTUALE DOCUMENTO COLLEGATO (APPUNTAMENTO/INTERVENTO)
  // -------------------------------------------------------------------------
  // Se c'è un documento collegato lo aggiorna
  if Self.IsImpegno and (ImpegnoForm.QryImp.State <> dsBrowse) and (not ImpegnoForm.CreandoDocumentoCollegato) then
  begin
    QryDocumentoDATADOCUMENTO.OnChange := nil;
    try
      if QryDocumentoDATADOCUMENTO.IsNull then
        ImpegnoForm.QryImpDATAORAINTERVENTO.Clear
      else
        ImpegnoForm.QryImpDATAORAINTERVENTO.Value := QryDocumentoDATADOCUMENTO.Value;
    finally
      QryDocumentoDATADOCUMENTO.OnChange := QryDocumentoDATADOCUMENTOChange;
    end;
  end;
  // =========================================================================
  // Forza il caricamento dei documenti correlati (fattura PA) in modo che poi
  // alla conferma del documento stesso vengano salvati anche i documenti correlati
  // questo eprchè altrimenti se cambiavo registro, numero oppure data ad un documento
  // già esistente perdeva i documenti correlati
  CaricaDocumentiCorrelatiPA;
end;

procedure TPreventiviOrdiniForm.QryDocumentoVALIDITAGGChange(Sender: TField);
begin
  // Ricalcola i campi ValiditaData e ConsegnaData se sono stati inseriti
  // i campi ValiditaGG e ConsegnaGG rispettivamente e la data del documento
  QryDocumentoVALIDITADATA.OnChange := nil;
  if (not QryDocumentoDATADOCUMENTO.IsNull) and (not QryDocumentoVALIDITAGG.IsNull) and (QryDocumentoVALIDITAGG.AsInteger > 0) then
  begin
    QryDocumentoVALIDITADATA.Value := QryDocumentoDATADOCUMENTO.Value + QryDocumentoVALIDITAGG.AsInteger;
  end
  else
  begin
    QryDocumentoVALIDITADATA.Clear;
  end;
  QryDocumentoVALIDITADATA.OnChange := QryDocumentoVALIDITADATAChange;
end;

procedure TPreventiviOrdiniForm.QryDocumentoCONSEGNAGGChange(Sender: TField);
begin
  // Ricalcola i campi ValiditaData e ConsegnaData se sono stati inseriti
  // i campi ValiditaGG e ConsegnaGG rispettivamente e la data del documento
  QryDocumentoCONSEGNADATA.OnChange := nil;
  if (not QryDocumentoDATADOCUMENTO.IsNull) and (not QryDocumentoCONSEGNAGG.IsNull) and (QryDocumentoCONSEGNAGG.AsInteger > 0) then
  begin
    QryDocumentoCONSEGNADATA.Value := QryDocumentoDATADOCUMENTO.Value + QryDocumentoCONSEGNAGG.AsInteger;
  end
  else
  begin
    QryDocumentoCONSEGNADATA.Clear;
  end;
  QryDocumentoCONSEGNADATA.OnChange := QryDocumentoCONSEGNADATAChange;
end;

procedure TPreventiviOrdiniForm.QryDocumentoVALIDITADATAChange(Sender: TField);
begin
  // Ricalcola i campi ValiditaGG e ConsegnaGG se sono stati inseriti
  // i campi ValiditaData e ConsegnaData rispettivamente e la data del documento
  QryDocumentoVALIDITAGG.OnChange := nil;
  if (not QryDocumentoDATADOCUMENTO.IsNull) and (not QryDocumentoVALIDITADATA.IsNull) then
  begin
    QryDocumentoVALIDITAGG.Value := Trunc(QryDocumentoVALIDITADATA.Value - QryDocumentoDATADOCUMENTO.Value);
  end
  else
  begin
    QryDocumentoVALIDITAGG.Clear;
  end;
  QryDocumentoVALIDITAGG.OnChange := QryDocumentoVALIDITAGGChange;
end;

procedure TPreventiviOrdiniForm.QryDocumentoCONSEGNADATAChange(Sender: TField);
begin
  // Ricalcola i campi ValiditaGG e ConsegnaGG se sono stati inseriti
  // i campi ValiditaData e ConsegnaData rispettivamente e la data del documento
  QryDocumentoCONSEGNAGG.OnChange := nil;
  if (not QryDocumentoDATADOCUMENTO.IsNull) and (not QryDocumentoCONSEGNADATA.IsNull) then
  begin
    QryDocumentoCONSEGNAGG.Value := Trunc(QryDocumentoCONSEGNADATA.Value - QryDocumentoDATADOCUMENTO.Value);
  end
  else
  begin
    QryDocumentoCONSEGNAGG.Clear;
  end;
  QryDocumentoCONSEGNAGG.OnChange := QryDocumentoCONSEGNAGGChange;
end;

procedure TPreventiviOrdiniForm.ClientAreaChange(Sender: TObject);
begin
  RxSpeedButtonNuovo.Enabled := (ClientArea.ActivePage = TabDoc) and RxSpeedModifica.Down;
  RxSpeedButtonElimina.Enabled := (ClientArea.ActivePage = TabDoc) and RxSpeedModifica.Down;
  RxSpeedButtonVisualizza.Enabled := (ClientArea.ActivePage = TabDoc);
end;

procedure TPreventiviOrdiniForm.ClientAreaPageChanging(Sender: TObject; NewPage: TcxTabSheet; var AllowChange: Boolean);
begin
  // DOCUEMNTI CORRELATI PA
  if NewPage = TabDocumentiCorrelati then
    CaricaDocumentiCorrelatiPA
    // NOTIFICHE FATTURA ELETTRONICA
  else if NewPage = TabNotifiche then
    CaricaNotificheFE;
end;

procedure TPreventiviOrdiniForm.CloseDatiRigoForm;
begin
  if DatiRigoForm = nil then
    Exit;
  DatiRigoForm.Close;
end;

procedure TPreventiviOrdiniForm.OpenDatiRigoForm;
begin
  if DatiRigoForm <> nil then
    Exit;
  Application.CreateForm(TDatiRigoForm, DatiRigoForm);
  DatiRigoForm.PratApparecchiDataSource := SourcePratApp;
  CaricaItemsSottocantieriDatiRigo;
  DatiRigoForm.eRowSection.Properties.OnInitPopup := tvCorpoROWSECTIONPropertiesInitPopup;
  AggiornaDatiRigoForm(QryDocumento);
  if not Self.IsImpegno then
    DatiRigoForm.Show;
end;

procedure TPreventiviOrdiniForm.QryDocumentoABBUONOChange(Sender: TField);
begin
  QryDocumentoABBUONOSU.Clear;
  QryDocumentoABBUONOPERC.Clear;
end;

procedure TPreventiviOrdiniForm.QryDocumentoABIChange(Sender: TField);
var
  QryPag, QryBan: TIB_Cursor;
begin
  // Prosegue solo se sono valorizzati sia l'IBAN che l'ABI
  if (Trim(QryDocumentoABI.AsString) = '') or (Trim(QryDocumentoCAB.AsString) = '') or QryDocumentoPAGAMENTO.IsNull then
    Exit;
  // Carica i dati del cliente
  QryPag := TIB_Cursor.Create(Self);
  QryBan := TIB_Cursor.Create(Self);
  try
    // IMposta la query dei dati pagamento
    QryPag.DatabaseName := DM1.ArcDBFile;
    QryPag.IB_Connection := DM1.DBAzienda;
    QryPag.SQL.Add('SELECT DATICONTOINFATTURA FROM PAGAM WHERE CODICE = ' + QryDocumentoPAGAMENTO.AsString);
    QryPag.Open;
    // Se la modalità di pagamento dice di NON riportare l'IBAN allore cancella il campo ed esce
    // altrimenti se la modalità di pagamento proprio non è stata trovata solleva un'eccezione
    // altrimenti continua
    if QryPag.Eof then
      raise Exception.Create('Modalità di pagamento non trovata!')
    else if (QryPag.Fields[0].AsString = 'F') then
    begin
      QryDocumentoIBAN.Clear;
      Exit;
    end;
    // Se arriva qui significa che deve riportare l'IBAN nella fattura e quindi imposta
    // la query per ricavare l'IBAn dai dati della banca e poi provvede a caricarli sul documneto stesso
    QryBan.DatabaseName := DM1.ArcDBFile;
    QryBan.IB_Connection := DM1.DBAzienda;
    QryBan.SQL.Add('SELECT BANCAIBAN FROM BANCHE WHERE ABI = ' + QuotedStr(QryDocumentoABI.AsString) + ' AND CAB = ' + QuotedStr(QryDocumentoCAB.AsString));
    QryBan.Open;
    if (not QryBan.Eof) then
      QryDocumentoIBAN.AsString := QryBan.Fields[0].AsString
    else
      QryDocumentoIBAN.Clear;
  finally
    QryPag.Close;
    QryPag.Free;
    QryBan.Close;
    QryBan.Free;
  end;
end;

procedure TPreventiviOrdiniForm.QryDocumentoAfterEdit(DataSet: TDataSet);
begin
  // RIchiama questa procedura per aggiornare, se aperta, la form laterale con i dati
  // dei righi selezionati e soprattutto per abilitare/disabilitare
  // i controlli stessi della suddetta form ed evitare così che l'operatore
  // possa modificare i valori mentre il documento non è in Editing.
  AggiornaDatiRigoForm(QryDocumento);
end;

procedure TPreventiviOrdiniForm.QryDocumentoAfterInsert(DataSet: TDataSet);
begin
  // RIchiama questa procedura per aggiornare, se aperta, la form laterale con i dati
  // dei righi selezionati e soprattutto per abilitare/disabilitare
  // i controlli stessi della suddetta form ed evitare così che l'operatore
  // possa modificare i valori mentre il documento non è in Editing.
  AggiornaDatiRigoForm(QryDocumento);
end;

procedure TPreventiviOrdiniForm.QryDocumentoAfterPost(DataSet: TDataSet);
begin
  // RIchiama questa procedura per aggiornare, se aperta, la form laterale con i dati
  // dei righi selezionati e soprattutto per abilitare/disabilitare
  // i controlli stessi della suddetta form ed evitare così che l'operatore
  // possa modificare i valori mentre il documento non è in Editing.
  AggiornaDatiRigoForm(QryDocumento);
end;

procedure TPreventiviOrdiniForm.IMportaArticoliDaTerminaleEsterno;
var
  FF: TextFile; // Puntatore al file di testo da importare
  NomeFileDaImportare: String;
  SS: String;
  SL: TStrings;
  vCodiceArticolo: String;
  vQta: Double;
  P: TMemIniFile;
  CmdStr: String;
  CmdResult: Integer;
  CodArtIndex, QtaIndex, ComPort: Integer;
begin

  // Carica i parametri di comunicazione
  P := TMemIniFile.Create(DM1.CurrDir + 'ExtTerminal.ini');
  try
    CmdStr := P.ReadString('BANCOLINI_UNITERMINAL_B30', 'CommandString', '');

    CodArtIndex := P.ReadInteger('BANCOLINI_UNITERMINAL_B30', 'CodArtIndex', -1);
    QtaIndex := P.ReadInteger('BANCOLINI_UNITERMINAL_B30', 'QtaIndex', -1);
    if (CodArtIndex = -1) or (QtaIndex = -1) then
      raise Exception.Create('Indice CodArtIndex e/o QtaIndex non impostati.');
  finally
    P.Free;
  end;

  // Carica il nome del file da importare nella variabile per facilitare
  // le elaborazioni successive
  // NB: MODIFICATO PERCHE' DA FORTUZZI SEMBRAVA NON ACCETTARE PIU'
  // IL PERCORSO E IL NOME FILE IMPOSTATI NEI PARAMETRI
  // NomeFileDaImportare := 'c:\programmi\dcom\levante\tmpdir\LevTerm.txt';
  NomeFileDaImportare := DM1.DesktopDir + 'FILEDATI.000';

  // Importa i dati dal terminale portatile
  CmdResult := B30XferRx(PAnsiChar(CmdStr));
  if CmdResult <> 0 then
  begin
    case CmdResult of
      777:
        raise Exception.Create('Il terminale portatile non risponde.');
      -2000:
        raise Exception.Create('Errore durante l''apertura della porta seriale. Porta già in uso da un altro dispositivo.');
      -2100:
        raise Exception.Create('Operazione interrotta dall''utente.');
      -3000:
        raise Exception.Create('Errore durante la creazione del file ricevuto.');
      -3050:
        raise Exception.Create('Errore durante l''apertura del file ricevuto. Il file non esiste oppure è vuoto.');
      -3100:
        raise Exception.Create('Errore di handshaking durante la comunicazione.');
    end;
  end;

  // Se il file non esiste solleva ua eccezione
  if not FileExists(NomeFileDaImportare) then
    raise Exception.Create('File da importare non presente.');
  // Crea la StringList che conterrà i campi appena importari
  SL := TStringList.Create;
  SL.Delimiter := ';';
  // Apre il file da importare
  AssignFile(FF, NomeFileDaImportare);
  // Si posiziona all'inizio del file
  Reset(FF);
  // Disabilita l'aggiornamento a video della griglia
  GridCorpo.BeginUpdate;
  // Messaggio a video
  DM1.ShowWait('Terminale portatile', 'Comunicazione in corso...');
  try
    try
      // Cicla finchè non si è arrivato fino in fondo
      while not SeekEof(FF) do
      begin
        // Legge la riga attuale e la pone in SS
        Readln(FF, SS);
        // Ripulisce il tutto da eventuali spazi di troppo all'inizio e alla fine
        SS := Trim(SS);
        // Carica la riga corrente nella StringList
        SL.DelimitedText := SS;
        // Carica i dati correnti nelle variabili di appoggio
        vCodiceArticolo := Trim(SL.Strings[CodArtIndex]);
        vQta := StrToFloat(StringReplace(Trim(SL.Strings[QtaIndex]), '.', ',', []));
        // Messaggio a video
        DM1.ShowWait('Terminale portatile', 'Caricamento articolo: ' + vCodiceArticolo + '   Qtà: ' + FloatToStr(vQta) + '.');
        // Caricamento del rigo nel documento
        NuovoRigoDocumento('', vCodiceArticolo, vCodiceArticolo, vCodiceArticolo, QryDocumentoCODICEMAGAZZINO.AsString, AM_Insert, vQta);
      end;
      // Messaggio a video
      DM1.ShowWait('Terminale portatile', 'Chiusura comunicazione...');
      // Chiude il file da importare
      CloseFile(FF);
      // Elimina il file originario importato
      if not DeleteFile(NomeFileDaImportare) then
        raise Exception.Create('Non è stato possibile eliminare il file importato.'#13#13'L''Operazione è stata annullata.');
      // Fine messaggi a video
      DM1.CloseWait;
      // Riabilita l'aggiornamento a video della griglia
      GridCorpo.EndUpdate;
      // Visualizza un messaggio
      // MessageBeep(0);
      // MessageDlg('Operazione completata!', mtInformation, [mbOk], 0);
    finally
      // Fine messaggi a video
      DM1.CloseWait;
      // Riabilita l'aggiornamento a video della griglia
      GridCorpo.EndUpdate;
      // Pulisce tutto
      SL.Free;
    end;
  except
    // Visualizza un messaggio
    MessageBeep(0);
    MessageDlg
      ('Ci sono stati degli errori durante l''importazione, l''operazione è stata annullata.'#13#13'Il messaggio di errore verrà visualizzato dopo aver premuto OK.',
      mtInformation, [mbOk], 0);
    raise;
  end;
end;

procedure TPreventiviOrdiniForm.ExtTermImportClick(Sender: TObject);
begin
  (Sender as TSpeedButton).Enabled := False;
  try
    IMportaArticoliDaTerminaleEsterno;
  finally
    (Sender as TSpeedButton).Enabled := True;
  end;
end;

procedure TPreventiviOrdiniForm.Selezionecumulativasottocantieri1Click(Sender: TObject);
begin
  // Visualizza il pannello per selezione cumulativa
  // dei sottocantieri.
  PanelSottocantieriCumulativi.Left := Trunc((Self.Width - PanelSottocantieriCumulativi.Width) / 2);
  PanelSottocantieriCumulativi.Top := Trunc((Self.Height - PanelSottocantieriCumulativi.Height) / 2) - 100;
  PanelSottocantieriCumulativi.Visible := True;
  PanelSottocantieriCumulativi.OnExit := PanelSottocantieriCumulativiExit;
  PanelSottocantieriCumulativi.Update;
  if Visible then
    SCC1.SetFocus;
end;

procedure TPreventiviOrdiniForm.BtnExitClick(Sender: TObject);
begin
  PanelSottocantieriCumulativi.OnExit := nil;
  PanelSottocantieriCumulativi.Visible := False;
end;

procedure TPreventiviOrdiniForm.PanelSottocantieriCumulativiExit(Sender: TObject);
begin
  // Non lo fa uscire da qui
  PanelSottocantieriCumulativi.SetFocus;
end;

procedure TPreventiviOrdiniForm.BtnOkClick(Sender: TObject);
var
  i, RI: Integer;
begin
  // CHiede prima conferma
  if DM1.Messaggi('Selezione cumulativa sottocantieri', 'Confermi di voler assegnare i sottocantieri scelti ai tutti i righi selezionati del documento?', '',
    [mbYes, mbNo], 0, nil) <> mrYes then
    Exit;
  // Assegna a tutti i righi selezionati del documento i sottocantieri scelti
  // nell'apposito pannello di scelta cumulativa.
  try
    tvCorpo.DataController.BeginUpdate;
    // Cicla per tutti i righi selezionati
    for i := 0 to tvCorpo.Controller.SelectedRecordCount - 1 do
    begin
      RI := tvCorpo.Controller.SelectedRecords[i].RecordIndex;
      tvCorpo.DataController.Values[RI, tvCorpoSOTTOCANTIERE1.Index] := SCC1.EditText;
      tvCorpo.DataController.Values[RI, tvCorpoSOTTOCANTIERE2.Index] := SCC2.EditText;
      tvCorpo.DataController.Values[RI, tvCorpoSOTTOCANTIERE3.Index] := SCC3.EditText;
    end;
  finally
    tvCorpo.EndUpdate;
    BtnExitClick(BtnExit);
  end;
end;

procedure TPreventiviOrdiniForm.DBEdit120KeyPress(Sender: TObject; var Key: Char);
begin
  if Key = '.' then
    Key := ',';
end;

procedure TPreventiviOrdiniForm.RxSpeedButtonMailClick(Sender: TObject);
begin
  Inviadocumentonormale1Click(Inviadocumentonormale1);
end;

procedure TPreventiviOrdiniForm.Inviadocumentonormale1Click(Sender: TObject);
begin
  // NB: Ho levato i messaggi di attesa perchè alcune volte non si chiudeva
  // la relativa finestrella.
  StampaDocFisc(TipoDoc, Registro, NumeroDoc, DataDoc, 3, 1, False);
end;

function TPreventiviOrdiniForm.CanSendEInvoice: Boolean;
var
  LMsg: String;
begin
  acInviaFatturaElettronica.Update;
  Result := acInviaFatturaElettronica.Enabled;
  if not Result then
  begin
    LMsg := 'A T T E N Z I O N E !!!'#13#13'FATTURA GIA'' INVIATA!!!'#13#13'----------';
    LMsg := LMsg + #13#13 + Format('%s n° %d%s del %s', [QryDocumentoTIPODOCUMENTOESTESO.AsString, QryDocumentoNUMORDPREV.AsInteger,
      QryDocumentoREGISTRO.AsString, QryDocumentoDATADOCUMENTO.AsString]);
    LMsg := LMsg + #13#13 + Format('%s, %s (/d)', [DbeDescrizioneCantiere.Text, QryDocumentoRAGSOCCLI.AsString, QryDocumentoCODICECLIENTE.AsInteger]);
    DM1.Messaggi('Levante', LMsg,
      'Non è possibile re-inviare una fattura se questa è stata già inviata al S.D.I.',
      [mbOk], 0, nil);
  end;
end;

procedure TPreventiviOrdiniForm.InviaFatturaElettronica;
var
  AFatturaPA: TFatturaPA;
begin
  // Prima verifica che possa essere possibile
  if not CanSendEInvoice then
    Exit;
  // Forza il caricamento dei documenti correlati altrimenti la fattura potrebbe partire senza il codice CIG o altro
  CaricaDocumentiCorrelatiPA;
  try
    AFatturaPA := TFatturaPA.Create(Self);
    AFatturaPA.CompilaFatturaElettronica;
    AFatturaPA.SendToProvider;
    QryDocumento.Refresh;
  finally
    AFatturaPA.Free;
  end;
end;

procedure TPreventiviOrdiniForm.Inviadocumentoconesplosionearticolicomposti1Click(Sender: TObject);
begin
  DM1.Attendere;
  try
    StampaDocFisc(TipoDoc, Registro, NumeroDoc, DataDoc, 3, 1, True);
  finally
    DM1.ChiudiAttendere;
  end;
end;

procedure TPreventiviOrdiniForm.RxSpeedButtonMailMouseUp(Sender: TObject; Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
var
  ClientPoint, ScreenPoint: TPoint;
begin
  // *************************************************************************
  // NB: FACENDO CLICK COL DX RICHIAMA IL MENU' DI STAMPA
  // *************************************************************************
  if Button = mbRight then
  begin
    // Esegue la conversione delle coordinate dove dovrà apparire il menù
    // da coordinate client della finestra a coordinate assolute dello schermo.
    // (NB: Il menù popup apparirà in prossimità del tasto NUOVO)
    ClientPoint.X := RxSpeedButtonMail.Left + 10;
    ClientPoint.Y := RxSpeedButtonMail.Top + 10;
    ScreenPoint := ClientToScreen(ClientPoint);
    // Imposta la proprietà TAG del menù (0=Anteprima, 1=Stampa, 2=Fax, 3=Email)
    MenuEmail.Tag := 0;
    MenuEmail.Popup(ScreenPoint.X, ScreenPoint.Y);
  end;
end;

// Procedure che aggiunge la QtàInEvasione alla QtàEvasa
procedure TPreventiviOrdiniForm.EvadiQtaInEvasioneRigo(DC: TcxCustomDataController; RI: Integer);
begin
  if (not VarIsNull(DC.Values[RI, tvCorpoQTAINEVASIONE.Index])) and (DC.Values[RI, tvCorpoQTAINEVASIONE.Index] > 0) then
  begin
    // Aggiunge la QtàInEvasione alla QtàEvasa
    if VarIsNull(DC.Values[RI, tvCorpoQTAEVASA.Index]) then
      DC.Values[RI, tvCorpoQTAEVASA.Index] := DC.Values[RI, tvCorpoQTAINEVASIONE.Index]
    else
      DC.Values[RI, tvCorpoQTAEVASA.Index] := DC.Values[RI, tvCorpoQTAEVASA.Index] + DC.Values[RI, tvCorpoQTAINEVASIONE.Index];
    // Azzera la Qtà in evasione
    DC.Values[RI, tvCorpoQTAINEVASIONE.Index] := NULL;
  end;
end;

// Procedura che evade tutte le QtàInEvasione di tutti i righi del documento
procedure TPreventiviOrdiniForm.EvadiQtaInEvasione(DC: TcxCustomDataController; EsportaRighi: Boolean = False);
var
  i: Integer;
  GiaChiesto: Boolean;
begin
  // Inizializzazione
  GiaChiesto := False;
  tvCorpo.DataController.BeginUpdate;
  try
    with tvCorpo.DataController do
    begin
      // Cicla per tutti i righi del documento
      for i := 0 to RecordCount - 1 do
      begin
        // Se il campo Qtà in evasione > 0
        if (not VarIsNull(Values[i, tvCorpoQTAINEVASIONE.Index])) and (Values[i, tvCorpoQTAINEVASIONE.Index] > 0) then
        begin
          // Chiede conferma per l'esportazione delle qta in evasione verso la bacheca
          if EsportaRighi and not GiaChiesto then
          begin
            EsportaRighi := (DM1.Messaggi('Evasione ordine', 'Copio gli articoli e le Qtà in evasione nella bacheca?', '', [mbYes, mbNo], 0, nil) = mrYes);
            GiaChiesto := True;
          end;
          // Esporta il rigo attuale
          if EsportaRighi then
            EsportaRigoSingolo(tvCorpo.DataController, i, Values[i, tvCorpoQTAINEVASIONE.Index]);
          // Aggiunge la QtàInEvasione alla QtàEvasa
          EvadiQtaInEvasioneRigo(tvCorpo.DataController, i);
        end;
      end;
    end;
  finally
    tvCorpo.DataController.EndUpdate;
    MainForm.AggiornaDocumentiEsportati;
  end;
end;

procedure TPreventiviOrdiniForm.EsportaleQtinevasionenellabacheca1Click(Sender: TObject);
begin
  if DM1.Messaggi('Levante', 'Sei sicuro/a?', '', [mbYes, mbNo], 0, nil) = mrYes then
  begin
    DM1.ShowWait('Levante', 'Operazione in corso...');
    try
      EvadiQtaInEvasione(tvCorpo.DataController, True);
    finally
      DM1.CloseWait;
    end;
  end;
end;

// Procedura che, se è attiva la colonna QTAEVASA, mette uno stato automatico al documento
// in base al fatto che i righi siano tutti evasi oppure no.
procedure TPreventiviOrdiniForm.ImpostaStatoOrdineFornitore;
var
  i: Integer;
  DaEvadere: Boolean;
begin
  // Se il flag OrdineChiuso è visibile e il flag è con valore True
  // imposta al documento lo stato di CHIUSO
  if DbeOrdineChiuso.Visible and (QryDocumentoORDINECHIUSO.AsString = 'T') then
  begin
    QryDocumentoSTATODESCRIZIONE.Value := 'CHIUSO';
    QryDocumentoSTATOFOREGROUND.Value := 'clGray';
    Exit;
  end;
  // Inizializzazione
  DaEvadere := False;
  // Se la colonna QTAEVASA è visibile abilita il controllo altrimenti no
  if tvCorpoQTAEVASA.Visible then
  begin
    // Cicla per tutti i righi del documento
    for i := 0 to tvCorpo.DataController.RecordCount - 1 do
    begin
      // Basta che un solo rigo sia da evedere (NON EVASO) che imposta
      // l'apposito flag ed esce dal ciclo
      if not RigoEvaso(tvCorpo.DataController, i) then
      begin
        DaEvadere := True;
        break;
      end;
    end;
    // In base al flag imposta lo stato appropriato
    if DaEvadere then
    begin
      QryDocumentoSTATODESCRIZIONE.Value := 'NON EVASO';
      QryDocumentoSTATOFOREGROUND.Value := 'clRed';
    end
    else
    begin
      QryDocumentoSTATODESCRIZIONE.Value := 'EVASO';
      QryDocumentoSTATOFOREGROUND.Value := 'clGray';
    end;
  end;
end;

procedure TPreventiviOrdiniForm.tvCorpoCustomDrawCell(Sender: TcxCustomGridTableView; ACanvas: TcxCanvas; AViewInfo: TcxGridTableDataCellViewInfo;
  var ADone: Boolean);
var
  LFontColor: TColor;
  LFontStyle: TFontStyles;
  LRowType: String;
begin
  LFontColor := ACanvas.Font.Color;
  LFontStyle := ACanvas.Font.Style;
  LRowType := VarToStr(AViewInfo.GridRecord.Values[tvCorpoROWTYPE.Index]);
  // Solo se la colonna QTAEVASA è visibile
  if tvCorpoQTAEVASA.Visible then
  begin
    // Se il rigo è EVASO lo visualizza in grigio altrimenti in rosso
    if RigoEvaso(Sender.DataController, AViewInfo.GridRecord.RecordIndex) then
      LFontColor := clGray
    else
      LFontColor := clRed;
  end
  else
    // Se la Qtà non è nulla e il prezzo unitario invece si (o viceversa) potrebbe essere
    // che l'utente si è dimenticato di inserire un valore e per minimizzare il rischio
    // di dimenticanze che posso essere gravi, visualizza i righi interessati in modo
    // che siano evidenziati.
    if EvidenziaRighiSenzaQtaPrzUnit and (AViewInfo.GridRecord.Values[tvCorpoIMPORTORIGO.Index] = 0) and
      (((not VarIsNull(AViewInfo.GridRecord.Values[tvCorpoQTA.Index])) and (AViewInfo.GridRecord.Values[tvCorpoQTA.Index] <> 0)) or
      ((not VarIsNull(AViewInfo.GridRecord.Values[tvCorpoPREZZOUNITARIO.Index])) and (AViewInfo.GridRecord.Values[tvCorpoPREZZOUNITARIO.Index] <> 0))) then
      LFontColor := clRed
    else
      // Qualunque valore negativo (in particolare i margini) viene visualizzato in rosso
      if (not VarIsNull(AViewInfo.Value)) and ((AViewInfo.Item.DataBinding.ValueType = 'Float') or (AViewInfo.Item.DataBinding.ValueType = 'Currency')) and
        (AViewInfo.Value < 0) then
        LFontColor := clRed;
  // Se si tratta di una riga di riepilogo con gli importi relativi ai beni significativi
  // allora imposta il grassetto per evidenziarle.
  if (LRowType = TIPORIGODOC_BS_IvaAgevolata) or (LRowType = TIPORIGODOC_BS_IvaOrdinaria) or (LRowType = TIPORIGODOC_BS_AltriCosti) or
    (LRowType = TIPORIGODOC_TC_Totale) then
    LFontStyle := [fsBold];
  // IN ogni caso forza il font previsto per la colonna in modo che anche se è
  // il rigo selezionato non mi cambi il font.
  if AViewInfo.Selected and (AViewInfo.Item.Styles.Content <> nil) then
  begin
    ACanvas.Font := AViewInfo.Item.Styles.Content.Font;
  end;
  // Set the resulting font color
  ACanvas.Font.Color := LFontColor;
  ACanvas.Font.Style := LFontStyle;
end;

procedure TPreventiviOrdiniForm.tvCorpoPREZZOUNITARIOGetDisplayText(Sender: TcxCustomGridTableItem; ARecord: TcxCustomGridRecord; var AText: string);
begin
  // Se il RowType finisce con il carattere che indica che i prezzi e gli importi del rigo devono essere
  // visualizzati in grigio o cmq in secondo piano...
  if (RightStr(VarToStr(ARecord.Values[tvCorpoROWTYPE.Index]), 1) = TIPORIGODOC_CHAR_GRAYED) and (AText <> '') then
    AText := Format('(%s)', [AText]);
  // Se si tratta di un rigo di riepilogo di beni significativi ed esattamente di uno dei tre
  // righi con i totali dei BS al 22&, BS al 10% e manodopera al 10% allora rende invisibili
  // la Qtà e il Prezzo Unitario
  tvCorpoQTAGetDisplayText(Sender, ARecord, AText);
end;

procedure TPreventiviOrdiniForm.tvCorpoPRZUNITNETTOGetDisplayText(Sender: TcxCustomGridTableItem; ARecord: TcxCustomGridRecord; var AText: String);
var
  PrzUnit: Currency;
begin
  AText := '';
  PrzUnit := 0;
  if (not VarIsNull(ARecord.Values[tvCorpoIMPORTORIGO.Index])) and (not VarIsNull(ARecord.Values[tvCorpoQTA.Index])) and
    (ARecord.Values[tvCorpoIMPORTORIGO.Index] <> 0) and (ARecord.Values[tvCorpoQTA.Index] <> 0) then
  begin
    PrzUnit := DM1.Arrotonda((ARecord.Values[tvCorpoIMPORTORIGO.Index] / ARecord.Values[tvCorpoQTA.Index]), DM1.DecMicroPrz);
    AText := '(' + CurrToStrF(PrzUnit, ffCurrency, DM1.DecMicroPrz) + ')';
  end;
end;

procedure TPreventiviOrdiniForm.QryDocumentoRITACCGetText(Sender: TField; var Text: String; DisplayText: Boolean);
begin
  DisplayText := True;
  if Sender.IsNull or (Sender.AsCurrency = 0) then
    Text := ''
  else
    Text := CurrToStrF(Sender.AsCurrency, ffCurrency, DM1.DecMicroPrz);
end;

procedure TPreventiviOrdiniForm.SelezionecumulativaaliquotaIVA1Click(Sender: TObject);
begin
  try
    DM1.Attendere;
    // Visualizza la form che permette di selezionare l'aliquota IVA da inserire come
    // aliqouta IVA forzata del documento
    Application.CreateForm(TAliquoteIVAForm, AliquoteIVAForm);
    AliquoteIVAForm.Parent := MainForm;
    AliquoteIVAForm.Tag := 997; // Abilita la seleziona dell'aliquota IVA
    AliquoteIVAForm.Show;
  finally
    DM1.ChiudiAttendere;
  end;
end;

procedure TPreventiviOrdiniForm.PanelAumentoPrezziExit(Sender: TObject);
begin
  // Non lo fa uscire da qui
  PanelAumentoPrezzi.SetFocus;
end;

procedure TPreventiviOrdiniForm.BtnAumentoExitClick(Sender: TObject);
begin
  PanelAumentoPrezzi.OnExit := nil;
  PanelAumentoPrezzi.Visible := False;
end;

procedure TPreventiviOrdiniForm.BtnAumentoOkClick(Sender: TObject);
var
  i, RI: Integer;
  PrzUnit: Double;
begin
  // CHiede prima conferma
  if DM1.Messaggi('Aumento cumulativo prezzi', 'Confermi di voler aumentare i prezzi di tutti i righi selezionati del documento?', '', [mbYes, mbNo], 0, nil) <> mrYes
  then
    Exit;
  // Assegna a tutti i righi selezionati del documento i sottocantieri scelti
  // nell'apposito pannello di scelta cumulativa.
  try
    tvCorpo.DataController.BeginUpdate;
    // Cicla per tutti i righi selezionati
    for i := 0 to tvCorpo.Controller.SelectedRecordCount - 1 do
    begin
      RI := tvCorpo.Controller.SelectedRecords[i].RecordIndex;
      if (not DM1.CheckIfExpandable(tvCorpo.DataController, RI, True)) then
      begin
        if not VarIsNull(tvCorpo.DataController.Values[RI, tvCorpoPREZZOUNITARIO.Index]) then
        begin
          PrzUnit := tvCorpo.DataController.Values[RI, tvCorpoPREZZOUNITARIO.Index];
          PrzUnit := DM1.Arrotonda((PrzUnit * (100 + StrToInt(eAumento.EditValue)) / 100), DM1.DecMicroPrz);
          tvCorpo.DataController.Values[RI, tvCorpoPREZZOUNITARIO.Index] := PrzUnit;
          CalcolaPerModificaPrezzoUnitario(RI, tvCorpo.DataController);
          CalcolaImportoRigo(tvCorpo.DataController, RI);
        end;
        // Se si tratta di un rigo composto avvisa l'utente dell'impossibilità dell'operazione su questo rigo
      end
      else
      begin
        DM1.Messaggi('Aumento cumulativo prezzo articoli',
          'ATTENZIONE !!!'#13#13#13'Non è possibile aumentare il prezzo di un rigo composto o di manodopera.'#13#13'L''operazione sui righi composti attualmente selezionati non verrà effettuata',
          '', [mbOk], 0, nil);
      end;
    end;
    // Se abilitato e necessario ricalcola i totali del documento
    CalcolaTotali(False);
  finally
    tvCorpo.EndUpdate;
    BtnAumentoExitClick(BtnAumentoExit);
  end;
end;

procedure TPreventiviOrdiniForm.Aumentocumulativoprezzoarticoli1Click(Sender: TObject);
begin
  // Visualizza il pannello per selezione cumulativa
  // dei sottocantieri.
  PanelAumentoPrezzi.Left := Trunc((ClientArea.Width - PanelAumentoPrezzi.Width) / 2);
  PanelAumentoPrezzi.Top := Trunc((ClientArea.Height - PanelAumentoPrezzi.Height) / 2) - 100;
  PanelAumentoPrezzi.Visible := True;
  PanelAumentoPrezzi.OnExit := PanelAumentoPrezziExit;
  PanelAumentoPrezzi.Update;
  eAumento.SetFocus;
end;

procedure TPreventiviOrdiniForm.tvCorpoSelectionChanged(Sender: TcxCustomGridTableView);
begin
  // Aggiorna i dati della form dei dati del rigo attualmente selezionato
  if DatiRigoForm <> nil then
    AggiornaDatiRigoForm(QryDocumento);
end;

procedure TPreventiviOrdiniForm.ConsideraSituazioneAttualeComeCostoERicarica(Ricarico: Double);
var
  i: Integer;
  ImportoRigo, Qta, CostoUnitario: Double;
  RI: Integer;
begin
  tvCorpo.BeginUpdate;
  try
    // L'operazione è possibile solo sui documenti di vendita
    if DM1.IsDocumentoDiIngresso(QryDocumentoTIPODOCUMENTO.AsString) then
    begin
      DM1.Messaggi('Levante', 'Questa funzione non è disponibile nei documenti di acquisto.'#13#13'L''operazione sarà annullata.', '', [mbOk], 0, nil);
      Exit;
    end;
    // Prima controlla tutti i righi selezinati e verifica che non ci siano righi romposti
    // altrimenti avvisa l'utente e annulla l'operazione
    for i := 0 to tvCorpo.Controller.SelectedRecordCount - 1 do
    begin
      if DM1.CheckIfExpandable(tvCorpo.DataController, tvCorpo.Controller.SelectedRecords[i].RecordIndex, True) then
      begin
        DM1.Messaggi('Levante',
          'Tra i righi selezionati sono presenti anche degli articoli composti o di manodopera.'#13#13'Questa funzione non può operare sugli articoli composti.'#13#13'L''operazione sarà annullata.',
          '', [mbOk], 0, nil);
        Exit;
      end;
    end;
    // Cicla per tutti i righi e imposta la situazione attuale come costo puro e ricarica
    for i := 0 to tvCorpo.Controller.SelectedRecordCount - 1 do
    begin
      // Carica i dati necessari del rigo attuale in variabili locali per comodità
      RI := tvCorpo.Controller.SelectedRecords[i].RecordIndex;
      ImportoRigo := DM1.NoNullFloatValue(tvCorpo.DataController, RI, tvCorpoIMPORTORIGO.Index);
      Qta := DM1.NoNullFloatValue(tvCorpo.DataController, RI, tvCorpoQTA.Index);
      if Qta <> 0 then
        CostoUnitario := DM1.Arrotonda((ImportoRigo / Qta), DM1.DecMicroPrz)
      else
        CostoUnitario := 0;
      tvCorpo.Controller.SelectedRecords[i].Values[tvCorpoSCONTORIGO.Index] := 0;
      tvCorpo.Controller.SelectedRecords[i].Values[tvCorpoSCONTORIGO2.Index] := 0;
      tvCorpo.Controller.SelectedRecords[i].Values[tvCorpoSCONTORIGO3.Index] := 0;
      // Imposta il costo unitario
      tvCorpo.Controller.SelectedRecords[i].Values[tvCorpoPREZZOACQUISTOARTICOLO.Index] := CostoUnitario;
      CalcolaPerModificaPrezzoAcquistoArticolo(RI, tvCorpo.DataController);
      // Imposta il margine
      tvCorpo.Controller.SelectedRecords[i].Values[tvCorpoMARGINE.Index] := Ricarico;
      CalcolaPerModificaMargine(RI, tvCorpo.DataController);
      // Calcola l'importo del rigo
      CalcolaImportoRigo(tvCorpo.DataController, RI);
    end;
    // Se abilitato e necessario ricalcola i totali del documento
    CalcolaTotali(False);
  finally
    tvCorpo.EndUpdate;
  end;
end;

function TPreventiviOrdiniForm.CodiceCIGPresente: Boolean;
var
  DC: TcxCustomDataController;
  RI: Integer;
begin
  Result := False;
  DC := TableViewDocCorr.DataController;
  for RI := 0 to DC.RecordCount - 1 do
    if Trim(VarToStr(DC.Values[RI, TableViewDocCorr_CIG.Index])) <> '' then
      Exit(True);
end;

procedure TPreventiviOrdiniForm.Consideralasituazioneattualecomecostoericarica1Click(Sender: TObject);
begin
  // Visualizza il pannello per selezione cumulativa
  // dei sottocantieri.
  PanelRicarico.Left := Trunc((Self.Width - PanelRicarico.Width) / 2);
  PanelRicarico.Top := Trunc((Self.Height - PanelRicarico.Height) / 2) - 100;
  PanelRicarico.Visible := True;
  PanelRicarico.OnExit := PanelRicaricoExit;
  PanelRicarico.Update;
  eRicarico.SetFocus;
end;

procedure TPreventiviOrdiniForm.PanelRicaricoExit(Sender: TObject);
begin
  // Non lo fa uscire da qui
  PanelRicarico.SetFocus;
end;

procedure TPreventiviOrdiniForm.BtnRicaricoExitClick(Sender: TObject);
begin
  PanelRicarico.OnExit := nil;
  PanelRicarico.Visible := False;
end;

procedure TPreventiviOrdiniForm.BtnRicaricoOkClick(Sender: TObject);
begin
  // CHiede prima conferma
  if DM1.Messaggi('Considera la situazione attuale come costo e ricarica.', 'Confermi di voler continuare?', '', [mbYes, mbNo], 0, nil) <> mrYes then
    Exit;

  DM1.ShowWait('Levante', 'Operazione in corso...');
  try
    eRicarico.PostEditValue; // Altrimenti il dato potrebbe non essere postato
    ConsideraSituazioneAttualeComeCostoERicarica(StrToInt(eRicarico.EditValue));
  finally
    DM1.CloseWait;
    BtnRicaricoExitClick(BtnRicaricoExit);
  end;
end;

procedure TPreventiviOrdiniForm.btvNotificheDataControllerBeforeDelete(ADataController: TcxCustomDataController; ARecordIndex: Integer);
var
  LID: Integer;
begin
  LID := btvNotifiche.DataController.Values[ARecordIndex, btvNotificheID.Index];
  if not TFatturaPA.DeleteNotification(LID) then
    Abort;
end;

procedure TPreventiviOrdiniForm.btvNotificheDonePropertiesValidate(Sender: TObject; var DisplayValue: Variant; var ErrorText: TCaption; var Error: Boolean);
var
  LID: Integer;
  LCheckBox: TcxCheckBox;
begin
  LID := btvNotifiche.Controller.FocusedRecord.Values[btvNotificheID.Index];
  LCheckBox := Sender as TcxCheckBox;
  if not TFatturaPA.SetNotificationDone(LID, LCheckBox.Checked) then
    LCheckBox.Checked := not LCheckBox.Checked;
end;

procedure TPreventiviOrdiniForm.btvNotificheFocusedRecordChanged(Sender: TcxCustomGridTableView; APrevFocusedRecord, AFocusedRecord: TcxCustomGridRecord;
  ANewItemRecordFocusingChanged: Boolean);
var
  LType, LXML: string;
begin
  if not Assigned(AFocusedRecord) then
    Exit;
  LType := VarToStr(AFocusedRecord.Values[btvNotificheMsgCode.Index]);
  LXML := VarToStr(AFocusedRecord.Values[btvNotificheMsgRAW.Index]);
  MemoNotifiche.Lines.Text := TFatturaPA.NotificationToString(LType, LXML);
end;

procedure TPreventiviOrdiniForm.btvNotificheHidePropertiesValidate(Sender: TObject; var DisplayValue: Variant; var ErrorText: TCaption; var Error: Boolean);
var
  LID: Integer;
  LCheckBox: TcxCheckBox;
begin
  LID := btvNotifiche.Controller.FocusedRecord.Values[btvNotificheID.Index];
  LCheckBox := Sender as TcxCheckBox;
  if not TFatturaPA.SetNotificationHide(LID, LCheckBox.Checked) then
    LCheckBox.Checked := not LCheckBox.Checked;
end;

procedure TPreventiviOrdiniForm.tvOreEditValueChanged(Sender: TcxCustomGridTableView; AItem: TcxCustomGridTableItem);
var
  Row: Integer;
  DC: TcxCustomDataController;
begin
  inherited;
  // Per non so quale motivo, quando entro in editing di un campo (Descrizione) passa 2 o 3 volte di quà
  // e anche quando lo confermo passa altre due o tre volte di quà.
  // Però quando modificavo la descrizione (dopo aver messo il memo) premendo INVIO al secondo passaggio
  // mi dava Access Violation Error e ho visto che AItem era nil. Quindi per risolvere
  // ora controllo AItem e se è = nil esco subito.
  if AItem = nil then
    Exit;
  // Questa linea fa in modo che se il DataController ha la proprieta "EditState"
  // di valore dceInsert senza anessun altro flag il programma esce senza fare nulla.
  // Questo è stato necessario perchè se un utente si metteva sull'ultima riga, iniziava a
  // editare il campo e poi premeva il tasto freccia giù, quanto inserito nel campo
  // andava perso e il campo stesso rimaneva vuoto. Ho verificato che in questo caso
  // questo evento veniva lanciato 2 volte, la prima volta in modo corretto, a seconda
  // con valore NULL che azzerava il campo. Così è a posto.
  if Sender.DataController.EditState = [dceInsert] then
    Exit;
  // DC Punta al DataCOntroller della TableView puntata da Sender
  DC := Sender.DataController;
  // Inizializzazione
  Row := DC.FocusedRecordIndex;
  // Blocca il painting della griglia sullo schermo per velocizzare l'esecuzione dei calcoli
  DC.BeginUpdate;
  // Scollega il gestore dell'evento
  // NB: Lo scollego perchè mi capitava che se nel codice seguente modificavo i valore di altuni campi
  // il gestore di evento veniva subito richiamato un'altra volta ma con il valore
  // di 'Sender.Controller.EditingController.Edit.EditValue' sempre = 0 e la cosa
  // mi dava molti problemi. Cmq. poi lo ripristino alla fine.
  Sender.OnEditValueChanged := nil;
  try
    // Le righe quì sotto servono a risolvere l'errore quando un utente eliminava un precedente
    // valore Qtà, praticamente ho visto che quando l'utente cancellava (BackSpace) la precedente
    // Qtà il valore di 'Sender.Controller.EditingController.Edit.EditValue' che è un variant
    // era una Stringa nulla e quindi il variant diventava di 'varString', allora ho fatto in
    // modo che in questo caso reimposta il valore come 'NUll' e tutto sembra funzionare
    // correttamente.
    if (AItem.Index = tvOreQTA.Index) and (VarType(Sender.Controller.EditingController.Edit.EditValue) = varString) and
      (Sender.Controller.EditingController.Edit.EditValue = '') then
      Sender.Controller.EditingController.Edit.EditValue := NULL;

    // Forza la scrittura del nuovo valore inserito dall'utente perchè altrimenti
    // le righe successive lavoravano con il valore antecedente la modifica.
    DC.Values[Row, AItem.Index] := Sender.Controller.EditingController.Edit.EditValue;

    // =====================================================================
    // In base alla colonna modificata esegue gli eventuali calcoli per aggiornare ad es. il totale del rigo, i margini ecc.
    // ---------------------------------------------------------------------
    // QTA (Ore ordinarie)
    if (AItem.Index = tvOreQTA.Index) then
    begin
      // Se la Qta e anche il costo orario non sono nulli provvede a calcolare
      // l'importo.
      Sender.Controller.EditingController.Edit.EditValue := CalcolaImportoOrario(DC, Row);
    end;
    // =====================================================================
    // Calcola IMPORTO RIGO
    CalcolaImportoOrario(DC, Row);
    // Se abilitato e necessario ricalcola i totali del documento
    CalcolaTotali(False);
  finally
    // Ripristina il gestore di evento.
    Sender.OnEditValueChanged := tvOreEditValueChanged;
    // Riabilita il painting del componente forzando così l'aggiornamento dello schermo
    DC.EndUpdate;
  end;
end;

procedure TPreventiviOrdiniForm.tvOreEditing(Sender: TcxCustomGridTableView; AItem: TcxCustomGridTableItem; var AAllow: Boolean);
var
  RI: Longint;
  DC: TcxCustomDataController;
begin
  // DC Punta al DataController corrente
  DC := Sender.DataController;
  // RI contiene l'indice al record corrente
  RI := DC.FocusedRecordIndex;
  // Fa in modo che non si possa modificare l'ultimo rigo obbligatorio
  // ------------------------------------------------------------------------------------
  // Se si tratta del rigo obbligatorio in fondo nega la modifica
  AAllow := not(DM1.NoNullIntValue(DC, RI, tvOreCODDIPENDENTE.Index) = -1);
end;

procedure TPreventiviOrdiniForm.tvOreDESCRIZDIPENDENTEPropertiesButtonClick(Sender: TObject; AButtonIndex: Integer);
begin
  inherited;
  DM1.Attendere;
  try
    Application.CreateForm(TDipendentiForm, DipendentiForm);
    DipendentiForm.Parent := MainForm;
    DipendentiForm.DblClickMode := DblClickModeSelection;
    DipendentiForm.CallerCode := 8;
    DipendentiForm.SoloManodoperaTipo := DM1.CodiceToIndexManodopera(tvCorpo.Controller.FocusedRecord.Values[tvCorpoCODICEARTICOLO.Index]);
    DipendentiForm.Show;
  finally
    DM1.ChiudiAttendere;
  end;
end;

procedure TPreventiviOrdiniForm.tvOreKeyDown(Sender: TObject; var Key: Word; Shift: TShiftState);
begin
  // Fà in modo che non si possa uscire dal Dettaglio con la tastiera
  if ((Key = 38) and ((Sender as TcxGridSite).GridView.DataController.IsBOF)) or ((Key = 40) and ((Sender as TcxGridSite).GridView.DataController.IsEOF)) then
    Key := 0;
end;

procedure TPreventiviOrdiniForm.tvOreCustomDrawCell(Sender: TcxCustomGridTableView; ACanvas: TcxCanvas; AViewInfo: TcxGridTableDataCellViewInfo;
  var ADone: Boolean);
var
  LineColor: TColor;
begin
  // Se è la prima colonna a sinistra disegna il bordo sinistro che altrimenti
  // non c'era.
  if AViewInfo.Item.IsFirst then
  begin
    ADone := True;
    // Disegna il contenuto della cella in modo standard
    AViewInfo.EditViewInfo.Paint(ACanvas); // Paint the default cell's contents
    // Disegna il bordo sinistro della prima colonna perchè altrimenti
    // non veniva disegnata
    LineColor := clBlack;
    ACanvas.DrawComplexFrame(AViewInfo.Bounds, LineColor, LineColor, [bLeft], 1);
  end;
end;

procedure TPreventiviOrdiniForm.tvOreCustomDrawColumnHeader(Sender: TcxGridTableView; ACanvas: TcxCanvas; AViewInfo: TcxGridColumnHeaderViewInfo;
  var ADone: Boolean);
var
  LineColor: TColor;
begin
  // Richiama la gestione predefinita dell'evento
  DM1.QGridCustomDrawColumnHeader(Sender, ACanvas, AViewInfo, ADone);
  // Se è la prima colonna a sinistra disegna il bordo sinistro che altrimenti
  // non c'era.
  if AViewInfo.Column.IsFirst then
  begin
    ADone := True;
    // Disegna il bordo sinistro della prima colonna perchè altrimenti
    // non veniva disegnata
    LineColor := clBlack;
    ACanvas.DrawComplexFrame(AViewInfo.Bounds, LineColor, LineColor, [bLeft], 1);
  end;
end;

procedure TPreventiviOrdiniForm.tvOreDataControllerAfterDelete(ADataController: TcxCustomDataController);
begin
  CalcolaTotaliSottorighiOre(ADataController.GetMasterDataController, ADataController.GetMasterRecordIndex, True);
end;

procedure TPreventiviOrdiniForm.TipoDocumentoPropertiesInitPopup(Sender: TObject);
var
  LO: TMemIniFile;
  TmpStr: String;
begin
  LO := TMemIniFile.Create(DM1.Repository_Layouts.FullLocalFileName);
  try
    // Carica le descrizioni del TipoDocumentoEsteso disponibili per il tipo documento attuale
    TipoDocumento.Properties.Items.Clear;
    TmpStr := LO.ReadString(TipoDoc, 'ListaNomiDoc', TipoDoc + ';');
    while DM1.RitornaTestoPrimaDi(';', TmpStr, False) <> '' do
    begin
      TipoDocumento.Properties.Items.Add(DM1.RitornaTestoPrimaDi(';', TmpStr, True));
    end;
  finally
    LO.Free;
  end;
end;

procedure TPreventiviOrdiniForm.TipoDocumentoKeyPress(Sender: TObject; var Key: Char);
begin
  // IN questo modo impedisce all'utente di inserire a mano un valore
  // senza usare il Modo DropDownList del componente che mi dava dei problemi
  Key := Chr(0);
end;

procedure TPreventiviOrdiniForm.ButtonApplicaVariazioniClick(Sender: TObject);
const
  Titolo = 'Variazione Margini e Mano d''Opera';
var
  MDC: TcxCustomDataController;
  ActualControl: TWinControl;
begin
  // Chiede prima conferma all'utente.
  if DM1.Messaggi(Titolo, 'Confermi di voler applicare le variazioni?', '', [mbYes, mbNo], 0, nil) = mrNo then
    Exit;
  // Sposta il focus per assicurarsi che il dato sia confermato
  ButtonApplicaVariazioni.SetFocus;
  // Applica la variazione % dei margini di ogni singolo rigo e sottorigo
  GridCorpo.BeginUpdate;
  try
    DM1.ShowWait(Titolo, 'Applicazione variazioni documento.');
    ApplicaVariazioniMargini(tvCorpo.DataController);
    // Ricalcola i totali del documento
    CalcolaTotali(True);
  finally
    DM1.CloseWait;
    GridCorpo.EndUpdate;
  end;
end;

procedure TPreventiviOrdiniForm.cxComboBox1PropertiesChange(Sender: TObject);
begin
  BodyView := TBodyView(cbBodyView.ItemIndex);
  // Crea l'istanza dell'oggetto che si occuperò della gestione dei totali a corpo
  // NB: In realtà qua la ricrea nel caso si sia cambiata vista in modo da
  // rigenerare gli indici che puntano alle varie colonne, altrimenti
  // succedevano casini al salvataggio (nei totali a corpo).
  FTotaleCorpo := TTotaleCorpoFactory.NewTotaleCorpo(Self);
end;

procedure TPreventiviOrdiniForm.cxDBComboBox1PropertiesInitPopup(Sender: TObject);
var
  Qry: TIB_Cursor;
begin
  // Crea la query che fornirà l'elenco dei registri disponibili
  Qry := TIB_Cursor.Create(Self);
  try
    Qry.DatabaseName := DM1.ArcDBFile;
    Qry.IB_Connection := DM1.DBAzienda;
    Qry.SQL.Add('SELECT Registro FROM ProgReg');
    Qry.Open;
    // Carica i registri nelle items del componente
    DBComboRegistro.Properties.Items.Clear;
    while not Qry.Eof do
    begin
      DBComboRegistro.Properties.Items.Add(Qry.FieldByName('Registro').Value);
      Qry.Next;
    end;
  finally
    Qry.Close;
    Qry.Free;
  end;
end;

procedure TPreventiviOrdiniForm.cxDBImageComboBox1FocusChanged(Sender: TObject);
begin
  dbeStatus.SetFocus;
end;

procedure TPreventiviOrdiniForm.QryDocumentoSEGNOOPERAZIONEChange(Sender: TField);
begin
  DbeAzioneMagazzino.Properties.OnChange := nil;
  try
    if Sender.AsString = '+' then
      DbeAzioneMagazzino.Text := 'Carico'
    else if Sender.AsString = '-' then
      DbeAzioneMagazzino.Text := 'Scarico'
    else if Sender.AsString = 'I' then
      DbeAzioneMagazzino.Text := 'Impegna'
    else if Sender.AsString = 'O' then
      DbeAzioneMagazzino.Text := 'Ordina'
    else if Sender.AsString = '=' then
      DbeAzioneMagazzino.Text := '- - -'
    else
      DbeAzioneMagazzino.Text := '- - -';
    if BeforeNewDocForm <> nil then
      BeforeNewDocForm.DbeAzioneMagazzino.Text := DbeAzioneMagazzino.Text;
  finally
    DbeAzioneMagazzino.Properties.OnChange := DbeAzioneMagazzinoPropertiesChange;
  end;
end;

procedure TPreventiviOrdiniForm.QryDocumentoSPLITPAYMENTChange(Sender: TField);
begin
  ControllaVisualizzazioneSplitPayment(True);
end;

procedure TPreventiviOrdiniForm.QryDocumentoSEGNOOPERAZIONECANTIEREChange(Sender: TField);
begin
  DbeAzioneCantiere.Properties.OnChange := nil;
  try
    if Sender.AsString = '+' then
      DbeAzioneCantiere.Text := 'Carico'
    else if Sender.AsString = '-' then
      DbeAzioneCantiere.Text := 'Scarico'
    else if Sender.AsString = 'C' then
      DbeAzioneCantiere.Text := 'Commessa'
    else if Sender.AsString = 'M' then
      DbeAzioneCantiere.Text := 'Montaggio'
    else if Sender.AsString = 'F' then
      DbeAzioneCantiere.Text := 'Fattura'
    else if Sender.AsString = '=' then
      DbeAzioneCantiere.Text := '- - -'
    else
      DbeAzioneCantiere.Text := '- - -';
    if BeforeNewDocForm <> nil then
      BeforeNewDocForm.DbeAzioneCantiere.Text := DbeAzioneCantiere.Text;
  finally
    DbeAzioneCantiere.Properties.OnChange := DbeAzioneCantierePropertiesChange;
  end;
end;

procedure TPreventiviOrdiniForm.DbeAzioneMagazzinoPropertiesChange(Sender: TObject);
begin
  QryDocumentoSEGNOOPERAZIONE.OnChange := nil;
  try
    with (Sender as TcxComboBox) do
    begin
      if Text = 'Carico' then
        QryDocumentoSEGNOOPERAZIONE.Value := '+'
      else if Text = 'Scarico' then
        QryDocumentoSEGNOOPERAZIONE.Value := '-'
      else if Text = 'Impegna' then
        QryDocumentoSEGNOOPERAZIONE.Value := 'I'
      else if Text = 'Ordina' then
        QryDocumentoSEGNOOPERAZIONE.Value := 'O'
      else
        QryDocumentoSEGNOOPERAZIONE.Value := '=';

      DbeAzioneMagazzino.Text := Text;
      if BeforeNewDocForm <> nil then
        BeforeNewDocForm.DbeAzioneMagazzino.Text := Text;

      if Self.IsImpegno then
        ImpegnoForm.DbeAzioneMagazzino.Text := Text;
    end;
  finally
    QryDocumentoSEGNOOPERAZIONE.OnChange := QryDocumentoSEGNOOPERAZIONEChange;
  end;
end;

procedure TPreventiviOrdiniForm.DbeDescrizioneCantiereKeyPress(Sender: TObject; var Key: Char);
begin
  if RxSpeedModifica.Down and ((Ord(Key) = VK_BACK) or (Ord(Key) = VK_DELETE)) then
    DM2.ClearCantiereDoc(QryDocumentoPRATICA, QryDocumentoDATAPRATICA1, DbeDescrizioneCantiere);
end;

procedure TPreventiviOrdiniForm.DbeAzioneCantierePropertiesChange(Sender: TObject);
begin
  QryDocumentoSEGNOOPERAZIONECANTIERE.OnChange := nil;
  try
    with (Sender as TcxComboBox) do
    begin
      if Text = 'Carico' then
        QryDocumentoSEGNOOPERAZIONECANTIERE.Value := '+'
      else if Text = 'Scarico' then
        QryDocumentoSEGNOOPERAZIONECANTIERE.Value := '-'
      else if Text = 'Commessa' then
        QryDocumentoSEGNOOPERAZIONECANTIERE.Value := 'C'
      else if Text = 'Montaggio' then
        QryDocumentoSEGNOOPERAZIONECANTIERE.Value := 'M'
      else if Text = 'Fattura' then
        QryDocumentoSEGNOOPERAZIONECANTIERE.Value := 'F'
      else
        QryDocumentoSEGNOOPERAZIONECANTIERE.Value := '=';

      DbeAzioneCantiere.Text := Text;
      if BeforeNewDocForm <> nil then
        BeforeNewDocForm.DbeAzioneCantiere.Text := Text;

      if Self.IsImpegno then
        ImpegnoForm.DbeAzioneCantiere.Text := Text;
    end;
  finally
    QryDocumentoSEGNOOPERAZIONECANTIERE.OnChange := QryDocumentoSEGNOOPERAZIONECANTIEREChange;
  end;
end;

procedure TPreventiviOrdiniForm.EditDescrizionePratica1Change(Sender: TObject);
begin
  if QryDocumentoPRATICA.AsInteger > 0 then
  begin
    DbeDescrizioneCantiere.Text := EditDescrizionePratica1.Text;
    // + ' - ' + QryDocumentoPRATICA.AsString + ' - ' + QryDocumentoDATAPRATICA1.AsString;
  end
  else
  begin
    DbeDescrizioneCantiere.Text := '- - -';
  end;
end;

procedure TPreventiviOrdiniForm.SetAzioniVisible(const Value: Boolean);
begin
  fAzioniVisible := Value;
  LabelAzioni.Visible := Value;
  ShapeAzioni.Visible := Value;
  LabelAzioneMagazzino.Visible := Value;
  LabelAzioneCantiere.Visible := Value;
  DbeAzioneMagazzino.Visible := Value;
  DbeAzioneCantiere.Visible := Value;
  DBEditSegnoOperazione.Visible := Value;
  DBEditSegnoOperazioneCantiere.Visible := Value;
end;

function TPreventiviOrdiniForm.GetIsImpegno: Boolean;
begin
  Result := (Self.TipoDoc = 'Intervento');
end;

function TPreventiviOrdiniForm.GetQrySalvaRighi: TIB_Cursor;
begin
  if not Assigned(FQrySalvaRighi) then
  begin
    FQrySalvaRighi := TIB_Cursor.Create(Self);
    FQrySalvaRighi.DatabaseName := DM1.ArcDBFile;
    FQrySalvaRighi.IB_Connection := DM1.DBAzienda;
    FQrySalvaRighi.SQL.Add('insert into ' + RighiTable +
      ' (TipoDocumento, Registro, NumOrdPrev, DataDocumento, ProgRigo, ProgRigo2, CodiceCliente, CodiceArticolo, CodiceArticoloStm,');
    FQrySalvaRighi.SQL.Add
      ('Descrizione, PrezzoUnitario, QTA, ScontoRigo, ScontoRigo2, ScontoRigo3, ImportoRigo, UnitaDiMisura, PrezzoAcquistoArticolo, ImportoCosto, MovMag, DestQtaEvasa, DestQtaDaEvadere,');
    FQrySalvaRighi.SQL.Add
      ('CodiceMagazzino, CodiceMagazzino2, DescrizioneIVA, AliquotaIVA, Margine, ImportoMargine, NoteRigo, CodiceIVA, ImportoRigoIVACompresa, PrezzoUnitarioIVACompresa, Sinchro,');
    FQrySalvaRighi.SQL.Add('QtaOperaUnit, OperaUnit, ComponentiUnit, CostoOperaUnit, CostoComponentiUnit,');
    FQrySalvaRighi.SQL.Add
      ('QtaOpera, ImportoOpera, ImportoComponenti, ImportoCostoOpera, ImportoCostoComponenti, ImportoMargineComponenti, ImportoMargineOpera, MargineComponenti, MargineOpera,');
    FQrySalvaRighi.SQL.Add('Selezionato, MinutiPrevisti,');
    FQrySalvaRighi.SQL.Add('Sottocantiere1, Sottocantiere2, Sottocantiere3,Sottocantiere4, Sottocantiere5, Sottocantiere6,');
    FQrySalvaRighi.SQL.Add('SegnoOperazioneCantiere, Pratica, DataPratica1, QtaEvasa,');
    FQrySalvaRighi.SQL.Add('Tipo1, Tipo2, Tipo3, Tipo4, Tipo5, Tipo6,');
    FQrySalvaRighi.SQL.Add('GC_COMMESSA_QTA, GC_COMMESSA_IMPORTOACQ, GC_COMMESSA_IMPORTOVEND,');
    FQrySalvaRighi.SQL.Add('GC_CARICO_QTA, GC_CARICO_IMPORTOACQ, GC_CARICO_IMPORTOVEND, GC_SCARICO_QTA, GC_SCARICO_IMPORTOACQ, GC_SCARICO_IMPORTOVEND,');
    FQrySalvaRighi.SQL.Add('GC_MONTATO_QTA, GC_MONTATO_IMPORTOACQ, GC_MONTATO_IMPORTOVEND, GC_FATTURATO_QTA, GC_FATTURATO_IMPORTOACQ, GC_FATTURATO_IMPORTOVEND,');
    FQrySalvaRighi.SQL.Add
      ('GC_COSTONETTOUNITARIO_MOD, GC_COSTONETTOUNITARIO, GC_RICARICO_MOD, GC_RICARICO, GC_QTA_MOD, GC_QTA, GC_DESCRIZIONE_MOD, GC_DESCRIZIONE,');
    FQrySalvaRighi.SQL.Add('GUID, GUID_REF, GUID_ANCESTOR, IDAPPARECCHIOPRAT, IDOPIMPEGNO,');
    FQrySalvaRighi.SQL.Add('PrezzoUnitarioAutocalc, RowType, RowPrintPrices, RowSection,');
    FQrySalvaRighi.SQL.Add('ADG1_TIPODATO, ADG1_RIFERIMENTOTESTO, ADG1_RIFERIMENTONUMERO, ADG1_RIFERIMENTODATA)');
    FQrySalvaRighi.SQL.Add('values');
    FQrySalvaRighi.SQL.Add
      ('(:P_TipoDocumento, :P_Registro, :P_NumOrdPrev, :P_DataDocumento, :P_ProgRigo, :P_ProgRigo2, :P_CodiceCliente, :P_CodiceArticolo, :P_CodiceArticoloStm,');
    FQrySalvaRighi.SQL.Add
      (':P_Descrizione, :P_PrezzoUnitario, :P_QTA, :P_ScontoRigo, :P_ScontoRigo2, :P_ScontoRigo3, :P_ImportoRigo, :P_UnitaDiMisura, :P_PrezzoAcquistoArticolo, :P_ImportoCosto, :P_MovMag, :P_DestQtaEvasa, :P_DestQtaDaEvadere,');
    FQrySalvaRighi.SQL.Add
      (':P_CodiceMagazzino, :P_CodiceMagazzino2, :P_DescrizioneIVA, :P_AliquotaIVA, :P_Margine, :P_ImportoMargine, :P_NoteRigo, :P_CodiceIVA, :P_ImportoRigoIVACompresa, :P_PrezzoUnitarioIVACompresa, :P_Sinchro,');
    FQrySalvaRighi.SQL.Add(':P_QtaOperaUnit, :P_OperaUnit, :P_ComponentiUnit, :P_CostoOperaUnit, :P_CostoComponentiUnit,');
    FQrySalvaRighi.SQL.Add
      (':P_QtaOpera, :P_ImportoOpera, :P_ImportoComponenti, :P_ImportoCostoOpera, :P_ImportoCostoComponenti, :P_ImportoMargineComponenti, :P_ImportoMargineOpera, :P_MargineComponenti, :P_MargineOpera,');
    FQrySalvaRighi.SQL.Add(':P_Selezionato, :P_MinutiPrevisti,');
    FQrySalvaRighi.SQL.Add(':P_Sottocantiere1, :P_Sottocantiere2, :P_Sottocantiere3, :P_Sottocantiere4, :P_Sottocantiere5, :P_Sottocantiere6,');
    FQrySalvaRighi.SQL.Add(':P_SegnoOperazioneCantiere, :P_Pratica, :P_DataPratica1, :P_QtaEvasa,');
    FQrySalvaRighi.SQL.Add(':P_Tipo1, :P_Tipo2, :P_Tipo3, :P_Tipo4, :P_Tipo5, :P_Tipo6,');
    FQrySalvaRighi.SQL.Add(':P_GC_COMMESSA_QTA, :P_GC_COMMESSA_IMPORTOACQ, :P_GC_COMMESSA_IMPORTOVEND,');
    FQrySalvaRighi.SQL.Add
      (':P_GC_CARICO_QTA, :P_GC_CARICO_IMPORTOACQ, :P_GC_CARICO_IMPORTOVEND, :P_GC_SCARICO_QTA, :P_GC_SCARICO_IMPORTOACQ, :P_GC_SCARICO_IMPORTOVEND,');
    FQrySalvaRighi.SQL.Add(':P_GC_MONTATO_QTA, :P_GC_MONTATO_IMPORTOACQ, :P_GC_MONTATO_IMPORTOVEND, :P_GC_FATTURATO_QTA, :P_GC_FATTURATO_IMPORTOACQ, :P_GC_FATTURATO_IMPORTOVEND,');
    FQrySalvaRighi.SQL.Add
      (':P_GC_COSTONETTOUNITARIO_MOD, :P_GC_COSTONETTOUNITARIO, :P_GC_RICARICO_MOD, :P_GC_RICARICO, :P_GC_QTA_MOD, :P_GC_QTA, :P_GC_DESCRIZIONE_MOD, :P_GC_DESCRIZIONE,');
    FQrySalvaRighi.SQL.Add(':P_GUID, :P_GUID_REF, :P_GUID_ANCESTOR, :P_IDAPPARECCHIOPRAT, :P_IDOPIMPEGNO,');
    FQrySalvaRighi.SQL.Add(':P_PrezzoUnitarioAutocalc, :P_RowType, :P_RowPrintPrices, :P_RowSection,');
    FQrySalvaRighi.SQL.Add(':P_ADG1_TIPODATO, :P_ADG1_RIFERIMENTOTESTO, :P_ADG1_RIFERIMENTONUMERO, :P_ADG1_RIFERIMENTODATA)');
    FQrySalvaRighi.Prepare;
  end;
  Result := FQrySalvaRighi;
end;

function TPreventiviOrdiniForm.GetQrySalvaRighiOre: TIB_Cursor;
begin
  if not Assigned(FQrySalvaRighiOre) then
  begin
    FQrySalvaRighiOre := TIB_Cursor.Create(Self);
    FQrySalvaRighiOre.DatabaseName := DM1.ArcDBFile;
    FQrySalvaRighiOre.IB_Connection := DM1.DBAzienda;
    FQrySalvaRighiOre.SQL.Add('INSERT INTO RAPGIORNRIGHI (TIPODOC, NUMDOC, DATADOC, REGISTRO, NUMRIGO, NUMRIGO2, CODDIPENDENTE, DESCRIZDIPENDENTE,');
    FQrySalvaRighiOre.SQL.Add('  CODCANTIERE, DATACANTIERE, DESCRIZCANTIERE, CODSOGGETTO, DESCRIZSOGGETTO, QTA, COSTOORARIO, IMPORTOCOSTOORARIO, NOTE,');
    FQrySalvaRighiOre.SQL.Add
      ('  TIPOORE1, TIPOORE2, TIPOORE3, TIPO1, TIPO2, TIPO3, TIPO4, TIPO5, TIPO6, OPERAINDEX, PRZVEND, IMPORTOVEND, SEGNOOPERAZIONECANTIERE, SOTTOCANTIERE1, SOTTOCANTIERE2, SOTTOCANTIERE3,');
    FQrySalvaRighiOre.SQL.Add
      ('  GC_COSTONETTOUNITARIO_MOD, GC_COSTONETTOUNITARIO, GC_RICARICO_MOD, GC_RICARICO, GC_QTA_MOD, GC_QTA, GC_DESCRIZIONE_MOD, GC_DESCRIZIONE,');
    FQrySalvaRighiOre.SQL.Add('  GUID, GUID_REF, GUID_ANCESTOR)');
    FQrySalvaRighiOre.SQL.Add('VALUES');
    FQrySalvaRighiOre.SQL.Add('  (:P_TIPODOC, :P_NUMDOC, :P_DATADOC, :P_REGISTRO, :P_NUMRIGO, :P_NUMRIGO2, :P_CODDIPENDENTE, :P_DESCRIZDIPENDENTE,');
    FQrySalvaRighiOre.SQL.Add('  :P_CODCANTIERE, :P_DATACANTIERE, :P_DESCRIZCANTIERE, :P_CODSOGGETTO,');
    FQrySalvaRighiOre.SQL.Add('  (SELECT CLIENTI.RAGIONESOCIALE FROM CLIENTI WHERE CLIENTI.CODICE = :P_CODICEDESCRIZSOGGETTO),');
    FQrySalvaRighiOre.SQL.Add('  :P_QTA, :P_COSTOORARIO, :P_IMPORTOCOSTOORARIO, :P_NOTE,');
    FQrySalvaRighiOre.SQL.Add
      ('  :P_TIPOORE1, :P_TIPOORE2, :P_TIPOORE3, :P_TIPO1, :P_TIPO2, :P_TIPO3, :P_TIPO4, :P_TIPO5, :P_TIPO6, :P_OPERAINDEX, :P_PRZVEND, :P_IMPORTOVEND, :P_SEGNOOPERAZIONECANTIERE, :P_SOTTOCANTIERE1, :P_SOTTOCANTIERE2, :P_SOTTOCANTIERE3,');
    FQrySalvaRighiOre.SQL.Add
      ('  :P_GC_COSTONETTOUNITARIO_MOD, :P_GC_COSTONETTOUNITARIO, :P_GC_RICARICO_MOD, :P_GC_RICARICO, :P_GC_QTA_MOD, :P_GC_QTA, :P_GC_DESCRIZIONE_MOD, :P_GC_DESCRIZIONE,');
    FQrySalvaRighiOre.SQL.Add('  :P_GUID, :P_GUID_REF, :P_GUID_ANCESTOR)');
    FQrySalvaRighiOre.Prepare;
  end;
  Result := FQrySalvaRighiOre;
end;

procedure TPreventiviOrdiniForm.FormHide(Sender: TObject);
begin
  if DatiRigoForm <> nil then
    DatiRigoForm.Hide;
end;

procedure TPreventiviOrdiniForm.SetDatiPrincipaliDocumentoVisible(const Value: Boolean);
begin
  fDatiPrincipaliDocumentoVisible := Value;
  LabelDocumento.Visible := Value;
  ShapeDocumento.Visible := Value;
  TipoDocumento.Visible := Value;
  LabelNumReg.Visible := Value;
  DBEditNumDoc.Visible := Value;
  DBComboRegistro.Visible := Value;
  LabelData.Visible := Value;
  DBEDataDoc.Visible := Value;
  PanelCantiere.Visible := Value;
end;

procedure TPreventiviOrdiniForm.QryDocumentoRAGSOCCLIChange(Sender: TField);
begin
  // Se c'è un documento collegato lo aggiorna
  if Self.IsImpegno and (ImpegnoForm.QryImp.State <> dsBrowse) then
  begin
    Sender.OnChange := nil;
    ImpegnoForm.QryImp.FieldByName(Sender.FieldName).Value := Sender.Value;
    Sender.OnChange := QryDocumentoRAGSOCCLIChange;
  end;
end;

procedure TPreventiviOrdiniForm.QryDocumentoNUMORDPREVChange(Sender: TField);
begin
  // Se c'è un documento collegato lo aggiorna
  if Self.IsImpegno and (ImpegnoForm.QryImp.State <> dsBrowse) then
  begin
    QryDocumentoNUMORDPREV.OnChange := nil;
    if QryDocumentoNUMORDPREV.IsNull then
      ImpegnoForm.QryImpID.Clear
    else
      ImpegnoForm.QryImpID.Value := QryDocumentoNUMORDPREV.Value;
    QryDocumentoNUMORDPREV.OnChange := QryDocumentoNUMORDPREVChange;
  end;
  // Forza il caricamento dei documenti correlati (fattura PA) in modo che poi
  // alla conferma del documento stesso vengano salvati anche i documenti correlati
  // questo eprchè altrimenti se cambiavo registro, numero oppure data ad un documento
  // già esistente perdeva i documenti correlati
  CaricaDocumentiCorrelatiPA;
end;

procedure TPreventiviOrdiniForm.QryDocumentoREGISTROChange(Sender: TField);
begin
  // Se c'è un documento collegato lo aggiorna
  if Self.IsImpegno and (ImpegnoForm.QryImp.State <> dsBrowse) then
  begin
    QryDocumentoREGISTRO.OnChange := nil;
    if QryDocumentoREGISTRO.IsNull then
      ImpegnoForm.QryImpREGISTRO.Clear
    else
      ImpegnoForm.QryImpREGISTRO.Value := QryDocumentoREGISTRO.Value;
    QryDocumentoREGISTRO.OnChange := QryDocumentoREGISTROChange;
  end;
  // Forza il caricamento dei documenti correlati (fattura PA) in modo che poi
  // alla conferma del documento stesso vengano salvati anche i documenti correlati
  // questo eprchè altrimenti se cambiavo registro, numero oppure data ad un documento
  // già esistente perdeva i documenti correlati
  CaricaDocumentiCorrelatiPA;
end;

procedure TPreventiviOrdiniForm.QryDocumentoRicalcolaDocumentoEventHandler(Sender: TField);
begin
  CalcolaTotali(False);
end;

procedure TPreventiviOrdiniForm.tvCorpoStartDrag(Sender: TObject; var DragObject: TDragObject);
var
  i: Integer;
  LTV: TcxGridTableView;
begin
  // ===========================================================================
  // GESTIONE DEL DRAG AND DROP INTERNO ALLA GRIGLIA STESSA
  // ---------------------------------------------------------------------------
  LTV := (Sender as TcxGridSite).GridView as TcxGridTableView;
  // Memorizza la riga con il focus al momento dell'avvio del trascinamento
  fStartDragRowIndex := LTV.Controller.FocusedRowIndex;
  // Memorizza in un array il RowIndex delle righe selezionate al momento
  // dell'inizio del trascinamento
  SetLength(fSelectedDragRecordIndex, LTV.Controller.SelectedRecordCount);
  for i := 0 to LTV.Controller.SelectedRecordCount - 1 do
    fSelectedDragRecordIndex[i] := LTV.Controller.SelectedRecords[i].RecordIndex;
  // ===========================================================================
end;

procedure TPreventiviOrdiniForm.tvCorpoTcxGridDataControllerTcxDataSummaryFooterSummaryItems0GetText(Sender: TcxDataSummaryItem; const AValue: Variant;
  AIsFooter: Boolean; var AText: string);
begin
  // Se è zero non visualizza nulla
  if VarIsNull(AValue) or (AValue = 0) then
    AText := '';
end;

procedure TPreventiviOrdiniForm.tvCorpoTcxGridDataControllerTcxDataSummaryFooterSummaryItems14GetText(Sender: TcxDataSummaryItem; const AValue: Variant;
  AIsFooter: Boolean; var AText: string);
var
  Minuti: Integer;
begin
  // Se è zero non visualizza nulla
  if VarIsNull(AValue) or (AValue = 0) then
    AText := ''
  else
  begin
    Minuti := AValue;
    AText := Format('%d:%d', [(Minuti div 60), (Minuti mod 60)]);
  end;
end;

// ===========================================================================
// GESTIONE DEL DRAG AND DROP INTERNO ALLA GRIGLIA STESSA
// ---------------------------------------------------------------------------
procedure TPreventiviOrdiniForm.ReorderRows(ASourceView, ADestView: TcxGridTableView; ADestRec: TcxCustomGridRecord);
var
  i: Integer;
  LMacroStep, LMicroStep, OrderDestinazione: Double;
  SezioneDestinazione: String;
  PrecDeletingConfirmation: Boolean;

  procedure SelectDestRows;
  var
    RI, SelectIdx: Integer;
  begin
    for RI := 0 to ADestView.DataController.RecordCount - 1 do
    begin
      if ADestView.DataController.DisplayTexts[RI, tvCorpoTODELETE.Index] = 'True' then
      begin
        SelectIdx := ADestView.DataController.GetRowIndexByRecordIndex(RI, True);
        ADestView.DataController.SelectRows(SelectIdx, SelectIdx);
        ADestView.DataController.Values[RI, tvCorpoTODELETE.Index] := False;
      end;
    end;
  end;

  procedure DeleteSourceSelectedRows;
  var
    i: Integer;
  begin
    // Elimina i records origine
    for i := Length(fSelectedDragRecordIndex) - 1 downto 0 do
      ASourceView.DataController.DeleteRecord(fSelectedDragRecordIndex[i]);
  end;

  procedure AppendAndCopyRowData;
  var
    LI, LDestRecordIndex: Integer;
  begin
    LDestRecordIndex := ADestView.DataController.AppendRecord;
    // Copia i valori di tutte le colonne
    for LI := 0 to ASourceView.ColumnCount - 1 do
      ADestView.DataController.Values[LDestRecordIndex, LI] := ASourceView.DataController.Values[fSelectedDragRecordIndex[i], LI];
    // Copia la sezione del rigo di destinazione
    ADestView.DataController.Values[LDestRecordIndex, tvCorpoORDER.Index] := OrderDestinazione;
    ADestView.DataController.Values[LDestRecordIndex, tvCorpoROWSECTION.Index] := SezioneDestinazione;
    // Marca il record corrente come "da selezionare" alla fine del processo di spostamento
    // dei righi selezionati. Lo scopo è quello di avere i righi che si stanno spostando
    // selezionati per massimizzare l'effetto di spostamento (gli stessi righi che si stanno
    // spostando e che erano selezionati nella View di partenza saranno selezionati anche
    // nella view di destinazione anche se in realtà non sono gli stessi righi ma una copia di essi).
    // NB: Ho provato a impostare semplicemente la proprietà Selected del record (vedi riga commentata
    // sotto ma non funzionava bene e selezionava altri righi).
    // ADestView.ViewData.Records[LDestRecordIndex].Selected := True;
    ADestView.DataController.Values[LDestRecordIndex, tvCorpoTODELETE.Index] := True;
    // Deselezione il rigo origine (altrimenti rimarrebbe selezionato e non mi piace)
    ASourceView.ViewData.Records[fSelectedDragRecordIndex[i]].Selected := False;
  end;

  procedure MoveRow;
  var
    LCurrDragRecordIndex: Integer;
  begin
    // Incrementa il valore ORDER destinazione di una microunità per mantenere l'ordine
    // tra le righe che si stanno spostando
    OrderDestinazione := OrderDestinazione + LMicroStep;
    // Se la TableView sorgente e quella di destinazione non sono uguali (quindi si stanno
    // spostando le righe da dentro o fuori un dettaglio) provvede anche a creare i
    // nuovi record nella vista di destinazione e ad eliminare quelli dalla lista sorgente.
    // Altrimenti li sposta semplicemente.
    if (ASourceView <> ADestView) or (GetKeyState(VK_CONTROL) < 0) then
    begin
      ADestView.Columns[tvCorpoORDER.Index].SortOrder := soNone;
      try
        AppendAndCopyRowData;
      finally
        ADestView.Columns[tvCorpoORDER.Index].SortOrder := soAscending;
      end;
    end
    else
    begin
      LCurrDragRecordIndex := fSelectedDragRecordIndex[i];
      ADestView.DataController.Values[LCurrDragRecordIndex, tvCorpoORDER.Index] := OrderDestinazione;
      ADestView.DataController.Values[LCurrDragRecordIndex, tvCorpoROWSECTION.Index] := SezioneDestinazione;
    end;
  end;

begin
  // Prepara l'operazione
  Screen.Cursor := crHourGlass;
  GridCorpo.BeginUpdate;
  try
    // OrderDestinazione contiene il valore ORDER della riga destinazione
    // e verrà utilizzato per ricavare i nuovi valori ORDER per lo spostamento
    // delle riche selezionate.
    OrderDestinazione := ADestRec.Values[tvCorpoORDER.Index];
    SezioneDestinazione := VarToStr(ADestRec.Values[tvCorpoROWSECTION.Index]);
    // A seconda che stiamo spostanto righe verso il basso o verso l'alto
    if (fStartDragRowIndex > ADestRec.Index) then
      LMacroStep := -0.5
    else
      LMacroStep := +0.5;
    LMicroStep := +0.0001;
    // OrderDestinazione contiene il nuovo valore del campo ORDER per la riga che si vuole spostare
    OrderDestinazione := OrderDestinazione + LMacroStep;
    // Cicla per tutto l'array che contiene gli indici delle righe selezionate per lo spostamento.
    for i := 0 to Length(fSelectedDragRecordIndex) - 1 do
      MoveRow;
    if (ASourceView <> ADestView) and not(GetKeyState(VK_CONTROL) < 0) then
      DeleteSourceSelectedRows;
    // Rigenera i valori di ORDER in modo da avere solo numeri interi
    RefreshOrderValues(ADestView);
    // Marca il record corrente come "da selezionare" alla fine del processo di spostamento
    // dei righi selezionati. Lo scopo è quello di avere i righi che si stanno spostando
    // selezionati per massimizzare l'effetto di spostamento (gli stessi righi che si stanno
    // spostando e che erano selezionati nella View di partenza saranno selezionati anche
    // nella view di destinazione anche se in realtà non sono gli stessi righi ma una copia di essi).
    SelectDestRows;
  finally
    // RImette tutto a posto
    GridCorpo.EndUpdate;
    Screen.Cursor := crDefault;
    // Ricalcola i totali (aggiunto per i Totali a corpo)
    // NB: Forzo il ricalcolo totale del documento perchè se si sono spostati più sottorighi
    // al di fuori del loro rigo principale di partenza non ricalcolava correttamente
    // il tutto.
    CalcolaTotali(True);
  end;
end;
procedure TPreventiviOrdiniForm.RGAbbuonoPropertiesChange(Sender: TObject);
begin
  // Abilita/disabilita il campo AbbuonoPerc in base alla selezione nel RadioGroup
  //  per decidere se lo sconto percentuale va applicato all'imponibile oppure
  //  al totale documento.
  //  In pratica finchè non si seleziona non si può mettere lo sconto in precentuale.
  if QryDocumentoABBUONOSU.AsString <> '' then
    dbeAbbuonoPerc.Visible := LabelAbbuonoPerc.Visible
  else
    dbeAbbuonoPerc.Visible := False;
end;

// ===========================================================================

// ===========================================================================
// GESTIONE DEL DRAG AND DROP INTERNO ALLA GRIGLIA STESSA
// ---------------------------------------------------------------------------
procedure TPreventiviOrdiniForm.RefreshOrderValues(AView: TcxGridTableView; EseguiBeginUpdate: Boolean = True);
var
  i: Integer;
begin
  if EseguiBeginUpdate then
    AView.BeginUpdate;
  try
    // Cicla per tutte le righe per rinumerare tutti i valori della colonna ORDER
    // NB: Questo è un primo ciclo che rinumera in negativo in modo da evitare casini
    // per il possibile sovrapporsi di valori nella colonna ORDER
    for i := 0 to (AView.ViewData.RowCount - 1) do
      AView.ViewData.Rows[i].Values[tvCorpoORDER.Index] := (i - 100000);
    // Poi ricicla di nuovo per rinumerare tutti i righi partendo da 1
    for i := (AView.ViewData.RowCount - 1) downto 0 do
      AView.ViewData.Rows[i].Values[tvCorpoORDER.Index] := (i + 1);
  finally
    if EseguiBeginUpdate then
      AView.EndUpdate;
  end;
end;
// ===========================================================================

procedure TPreventiviOrdiniForm.tvCorpoDataControllerAfterInsert(ADataController: TcxCustomDataController);
begin
  // NB: Ho messo qio questo BeginUpdate (e il conseguente EndUpdate nell'evento OnAfterInsert) perchè
  // altrimenti era troppo lento fare l'insert di nuove righe, soprattutto se c'erano molti
  // righi e ancora di più se c'erano dei sottorighi
  GridCorpo.EndUpdate;
end;

procedure TPreventiviOrdiniForm.tvCorpoDataControllerBeforeInsert(ADataController: TcxCustomDataController);
begin
  // NB: Ho messo qio questo BeginUpdate (e il conseguente EndUpdate nell'evento OnAfterInsert) perchè
  // altrimenti era troppo lento fare l'insert di nuove righe, soprattutto se c'erano molti
  // righi e ancora di più se c'erano dei sottorighi
  GridCorpo.BeginUpdate;
end;

procedure TPreventiviOrdiniForm.tvCorpoDataControllerBeforePost(ADataController: TcxCustomDataController);
begin
  // -----------------------------------------------------------------------------------------------------
  // Dopo aver inserito un nuovo record imposta il valore di ORDER per fargli mantenere la posizione.
  with ADataController do
    Values[FocusedRecordIndex, tvCorpoORDER.Index] := FocusedRecordIndex + 0.0001;
  // Rigenera i valori di ORDER in modo da avere solo numeri interi
  // RefreshOrderValues(tvCorpo);
  RefreshOrderValues(GridCorpo.FocusedView as TcxGridTableView);
  // -----------------------------------------------------------------------------------------------------
end;

procedure TPreventiviOrdiniForm.tvCorpoDataControllerDetailCollapsed(ADataController: TcxCustomDataController; ARecordIndex: Integer);
var
  RelationIndex: Integer;
begin
  // Ottiene l'indice della relazione in base al fatto che il rigo principale sia un rigo di manodopera oppure di componenti
  if DM1.CodiceIsManodopera(DM1.NoNullStringValue(ADataController, ARecordIndex, tvCorpoCODICEARTICOLO.Index)) then
    RelationIndex := RELATION_IDX_SOTTORIGHI_ORE
  else
    RelationIndex := RELATION_IDX_SOTTORIGHI_NORMALI;
  // Se non ci sono sottorighi provvede a eliminare il DetailLinkObject altrimenti il rigo rimarrebbe cmq
  // "espandibile" anche se vuoto
  if ADataController.GetDetailDataController(ARecordIndex, RelationIndex).RecordCount = 0 then
    ADataController.ClearDetailLinkObject(ARecordIndex, RelationIndex);
end;

procedure TPreventiviOrdiniForm.tvCorpoDataControllerNewRecord(ADataController: TcxCustomDataController; ARecordIndex: Integer);
begin
  // Verifica ed eventualmente inserisce i valori di default relativi
  // all'aliquota IVA e ai codici magazzino del nuovo rigo
  CheckForDefaultIvaAndMag(ADataController, ARecordIndex);
end;

procedure TPreventiviOrdiniForm.CheckForDefaulRowSection(ADataController: TcxCustomDataController; ARecordIndex: Integer);
begin
  // Se c'è un rigo precedente e se la sezione corrente è vuota il nuovo rigo ne eredita la RowSection
  if (ARecordIndex = 0) or ((not VarIsNull(ADataController.Values[ARecordIndex, tvCorpoROWSECTION.Index])) and
    (Trim(ADataController.Values[ARecordIndex, tvCorpoROWSECTION.Index]) <> '')) then
  begin
    ADataController.Values[ARecordIndex, tvCorpoROWSECTION.Index] := '';
    Exit;
  end;
  ADataController.Values[ARecordIndex, tvCorpoROWSECTION.Index] := VarToStr(ADataController.Values[ARecordIndex - 1, tvCorpoROWSECTION.Index]);
end;

procedure TPreventiviOrdiniForm.CheckForDefaultIvaAndMag(ADataController: TcxCustomDataController; ARecordIndex: Integer);
var
  CI, CM1, CM2: Integer;
begin
  // Inizializzazione
  CI := tvCorpoCODICEIVA.Index;
  CM1 := tvCorpoCODICEMAGAZZINO.Index;
  CM2 := tvCorpoCODICEMAGAZZINO2.Index;
  // DC Punta al Datacontroller corrente
  // Imposta per default l'aliquota al Codice 1
  // Imposta per default il COdiceMagazzino del rigo uguale a quello del documento
  // NB: Siccome era troppo lento il codice qui sotto (quello all'interno del with) provo
  // ad eliminare tutte le verifiche di nullità o meno di tutti i campi e assumo che se il rigo
  // è senza aliquota IVA significa che è un rigo nuovo e quindi controllo solo la nullità o meno
  // dell'aliquota IVA.
  with ADataController do
  begin
    // Se nullo imposta il codice IVA di default
    if VarIsNull(Values[ARecordIndex, CI]) or (Values[ARecordIndex, CI] = 0) then
    begin
      AssegnaAliquotaIVA(DocIvaDefault.Codice, ARecordIndex, ADataController);
      Values[ARecordIndex, CM1] := QryDocumentoCODICEMAGAZZINO.AsInteger;
      Values[ARecordIndex, CM2] := QryDocumentoCODICEMAGAZZINO2.AsInteger;
      Values[ARecordIndex, tvCorpoTIPO1.Index] := DM1.TableProgressiviTIPO1.AsString;
      Values[ARecordIndex, tvCorpoTIPO2.Index] := DM1.TableProgressiviTIPO2.AsString;
      Values[ARecordIndex, tvCorpoTIPO3.Index] := DM1.TableProgressiviTIPO3.AsString;
      Values[ARecordIndex, tvCorpoTIPO4.Index] := DM1.TableProgressiviTIPO4.AsString;
      Values[ARecordIndex, tvCorpoTIPO5.Index] := DM1.TableProgressiviTIPO5.AsString;
      Values[ARecordIndex, tvCorpoTIPO6.Index] := DM1.TableProgressiviTIPO6.AsString;
    end;
  end;
end;

procedure TPreventiviOrdiniForm.TotaleacorpoSOLOdeirighiselezionati1Click(Sender: TObject);
begin
  if DM1.Messaggi('Totale a corpo', 'Confermi di voler fare il totale a corpo dei righi selezionati?', '', [mbYes, mbNo], 0, nil) <> mrYes then
    Exit;
  DM1.ShowWait('Totale a corpo', 'Operazione in corso...');
  try
    TotaleACorpoRighiSelezionati(tvCorpo);
  finally
    DM1.CloseWait;
  end;
end;

procedure TPreventiviOrdiniForm.FormResize(Sender: TObject);
begin
  // IMposta la posizione della client area e i relativi margini
  Self.CalcolaDimensioniClientAreaChildForm(BodyScreenState = bssNormal);
  // Ricarica il layout documento solo se la form è visibile
  // e non siamo in modalità BodyFullStretched
  // NB: Se tolgo il Self.Visible poi ci sono dei problemi di visualizzazione del documento
  // nel caso in cui si ridimensiona Levante mentre l'utente è su un'altra pagina del
  // documento (ad es. su un impegno è nella parte appuntamento oppure su un articolo
  // composto è nella parte anagrafica articolo) probabilmente perchè l'esecuzione del
  // CaricaLayouts con la form non visibile fa casino.
  if Self.Visible and (BodyScreenState <> bssFullStretched) then
  begin
    // Proprietà che se messa a True fa in modo che alla prossima chiamata della procedure
    // CaricaLayoutDocumento non vengano rielaborate le impostazioni delle colonne del documento
    // in modo da velocizzare un pò l'esecuzione.
    CaricaLayoutDocumento_NotLoadColumnSettingsNextTime := True;
    CaricaLayoutDocumento;
  end;
  // RIdimensiona anche la form laerale con i dati del rigo
  if DatiRigoForm <> nil then
    DatiRigoForm.Ridimensiona;
end;

procedure TPreventiviOrdiniForm.SbRifSogg1Click(Sender: TObject);
begin
  DM1.SelezionaCliente(QryDocumentoRIFSOGG1_CODICE, nil, nil, '');
end;

procedure TPreventiviOrdiniForm.SbRifSogg2Click(Sender: TObject);
begin
  DM1.SelezionaCliente(QryDocumentoRIFSOGG2_CODICE, nil, nil, '');
end;

procedure TPreventiviOrdiniForm.SbRifSogg3Click(Sender: TObject);
begin
  DM1.SelezionaCliente(QryDocumentoRIFSOGG3_CODICE, nil, nil, '');
end;

procedure TPreventiviOrdiniForm.SbRifSogg4Click(Sender: TObject);
begin
  DM1.SelezionaCliente(QryDocumentoRIFSOGG4_CODICE, nil, nil, '');

end;

procedure TPreventiviOrdiniForm.SbRifSogg5Click(Sender: TObject);
begin
  DM1.SelezionaCliente(QryDocumentoRIFSOGG5_CODICE, nil, nil, '');

end;

procedure TPreventiviOrdiniForm.SbRifSogg6Click(Sender: TObject);
begin
  DM1.SelezionaCliente(QryDocumentoRIFSOGG6_CODICE, nil, nil, '');

end;

procedure TPreventiviOrdiniForm.QryDocumentoRIFSOGG1_CODICEChange(Sender: TField);
var
  QryCli: TIB_Cursor;
begin
  // Carica i dati del cliente
  QryCli := TIB_Cursor.Create(Self);
  try
    QryCli.DatabaseName := DM1.ArcDBFile;
    QryCli.IB_Connection := DM1.DBAzienda;
    QryCli.SQL.Add('SELECT RagioneSociale, ClienteFornitore FROM CLIENTI WHERE CODICE = ' + QryDocumentoRIFSOGG1_CODICE.AsString);
    QryCli.Open;
    if not QryCli.Eof then
    begin
      QryDocumentoRIFSOGG1_TIPO.Value := QryCli.FieldByName('CLIENTEFORNITORE').AsString;
      QryDocumentoRIFSOGG1_RAGIONESOCIALE.Value := QryCli.FieldByName('RAGIONESOCIALE').AsString;
    end;
  finally
    QryCli.Close;
    QryCli.Free;
  end;
end;

procedure TPreventiviOrdiniForm.QryDocumentoRIFSOGG2_CODICEChange(Sender: TField);
var
  QryCli: TIB_Cursor;
begin
  // Carica i dati del cliente
  QryCli := TIB_Cursor.Create(Self);
  try
    QryCli.DatabaseName := DM1.ArcDBFile;
    QryCli.IB_Connection := DM1.DBAzienda;
    QryCli.SQL.Add('SELECT RagioneSociale, ClienteFornitore FROM CLIENTI WHERE CODICE = ' + QryDocumentoRIFSOGG2_CODICE.AsString);
    QryCli.Open;
    if not QryCli.Eof then
    begin
      QryDocumentoRIFSOGG2_TIPO.Value := QryCli.FieldByName('CLIENTEFORNITORE').AsString;
      QryDocumentoRIFSOGG2_RAGIONESOCIALE.Value := QryCli.FieldByName('RAGIONESOCIALE').AsString;
    end;
  finally
    QryCli.Close;
    QryCli.Free;
  end;
end;

procedure TPreventiviOrdiniForm.QryDocumentoRIFSOGG3_CODICEChange(Sender: TField);
var
  QryCli: TIB_Cursor;
begin
  // Carica i dati del cliente
  QryCli := TIB_Cursor.Create(Self);
  try
    QryCli.DatabaseName := DM1.ArcDBFile;
    QryCli.IB_Connection := DM1.DBAzienda;
    QryCli.SQL.Add('SELECT RagioneSociale, ClienteFornitore FROM CLIENTI WHERE CODICE = ' + QryDocumentoRIFSOGG3_CODICE.AsString);
    QryCli.Open;
    if not QryCli.Eof then
    begin
      QryDocumentoRIFSOGG3_TIPO.Value := QryCli.FieldByName('CLIENTEFORNITORE').AsString;
      QryDocumentoRIFSOGG3_RAGIONESOCIALE.Value := QryCli.FieldByName('RAGIONESOCIALE').AsString;
    end;
  finally
    QryCli.Close;
    QryCli.Free;
  end;
end;

procedure TPreventiviOrdiniForm.QryDocumentoRIFSOGG4_CODICEChange(Sender: TField);
var
  QryCli: TIB_Cursor;
begin
  // Carica i dati del cliente
  QryCli := TIB_Cursor.Create(Self);
  try
    QryCli.DatabaseName := DM1.ArcDBFile;
    QryCli.IB_Connection := DM1.DBAzienda;
    QryCli.SQL.Add('SELECT RagioneSociale, ClienteFornitore FROM CLIENTI WHERE CODICE = ' + QryDocumentoRIFSOGG4_CODICE.AsString);
    QryCli.Open;
    if not QryCli.Eof then
    begin
      QryDocumentoRIFSOGG4_TIPO.Value := QryCli.FieldByName('CLIENTEFORNITORE').AsString;
      QryDocumentoRIFSOGG4_RAGIONESOCIALE.Value := QryCli.FieldByName('RAGIONESOCIALE').AsString;
    end;
  finally
    QryCli.Close;
    QryCli.Free;
  end;
end;

procedure TPreventiviOrdiniForm.QryDocumentoRIFSOGG5_CODICEChange(Sender: TField);
var
  QryCli: TIB_Cursor;
begin
  // Carica i dati del cliente
  QryCli := TIB_Cursor.Create(Self);
  try
    QryCli.DatabaseName := DM1.ArcDBFile;
    QryCli.IB_Connection := DM1.DBAzienda;
    QryCli.SQL.Add('SELECT RagioneSociale, ClienteFornitore FROM CLIENTI WHERE CODICE = ' + QryDocumentoRIFSOGG5_CODICE.AsString);
    QryCli.Open;
    if not QryCli.Eof then
    begin
      QryDocumentoRIFSOGG5_TIPO.Value := QryCli.FieldByName('CLIENTEFORNITORE').AsString;
      QryDocumentoRIFSOGG5_RAGIONESOCIALE.Value := QryCli.FieldByName('RAGIONESOCIALE').AsString;
    end;
  finally
    QryCli.Close;
    QryCli.Free;
  end;
end;

procedure TPreventiviOrdiniForm.QryDocumentoRIFSOGG6_CODICEChange(Sender: TField);
var
  QryCli: TIB_Cursor;
begin
  // Carica i dati del cliente
  QryCli := TIB_Cursor.Create(Self);
  try
    QryCli.DatabaseName := DM1.ArcDBFile;
    QryCli.IB_Connection := DM1.DBAzienda;
    QryCli.SQL.Add('SELECT RagioneSociale, ClienteFornitore FROM CLIENTI WHERE CODICE = ' + QryDocumentoRIFSOGG6_CODICE.AsString);
    QryCli.Open;
    if not QryCli.Eof then
    begin
      QryDocumentoRIFSOGG6_TIPO.Value := QryCli.FieldByName('CLIENTEFORNITORE').AsString;
      QryDocumentoRIFSOGG6_RAGIONESOCIALE.Value := QryCli.FieldByName('RAGIONESOCIALE').AsString;
    end;
  finally
    QryCli.Close;
    QryCli.Free;
  end;
end;

procedure TPreventiviOrdiniForm.SBImportPalmareClick(Sender: TObject);
var
  First: Integer;
begin
  DM1.ShowWait('Importazione Palmare', 'Operazione in corso...');
  try
    SBImportPalmare.Enabled := False;
    SBImportPalmare.Update;
    MainForm.SBImportPalmare.Enabled := False;
    MainForm.SBImportPalmare.Update;
    First := Zebex_2031_ScaricaArticoliInBacheca(1, 'COM1');
    if First <> 0 then
      ImportaRighiCodiceQtaDallaBacheca('Palmare', '', First, Date, RifEnabled, MainForm.BachecaInsert);
    MainForm.AggiornaDocumentiEsportati;
  finally
    SBImportPalmare.Enabled := True;
    SBImportPalmare.Update;
    MainForm.SBImportPalmare.Enabled := True;
    MainForm.SBImportPalmare.Update;
    DM1.CloseWait;
  end;
end;

procedure TPreventiviOrdiniForm.ControllaAbilitazioneImportazionePalmare;
var
  LO: TMemIniFile;
  ButtonVisible, ButtonEnabled: Boolean;
begin
  // Inizializzazione
  SBImportPalmare.Visible := False;
  SBImportPalmare.Enabled := False;
  // Apre il file con i parametri
  LO := TMemIniFile.Create(DM1.CurrDir + 'ExtTerminal.ini');
  try
    // =========================================================================
    // TERMINALE BANCOLINI UNITERMINAL B30
    // -------------------------------------------------------------------------
    // Se è attivata l'importazione dal terminale BANCOLINI_UNITERMINAL_B30 (Fortuzzi)
    ButtonVisible := LO.ReadBool('BANCOLINI_UNITERMINAL_B30', 'ButtonVisible', False) and (not MainForm.IsLevanteLight);
    if ButtonVisible then
    begin
      // Rende visibile il pulsante con l'icona del terminalino e ridirezione l'OnClick del pulsante
      // sul gestore di evento del pulsante originario relativo all'importazione Fortuzzi, così
      // risolvo il problema che il pulsante originario è stato sopraffatto da altri pulsnti.
      // NB: NON CANCELLO IL PULSANTE ORIGINARIO
      SBImportPalmare.OnClick := ExtTermImportClick;
      SBImportPalmare.Enabled := True;
      SBImportPalmare.Visible := True;
      // Esce subito
      Exit;
    end;
    // =========================================================================

    // =========================================================================
    // TERMINALE ZEBEX 2031
    // -------------------------------------------------------------------------
    ButtonVisible := LO.ReadBool('ZEBEX_2031', 'ButtonVisible', False) and (not MainForm.IsLevanteLight);
    if ButtonVisible then
    begin
      SBImportPalmare.Enabled := LO.ReadBool('ZEBEX_2031', 'ButtonEnabled', False);
      SBImportPalmare.Visible := True;
      Exit;
    end;
    // =========================================================================

    {
      // Se deve essere attivo il terminale portatile ZEBEX_2031...
      SBImportPalmare.Visible := LO.ReadBool('ZEBEX_2031', 'ButtonVisible', True);
      SBImportPalmare.Enabled := LO.ReadBool('ZEBEX_2031', 'ButtonEnabled', False) and (not MainForm.IsLevanteLight);
      // Terminale Bancolini (Fortuzzi)
      ExtTermImport.Visible   := LO.ReadBool('BANCOLINI_UNITERMINAL_B30', 'ButtonVisible', False) and (not MainForm.IsLevanteLight);
    }
  finally
    LO.Free;
  end;
end;

procedure TPreventiviOrdiniForm.RicalcolaMarginePerModificaPrzVend(i: Integer; DC: TcxCustomDataController);
var
  ImportoMargine, PrezzoScontato, LPrzAcq: Double;
begin
  with DC do
  begin
    // Controlla che il prezzo di acquisto sia > 0 poi calcola il margine
    LPrzAcq := DM1.NoNullFloatValue(DC, i, tvCorpoPREZZOACQUISTOARTICOLO.Index);
    if LPrzAcq > 0 then
    begin
      // Calcola il prezzo unitario scontato
      PrezzoScontato := CalcolaPrezzoScontato(DM1.NoNullFloatValue(DC, i, tvCorpoPREZZOUNITARIO.Index), DM1.NoNullFloatValue(DC, i, tvCorpoSCONTORIGO.Index),
        DM1.NoNullFloatValue(DC, i, tvCorpoSCONTORIGO2.Index), DM1.NoNullFloatValue(DC, i, tvCorpoSCONTORIGO3.Index));
      // Calcola l'importo del margine: ImpMarg := PrezzoUnitarioScontato - PrzUnitAcquisto
      ImportoMargine := PrezzoScontato - LPrzAcq;
      // Calcola la % del margine: M% := ImpMarg * 100 / PAcq
      Values[i, tvCorpoMARGINE.Index] := DM1.Arrotonda(ImportoMargine * 100 / LPrzAcq, 2);
    end;
  end;
end;

procedure TPreventiviOrdiniForm.RichiediCantiereTouchScreen;
begin
  if VendBancoSeleCantForm = nil then
  begin
    Application.CreateForm(TVendBancoSeleCantForm, VendBancoSeleCantForm);
    VendBancoSeleCantForm.Parent := MainForm;
  end;
  VendBancoSeleCantForm.FormResize(VendBancoSeleCantForm);
  VendBancoSeleCantForm.Show;
end;

procedure TPreventiviOrdiniForm.tvOreOPERAINDEXGetDataText(Sender: TcxCustomGridTableItem; ARecordIndex: Integer; var AText: String);
begin
  AText := RightStr(AText, 1);
  // IN questo modo funziona anche quando la colonna è raggruppata
  if AText = '' then
    Exit;
  AText := AText + ' - ' + DM1.Manodopera[StrToInt(AText)].Descrizione;
  // NB: Mette tre spazio all'inizio perchè altrimenti non mi visualizza il numero iniziale
  // praticamente è come se si mangiasse il primo carattere solo quando la colonna
  // è raggruppata.
  if tvOreOPERAINDEX.GroupIndex <> -1 then
    AText := '   ' + AText;
end;

procedure TPreventiviOrdiniForm.Button1Click(Sender: TObject);
var
  LStrings: TStringList;
  LStr: String;
  LInvoice: IeiInvoiceMini;
begin
  LStrings := TStringList.Create;
  LStrings.LoadFromFile('c:\Test_Bad2.xml', TEncoding.UTF8);

  LStr := LStrings.Text;

  LStr := TeiSanitizer.SanitizeXMLStructure(LStr);

  LStrings.Text := LStr;
  LStrings.SaveToFile('c:\Sanitized.xml', TEncoding.UTF8);

  LInvoice := TeiInvoiceMiniFactory.NewInvoiceFromString(LStr);
  Sleep(100);
end;

procedure TPreventiviOrdiniForm.Button2Click(Sender: TObject);
begin
  PropertiesStore.StoreTo;
end;

function TPreventiviOrdiniForm.GetStmPref_FullPathIniFileName: String;
begin
  Result := DM1.CartellaTmp + StmPref_IniFileName;
end;

function TPreventiviOrdiniForm.GetStmPref_IniFileName: String;
begin
  Result := fStmPref_FileName + '.ini';
end;

function TPreventiviOrdiniForm.GetStmPref_CompressedFileName: String;
begin
  Result := fStmPref_FileName + '.zlb';
end;

function TPreventiviOrdiniForm.GetStmPref_FullPathCompressedFileName: String;
begin
  Result := DM1.CartellaTmp + StmPref_CompressedFileName;
end;

procedure TPreventiviOrdiniForm.StmPrzIvaCompClick(Sender: TObject);
begin
  // Imposta il documento per essere IVA compresa
  with Sender as TcxRadioButton do
  begin
    if Checked then
      StmPref_SetIvaCompresa(True);
  end;
end;

procedure TPreventiviOrdiniForm.StmPrzIvaEsclClick(Sender: TObject);
begin
  // Imposta il documento per essere IVA compresa
  with Sender as TcxRadioButton do
  begin
    if Checked then
      StmPref_SetIvaEsclusa(True);
  end;
end;

procedure TPreventiviOrdiniForm.StmTotIvaEsclClick(Sender: TObject);
begin
  if StmTotIvaEscl.Checked then
  Begin
    // Se sono selezionati i prezzi IVA esclusa non ha senso
    // che nei righi ci siano i prezzi IVA compresa e quindi li cambia
    // e disabilita la possibilità di selezione
    StmPrzIvaEscl.Checked := True;
  end;
end;

procedure TPreventiviOrdiniForm.MenuStampePopup(Sender: TObject);
begin
  Stampadocumento1.Enabled := True;
  Stampadocumentoconesplosionearticolicomposti1.Enabled := True and not MainForm.IsLevanteLight;
  Stampaleetichettedegliarticolideldocumento1.Enabled := True and not MainForm.IsLevanteLight;
end;

procedure TPreventiviOrdiniForm.DBEditProtocolloEnter(Sender: TObject);
begin
  if RxSpeedModifica.Down then
    (Sender as TcxDBTextEdit).Style.Color := COLOR_FOCUS;
  ActiveControlName := (Sender as TcxDBTextEdit).Name;
end;

procedure TPreventiviOrdiniForm.DBEditProtocolloExit(Sender: TObject);
begin
  // Azzera il nome del controllo attivo
  ActiveControlName := '';

  if (Sender as TcxDBTextEdit).Style.Color = COLOR_FOCUS then
    (Sender as TcxDBTextEdit).Style.Color := ShapeDocumento.Brush.Color;
end;

procedure TPreventiviOrdiniForm.Button6Click(Sender: TObject);
var
  AView: TcxGridTableView;
  i, ii: Integer;
  DC: TcxCustomDataController;
  AMemo: TcxMemo;
  OutStr: String;
begin
  OutStr := 'Descrizione:';
  AView := tvCorpo;
  DC := AView.DataController;
  for i := 0 to DC.RecordCount - 1 do
  begin
    AView.Controller.FocusedRecordIndex := i;
    AView.Controller.EditingController.ShowEdit(tvCorpoDESCRIZIONE);
    AMemo := TcxMemo(AView.Controller.EditingController.Edit);
    for ii := 0 to AMemo.Lines.Count - 1 do
    begin
      OutStr := OutStr + #13 + AMemo.Lines[ii];
    end;
    ShowMessage(OutStr);
  end;
end;

procedure TPreventiviOrdiniForm.QryDocumentoRITACCIMPONIBILEGetText(Sender: TField; var Text: String; DisplayText: Boolean);
begin
  DisplayText := True;
  if Sender.IsNull or (Sender.AsCurrency = 0) then
    Text := ''
  else
    Text := CurrToStrF(Sender.AsCurrency, ffCurrency, FormatSettings.CurrencyDecimals);
end;

procedure TPreventiviOrdiniForm.QryDocumentoRITACCSUPERCIMPValidate(Sender: TField);
begin
  QryDocumentoRITACCSUIMPORTOIMP.OnValidate := nil;
  try
    if QryDocumentoRITACCSUPERCIMP.AsString = 'F' then
    begin
      QryDocumentoRITACCSUIMPORTOIMP.Value := 'T';
    end
    else
    begin
      QryDocumentoRITACCSUIMPORTOIMP.Value := 'F';
    end;
    SetRitAccVisiblesFields;
    // Richiama l'evento che ricalcola i totali e la ritenuta d'acconto stessa
    QryDocumentoRicalcolaDocumentoEventHandler(Sender);
  finally
    QryDocumentoRITACCSUIMPORTOIMP.OnValidate := QryDocumentoRITACCSUIMPORTOIMPValidate;
  end;
end;

procedure TPreventiviOrdiniForm.QryDocumentoRITACCSUIMPORTOIMPValidate(Sender: TField);
begin
  QryDocumentoRITACCSUPERCIMP.OnValidate := nil;
  try
    if QryDocumentoRITACCSUIMPORTOIMP.AsString = 'F' then
    begin
      QryDocumentoRITACCSUPERCIMP.Value := 'T';
    end
    else
    begin
      QryDocumentoRITACCSUPERCIMP.Value := 'F';
    end;
    SetRitAccVisiblesFields;
    // Richiama l'evento che ricalcola i totali e la ritenuta d'acconto stessa
    QryDocumentoRicalcolaDocumentoEventHandler(Sender);
  finally
    QryDocumentoRITACCSUPERCIMP.OnValidate := QryDocumentoRITACCSUPERCIMPValidate;
  end;
end;

procedure TPreventiviOrdiniForm.SetRitAccVisiblesFields;
begin
  DBEdit2.Visible := (QryDocumentoRITACCSUPERCIMP.AsString <> 'T');
  DBEdit14.Visible := not DBEdit2.Visible;
end;

procedure TPreventiviOrdiniForm.EsportaTesto1Click(Sender: TObject);
begin
  MainForm.EsportaDocumentoSilent(QryDocumentoTIPODOCUMENTO.AsString, QryDocumentoNUMORDPREV.AsInteger, QryDocumentoREGISTRO.AsString,
    QryDocumentoDATADOCUMENTO.AsDateTime, 'TEXT', True);
end;

procedure TPreventiviOrdiniForm.EsportaExcel1Click(Sender: TObject);
begin
  MainForm.EsportaDocumentoSilent(QryDocumentoTIPODOCUMENTO.AsString, QryDocumentoNUMORDPREV.AsInteger, QryDocumentoREGISTRO.AsString,
    QryDocumentoDATADOCUMENTO.AsDateTime, 'EXCEL', True);
end;

procedure TPreventiviOrdiniForm.EsportagrigliacorpodocumentoinformatoExcel1Click(Sender: TObject);
var
  FileNameNoExt: String;
begin
  // Richiede all'utente il nome del file
  // NB: Prima azzera il nome del file
  DM1.ExcelSaveDialog.FileName := '';
  if DM1.ExcelSaveDialog.Execute then
  begin
    FileNameNoExt := LeftStr(DM1.ExcelSaveDialog.FileName, (Length(DM1.ExcelSaveDialog.FileName) - Length(ExtractFileExt(DM1.ExcelSaveDialog.FileName))));
    // Verifica che il file non esista già, e se esiste chiede se lo si vuole sovrascrivere
    if FileExists(FileNameNoExt + '.xls') then
    begin
      if DM1.Messaggi('Esportazione', 'File già esistente !!!'#13#13'Devo proseguire e sovrascrivere il file?',
        'NB: Rispondendo "SI" e quindi sovrascrivendo il file esistente i dati in esso contenuti saranno perduti.', [mbYes, mbNo], 0, nil) <> mrYes then
        Exit;
    end;
    // Informa l'utente
    DM1.ShowWait('Esportazione Excel', 'Operazione in corso...');
    try
      GridCorpo.BeginUpdate;
      try;
        ExportGridToExcel(FileNameNoExt, // FileName senza estensione
          GridCorpo, // cxGrid
          False, // AExpand
          True, // ASaveAll
          False, // AUseNativeFOrmat
          'xls' // AFileExt
          );
      finally
        GridCorpo.EndUpdate;
      end;
    finally
      DM1.CloseWait;
      DM1.Messaggi('Levante - Esportazione dati', 'Operazione terminata.', '', [mbOk], 0, nil);
    end;
  end;
end;

procedure TPreventiviOrdiniForm.BitBtnMagazzino2Click(Sender: TObject);
begin
  DM1.Attendere;
  try
    // Visualizza la form che permette di selezionare il magazzino da inserire nel documento
    Application.CreateForm(TAnagMagaForm, AnagMagaForm);
    MainForm.SetParentComponent(AnagMagaForm);
    AnagMagaForm.Tag := 993; // Abilita la seleziona dell'aliquota IVA
    AnagMagaForm.Show;
  finally
    DM1.ChiudiAttendere;
  end;
end;

procedure TPreventiviOrdiniForm.Aggiornaiprezzideirighiselezionati1Click(Sender: TObject);
begin
  // Chiede prima conferma
  MessageBeep(0);
  if MessageDlg('Sei sicuro/a ?', mtWarning, [mbOk, mbNo], 0) = mrOk then
  begin
    DM1.Attendere;
    try
      AggiornaPrezziDocumento(tvCorpo.DataController, True);
      // Se abilitato e necessario ricalcola i totali del documento
      CalcolaTotali(False);
    finally
      DM1.ChiudiAttendere;
    end;
  end;
end;

procedure TPreventiviOrdiniForm.AggiornairicarichiperfascedicostoSOLORIGHISELEZIONATI1Click(Sender: TObject);
begin
  if DM1.Messaggi('Aggiorna ricarichi per fasce di costo', 'Proseguire con l''operazione?', '', [mbYes, mbNo], 0, nil) <> mrYes
  then
    Exit;
  DM1.ShowWait('Aggiorna ricarichi per fasce di costo', 'Operazione in corso...');
  try
    AggiornaRicarichiPerFasceDiCosto(tvCorpo.DataController, True);
  finally
    DM1.CloseWait;
  end;
end;

procedure TPreventiviOrdiniForm.AggiornairicarichiperfascedicostoTUTTIIRIGHI1Click(Sender: TObject);
begin
  if DM1.Messaggi('Aggiorna ricarichi per fasce di costo', 'Proseguire con l''operazione?', '', [mbYes, mbNo], 0, nil) <> mrYes
  then
    Exit;
  DM1.ShowWait('Aggiorna ricarichi per fasce di costo', 'Operazione in corso...');
  try
    AggiornaRicarichiPerFasceDiCosto(tvCorpo.DataController, False);
  finally
    DM1.CloseWait;
  end;
end;

procedure TPreventiviOrdiniForm.SetBodyScreenState(const Value: TBodyScreenState);
begin
  fBodyScreenState := Value;

  // Se siamo in modalità FullStretched...
  if Value = bssFullStretched then
  begin
    PanelCorpoDoc.Parent := TabFullBody;
    PanelCorpoDoc.Align := alClient;
    TabFullBody.TabVisible := True;
    TabDoc.TabVisible := False;
    ClientArea.ActivePage := TabFullBody;
    // Se invece non siamo in modalità FullStretched
  end
  else
  begin
    PanelCorpoDoc.Parent := DocClientArea;
    PanelCorpoDoc.Align := alNone;
    TabFullBody.TabVisible := False;
    TabDoc.TabVisible := True;
    ClientArea.ActivePage := TabDoc;
  end;

  // Richiama il gestore di evento onResize della Form per attuare le necessarie
  // modifiche alla visualizzazione del corpo documento
  FormResize(Self);

  // Mette in Down il pulsante relativo
  sbBodyNormal.Down := (Value = bssNormal);
  sbBodyHorzStretched.Down := (Value = bssHorzStretched);
  sbBodyFullStretched.Down := (Value = bssFullStretched);
end;

procedure TPreventiviOrdiniForm.sbBodyNormalClick(Sender: TObject);
begin
  if (Sender as TSpeedButton).Down then
    BodyScreenState := bssNormal;
end;

procedure TPreventiviOrdiniForm.sbBodyHorzStretchedClick(Sender: TObject);
begin
  if (Sender as TSpeedButton).Down then
    BodyScreenState := bssHorzStretched;
end;

procedure TPreventiviOrdiniForm.sbBodyFullStretchedClick(Sender: TObject);
begin
  if (Sender as TSpeedButton).Down then
    BodyScreenState := bssFullStretched;
end;

procedure TPreventiviOrdiniForm.PanelAddArtResize(Sender: TObject);
begin
  // Fa in modo che il pannello selettore della modalità di visualizzazione
  // del corpo documento sia sempre al centro
  // PanelBodyStateSelector.Left := Trunc((PanelAddArt.ClientWidth - PanelBodyStateSelector.Width) / 2) + 5;
end;

procedure TPreventiviOrdiniForm.Mostralacolonnadelcodicearticoloreale1Click(Sender: TObject);
var
  CurrMenuItem: TMenuItem;
begin
  // MOstra/nasconde la colonna del Codice Articolo reale.
  CurrMenuItem := (Sender as TMenuItem);
  CurrMenuItem.Checked := not CurrMenuItem.Checked;
  tvCorpoCODICEARTICOLO.Visible := CurrMenuItem.Checked;
  tvDiBaCODICEARTICOLO.Visible := CurrMenuItem.Checked;
end;

procedure TPreventiviOrdiniForm.TimerDocStateTimer(Sender: TObject);
var
  TV: TcxGridTableView;
begin
  // Se il focus non è sull griglia del corpo documento esce subito.
  // Anche se siamo su una TableView (Non sulla CardView)
  if (not GridCorpo.IsFocused) or (not(GridCorpo.FocusedView is TcxGridTableView)) then
  begin
    RxSpeedButtonTrova.Enabled := False;
    Exit;
  end;
  with GridCorpo.FocusedView as TcxGridTableView do
  begin
    // Se non siamo in editing...
    if Controller.EditingItem = nil then
    begin
      RxSpeedButtonTrova.Enabled := False;
      Exit;
    end;
    // Se siamo in editing del CodiceArticolo attiva il pulsante "Trova"
    RxSpeedButtonTrova.Enabled := (Controller.EditingItem.Index = tvCorpoCODICEARTICOLO.Index) or
      (Controller.EditingItem.Index = tvCorpoCODICEARTICOLOSTM.Index) or (Controller.EditingItem.Index = tvCorpoDESCRIZIONE.Index);
  end;
end;

procedure TPreventiviOrdiniForm.DBERagSocCliEnter(Sender: TObject);
begin
  // Attiva il pulsante F5 Trova (se si è in modalità di modifica
  if RxSpeedModifica.Down then
    RxSpeedButtonTrova.Enabled := True;
  // RIchiama la gestione dell'evento che colora il campo in editing di giallo
  DBEdit1Enter(Sender);
end;

procedure TPreventiviOrdiniForm.DBERagSocCliExit(Sender: TObject);
begin
  // Attiva il pulsante F5 Trova (se si è in modalità di modifica
  if RxSpeedModifica.Down then
    RxSpeedButtonTrova.Enabled := False;
  // RIchiama la gestione dell'evento che colora il campo in editing di giallo
  DBEdit1Exit(Sender);
end;

procedure TPreventiviOrdiniForm.GridCorpoEnter(Sender: TObject);
begin
  // Attiva il timer per la gestione del pulsante "TROVA" quando si è
  // in editing del codicearticolo eltri campi all'interno della griglia.
  TimerDocState.Enabled := True;
  // RIchiama la gestione dell'evento che colora il campo in editing di giallo
  DBEdit1Enter(Sender);
end;

procedure TPreventiviOrdiniForm.GridCorpoExit(Sender: TObject);
begin
  // Disattiva il timer per la gestione del pulsante "TROVA" quando si è
  // in editing del codicearticolo eltri campi all'interno della griglia.
  TimerDocState.Enabled := False;
  // Se il pulsante Trova è attivo lo disablità altrimenti in alcune situazioni rimaneva attiva
  if RxSpeedButtonTrova.Enabled then
    RxSpeedButtonTrova.Enabled := False;
  // RIchiama la gestione dell'evento che colora il campo in editing di giallo
  DBEdit1Exit(Sender);
end;

procedure TPreventiviOrdiniForm.GridCorpoFocusedViewChanged(Sender: TcxCustomGrid; APrevFocusedView, AFocusedView: TcxCustomGridView);
begin
  // Così quando mi sposto in un'altra vista sparisce la selezione in quella da cui si sta uscendo,
  // prima invece rimaneva ma non mi piaceva
  if Assigned(APrevFocusedView) then
    APrevFocusedView.DataController.ClearSelection;
end;

procedure TPreventiviOrdiniForm.SBTrovaArtClick(Sender: TObject);
begin
  // Apre l'elenco articoli, imposta i filtri inserendo il valore attuale del campo ed esegue automaticamente la ricerca
  DM1.SelezionaArticolo('', Trim(TrovaArt.Text), AM_Append, 0, QryDocumentoPRATICA.AsInteger, QryDocumentoDATAPRATICA1.AsDateTime);
end;

procedure TPreventiviOrdiniForm.TrovaArtKeyUp(Sender: TObject; var Key: Word; Shift: TShiftState);
begin
  // Se non si è in modalità di modifica annulla qualunque inserimento
  if RxSpeedModifica.Down then
  begin
    // Se viene premuto il pulsante INVIO preme il pulsante aggiungi
    if Key = 13 then
    begin
      SBTrovaArtClick(Self);
    end;
  end;
end;

procedure TPreventiviOrdiniForm.TrovaArtChange(Sender: TObject);
begin
  // Abilita il pulsante aggiungi solo se l'utente ha inserito qualcosa nel
  // campo apposito
  SBTrovaArt.Enabled := (TrovaArt.Text <> '');
end;

procedure TPreventiviOrdiniForm.QryDocumentoAGENTEChange(Sender: TField);
begin
  // Se c'è un documento collegato lo aggiorna
  if Self.IsImpegno and (ImpegnoForm.QryImp.State <> dsBrowse) then
  begin
    QryDocumentoAGENTE.OnChange := nil;
    if QryDocumentoAGENTE.IsNull then
      ImpegnoForm.QryImpAGENTE.Clear
    else
      ImpegnoForm.QryImpAGENTE.Value := QryDocumentoAGENTE.Value;
    QryDocumentoAGENTE.OnChange := QryDocumentoAGENTEChange;
  end;
end;

procedure TPreventiviOrdiniForm.QryDocumentoAGENTE2Change(Sender: TField);
begin
  // Se c'è un documento collegato lo aggiorna
  if Self.IsImpegno and (ImpegnoForm.QryImp.State <> dsBrowse) then
  begin
    QryDocumentoAGENTE2.OnChange := nil;
    if QryDocumentoAGENTE2.IsNull then
      ImpegnoForm.QryImpAGENTE2.Clear
    else
      ImpegnoForm.QryImpAGENTE2.Value := QryDocumentoAGENTE2.Value;
    QryDocumentoAGENTE2.OnChange := QryDocumentoAGENTE2Change;
  end;
end;

procedure TPreventiviOrdiniForm.QryDocumentoAGENTE3Change(Sender: TField);
begin
  // Se c'è un documento collegato lo aggiorna
  if Self.IsImpegno and (ImpegnoForm.QryImp.State <> dsBrowse) then
  begin
    QryDocumentoAGENTE3.OnChange := nil;
    if QryDocumentoAGENTE3.IsNull then
      ImpegnoForm.QryImpAGENTE3.Clear
    else
      ImpegnoForm.QryImpAGENTE3.Value := QryDocumentoAGENTE3.Value;
    QryDocumentoAGENTE3.OnChange := QryDocumentoAGENTE3Change;
  end;
end;

procedure TPreventiviOrdiniForm.QryDocumentoAGENTE4Change(Sender: TField);
begin
  // Se c'è un documento collegato lo aggiorna
  if Self.IsImpegno and (ImpegnoForm.QryImp.State <> dsBrowse) then
  begin
    QryDocumentoAGENTE4.OnChange := nil;
    if QryDocumentoAGENTE4.IsNull then
      ImpegnoForm.QryImpAGENTE4.Clear
    else
      ImpegnoForm.QryImpAGENTE4.Value := QryDocumentoAGENTE4.Value;
    QryDocumentoAGENTE4.OnChange := QryDocumentoAGENTE4Change;
  end;
end;

procedure TPreventiviOrdiniForm.SbRifSogg7Click(Sender: TObject);
begin
  DM1.SelezionaCliente(QryDocumentoRIFSOGG7_CODICE, nil, nil, '');
end;

procedure TPreventiviOrdiniForm.SbRifSogg8Click(Sender: TObject);
begin
  DM1.SelezionaCliente(QryDocumentoRIFSOGG8_CODICE, nil, nil, '');
end;

procedure TPreventiviOrdiniForm.SbRifSogg9Click(Sender: TObject);
begin
  DM1.SelezionaCliente(QryDocumentoRIFSOGG9_CODICE, nil, nil, '');
end;

procedure TPreventiviOrdiniForm.SbRifSogg10Click(Sender: TObject);
begin
  DM1.SelezionaCliente(QryDocumentoRIFSOGG10_CODICE, nil, nil, '');
end;

procedure TPreventiviOrdiniForm.QryDocumentoRIFSOGG7_CODICEChange(Sender: TField);
var
  QryCli: TIB_Cursor;
begin
  // Carica i dati del cliente
  QryCli := TIB_Cursor.Create(Self);
  try
    QryCli.DatabaseName := DM1.ArcDBFile;
    QryCli.IB_Connection := DM1.DBAzienda;
    QryCli.SQL.Add('SELECT RagioneSociale, ClienteFornitore FROM CLIENTI WHERE CODICE = ' + QryDocumentoRIFSOGG7_CODICE.AsString);
    QryCli.Open;
    if not QryCli.Eof then
    begin
      QryDocumentoRIFSOGG7_TIPO.Value := QryCli.FieldByName('CLIENTEFORNITORE').AsString;
      QryDocumentoRIFSOGG7_RAGIONESOCIALE.Value := QryCli.FieldByName('RAGIONESOCIALE').AsString;
    end;
  finally
    QryCli.Close;
    QryCli.Free;
  end;
end;

procedure TPreventiviOrdiniForm.QryDocumentoRIFSOGG8_CODICEChange(Sender: TField);
var
  QryCli: TIB_Cursor;
begin
  // Carica i dati del cliente
  QryCli := TIB_Cursor.Create(Self);
  try
    QryCli.DatabaseName := DM1.ArcDBFile;
    QryCli.IB_Connection := DM1.DBAzienda;
    QryCli.SQL.Add('SELECT RagioneSociale, ClienteFornitore FROM CLIENTI WHERE CODICE = ' + QryDocumentoRIFSOGG8_CODICE.AsString);
    QryCli.Open;
    if not QryCli.Eof then
    begin
      QryDocumentoRIFSOGG8_TIPO.Value := QryCli.FieldByName('CLIENTEFORNITORE').AsString;
      QryDocumentoRIFSOGG8_RAGIONESOCIALE.Value := QryCli.FieldByName('RAGIONESOCIALE').AsString;
    end;
  finally
    QryCli.Close;
    QryCli.Free;
  end;
end;

procedure TPreventiviOrdiniForm.QryDocumentoRIFSOGG9_CODICEChange(Sender: TField);
var
  QryCli: TIB_Cursor;
begin
  // Carica i dati del cliente
  QryCli := TIB_Cursor.Create(Self);
  try
    QryCli.DatabaseName := DM1.ArcDBFile;
    QryCli.IB_Connection := DM1.DBAzienda;
    QryCli.SQL.Add('SELECT RagioneSociale, ClienteFornitore FROM CLIENTI WHERE CODICE = ' + QryDocumentoRIFSOGG9_CODICE.AsString);
    QryCli.Open;
    if not QryCli.Eof then
    begin
      QryDocumentoRIFSOGG9_TIPO.Value := QryCli.FieldByName('CLIENTEFORNITORE').AsString;
      QryDocumentoRIFSOGG9_RAGIONESOCIALE.Value := QryCli.FieldByName('RAGIONESOCIALE').AsString;
    end;
  finally
    QryCli.Close;
    QryCli.Free;
  end;
end;

procedure TPreventiviOrdiniForm.QryDocumentoRIFSOGG10_CODICEChange(Sender: TField);
var
  QryCli: TIB_Cursor;
begin
  // Carica i dati del cliente
  QryCli := TIB_Cursor.Create(Self);
  try
    QryCli.DatabaseName := DM1.ArcDBFile;
    QryCli.IB_Connection := DM1.DBAzienda;
    QryCli.SQL.Add('SELECT RagioneSociale, ClienteFornitore FROM CLIENTI WHERE CODICE = ' + QryDocumentoRIFSOGG10_CODICE.AsString);
    QryCli.Open;
    if not QryCli.Eof then
    begin
      QryDocumentoRIFSOGG10_TIPO.Value := QryCli.FieldByName('CLIENTEFORNITORE').AsString;
      QryDocumentoRIFSOGG10_RAGIONESOCIALE.Value := QryCli.FieldByName('RAGIONESOCIALE').AsString;
    end;
  finally
    QryCli.Close;
    QryCli.Free;
  end;
end;

procedure TPreventiviOrdiniForm.FormDestroy(Sender: TObject);
begin
  // Senza questo codice mi da un errore alla distruzione della Form
  if fAllegatiForm <> nil then
  begin
    fAllegatiForm.Free;
  end;
end;

procedure TPreventiviOrdiniForm.tvOreSOTTOCANTIERE1PropertiesInitPopup(Sender: TObject);
begin
  (Sender as TcxComboBox).Properties.Assign(tvCorpoSOTTOCANTIERE1.Properties);
end;

procedure TPreventiviOrdiniForm.tvOreSOTTOCANTIERE2PropertiesInitPopup(Sender: TObject);
begin
  (Sender as TcxComboBox).Properties.Assign(tvCorpoSOTTOCANTIERE2.Properties);
end;

procedure TPreventiviOrdiniForm.tvOreSOTTOCANTIERE3PropertiesInitPopup(Sender: TObject);
begin
  (Sender as TcxComboBox).Properties.Assign(tvCorpoSOTTOCANTIERE3.Properties);
end;

procedure TPreventiviOrdiniForm.tvOreDataControllerDataChanged(Sender: TObject);
var
  MDC: TcxCustomDataController;
  MRI: Integer;
begin
  // Inizializzazione
  MDC := (Sender as TcxCustomDataController).GetMasterDataController;
  MRI := (Sender as TcxCustomDataController).GetMasterRecordIndex;
  // Azzera i sottocantieri del rigo principale
  MDC.Values[MRI, tvCorpoSOTTOCANTIERE1.Index] := NULL;
  MDC.Values[MRI, tvCorpoSOTTOCANTIERE2.Index] := NULL;
  MDC.Values[MRI, tvCorpoSOTTOCANTIERE3.Index] := NULL;
end;

procedure TPreventiviOrdiniForm.Inversionecodiciarticolo1Click(Sender: TObject);
var
  i: Integer;
  DC: TcxCustomDataController;
  Tmp: Variant;
begin
  // Chiede conferma all'operatore
  if DM1.Messaggi('Inversione codici articolo', 'Invertire i codici articolo?', '', [mbYes, mbNo], 0, nil) <> mrYes then
    Exit;
  // Inizializzazione
  DC := tvCorpo.DataController;
  // Disabilita l'aggiornamento dello schermo
  tvCorpo.BeginUpdate;
  try
    // Informa l'operatore
    DM1.ShowWait('Levante', 'Operazione in corso...');
    // Cicla per tutti i righi del documento
    for i := 0 to DC.RecordCount - 1 do
    begin
      // PArcheggio in TmpStr il CODICEARTICOLO
      Tmp := DC.Values[i, tvCorpoCODICEARTICOLO.Index];
      // Copio il CODICEARTICOLOSTM nel CODICEARTICOLO
      DC.Values[i, tvCorpoCODICEARTICOLO.Index] := DC.Values[i, tvCorpoCODICEARTICOLOSTM.Index];
      // Copia il CODICEARTICOLO nel CODICEARTICOLOSTM
      DC.Values[i, tvCorpoCODICEARTICOLOSTM.Index] := Tmp;
    end;
    // Pulizie finali
  finally
    DM1.CloseWait;
    tvCorpo.EndUpdate;
  end;
end;

procedure TPreventiviOrdiniForm.dbeRifDoc_RegDocPropertiesInitPopup(Sender: TObject);
var
  Qry: TIB_Cursor;
begin
  // Crea la query che fornirà l'elenco dei registri disponibili
  Qry := TIB_Cursor.Create(Self);
  try
    Qry.DatabaseName := DM1.ArcDBFile;
    Qry.IB_Connection := DM1.DBAzienda;
    Qry.SQL.Add('SELECT Registro FROM ProgReg');
    Qry.Open;
    // Carica i registri nelle items del componente
    dbeRifDoc_RegDoc.Properties.Items.Clear;
    dbeRifDoc_RegDoc.Properties.Items.Add('');
    while not Qry.Eof do
    begin
      dbeRifDoc_RegDoc.Properties.Items.Add(Qry.FieldByName('Registro').Value);
      Qry.Next;
    end;
  finally
    Qry.Close;
    Qry.Free;
  end;
end;

procedure TPreventiviOrdiniForm.TabControlPagineDocumentoChange(Sender: TObject);
begin
  // In base al tab selezionato dall'utente...
  case (Sender as TcxTabControl).TabIndex of
    // ----- Tab Appuntamento
    DOCTABIDX_APPUNTAMENTO:
      begin
        ImpegnoForm.TabControlPagineDocumento.TabIndex := DOCTABIDX_APPUNTAMENTO;
        PreventiviOrdiniForm.Hide;
      end;
    // ----- Tab Operazioni pianificate
    DOCTABIDX_OPERAZIONIPIANIFICATE:
      begin
        ImpegnoForm.TabControlPagineDocumento.TabIndex := DOCTABIDX_OPERAZIONIPIANIFICATE;
        PreventiviOrdiniForm.Hide;
      end;
    // ----- Tab Interventi precedenti
    DOCTABIDX_INTERVENTIPRECEDENTI:
      begin
        ImpegnoForm.TabControlPagineDocumento.TabIndex := DOCTABIDX_INTERVENTIPRECEDENTI;
        PreventiviOrdiniForm.Hide;
      end;
    // ----- Tab Allegati
    DOCTABIDX_ALLEGATI:
      begin
        ImpegnoForm.TabControlPagineDocumento.TabIndex := DOCTABIDX_ALLEGATI;
        PreventiviOrdiniForm.Hide;
      end;
    // ----- Tab Mappa
    DOCTABIDX_MAPPA:
      begin
        ImpegnoForm.TabControlPagineDocumento.TabIndex := DOCTABIDX_MAPPA;
        PreventiviOrdiniForm.Hide;
      end;
    // ----- Tab aNAGRAFICA ARTICOLO
    DOCTABIDX_ANAGRAFICAARTICOLO:
      begin
        AnagArtForm.TabControlPagineDocumento.TabIndex := DOCTABIDX_ANAGRAFICAARTICOLO;
        PreventiviOrdiniForm.Hide;
      end;
    // ----------------------
  end;
end;

procedure TPreventiviOrdiniForm.TableViewAllegatiColumn1PropertiesButtonClick(Sender: TObject; AButtonIndex: Integer);
begin
  ShowMessage('Eccolo!!!');
end;

procedure TPreventiviOrdiniForm.ApriQueryApparecchiPratica;
begin
  // Prima chiude la query se è già aperta
  if QryPratApp.Active then
    QryPratApp.Close;
  // Continua solo se il documento fa parte di una pratica
  if QryDocumentoPRATICA.IsNull or (QryDocumentoPRATICA.AsInteger = 0) then
    Exit;
  // Imposta ed apre la query
  if not QryPratApp.Prepared then
    QryPratApp.Prepare;
  QryPratApp.ParamByName('P_PRATICA').AsInteger := QryDocumentoPRATICA.AsInteger;
  QryPratApp.ParamByName('P_DATAPRATICA').AsDateTime := QryDocumentoDATAPRATICA1.AsDateTime;
  QryPratApp.Open;
end;

procedure TPreventiviOrdiniForm.QryDocumentoAfterOpen(DataSet: TDataSet);
begin
  // Riapre la query con i dati degli apparecchi da usare nelle OP
  ApriQueryApparecchiPratica;
end;

procedure TPreventiviOrdiniForm.QryPratAppCalcFields(DataSet: TDataSet);
begin
  // Costruisce la descrizione completa dell'apparecchio da usare poi come riferimento
  // allapparecchio stesso
  QryPratAppCOMPUTED_APPARECCHIO_FULL.Value := Trim(QryPratAppCOSTRUTTORE.AsString + ' ' + QryPratAppMODELLO.AsString + ' (' + QryPratAppMATRICOLA.AsString +
    ') ' + QryPratAppUBICAZIONE.AsString);
end;

// =============================================================================
// INIZIO - PARTE CHE AGGIORNA LE OP NEL DOCUMENTO DALL'IMPEGNO
// -----------------------------------------------------------------------------
// Function che ritorna il numero di record del rigo relativo al contratto e alle prestazioni
// (OP) comprese nel contratto stesso.
function TPreventiviOrdiniForm.OP_RifContratto_GetRecordIndex(const ACreateIsNotExists: Boolean): Integer;
var
  DC: TcxCustomDataController;
begin
  DC := tvCorpo.DataController;
  // Ricerca rigo con marcatore che indica che è il rigo di riferimento al contratto
  Result := tvCorpo.DataController.FindRecordIndexByText(0, tvCorpoROWTYPE.Index, 'RifContratto', False, False, True);
  // Se non lo ha trovato lo cerca con il vecchio marcatore sul codice articolo (per retrocompatibilità)
  if Result = -1 then
    Result := tvCorpo.DataController.FindRecordIndexByText(0, tvCorpoCODICEARTICOLO.Index, '(Abbonamento)', False, False, True); // Vecchia marcatura mantenuta per compatibilità
  // Se non lo ha trovato lo crea nuovo
  if (Result = -1) and ACreateIsNotExists then
    Result := DC.InsertRecord(0);
end;

function TPreventiviOrdiniForm.OP_RifContrattoDicitura_GetRecordIndex(const ACreateIsNotExists: Boolean): Integer;
var
  DC: TcxCustomDataController;
begin
  DC := tvCorpo.DataController;
  // Ricerca rigo con marcatore che indica che è il rigo di riferimento al contratto
  Result := tvCorpo.DataController.FindRecordIndexByText(0, tvCorpoROWTYPE.Index, 'RifContrattoDicitura', False, False, True);
  // Se non lo ha trovato lo crea nuovo
  if (Result = -1) and ACreateIsNotExists then
    Result := DC.InsertRecord(0);
end;

// Procedure che crea, modifica o elimina il record relativo alle prestazioni (OP) in abbonamento
// con il riferimento al contratto e elle OP comprese effettuate
procedure TPreventiviOrdiniForm.OP_RifContratto_Check(const AInAbbonamento, ASetImportoRinnovo: Boolean);
var
  DC: TcxCustomDataController;
  LDescrizione, LNumeroContratto: String;
  LDataContratto: TDate;
  RI: Integer;
begin
  // Verifiche iniziali
  if ImpegnoForm = nil then
    Exit; // Solo se è un documento con una parte appuntamento (quindi un intervento)
  // Inizializzazione
  DC := tvCorpo.DataController;
  // Costruisce il riferimento al contratto (se ci sono i dati)
  LNumeroContratto := ImpegnoForm.QryAssCONTRATTO_NUMERO.AsString.Trim;
  LDataContratto := ImpegnoForm.QryAssCONTRATTO_DATASTIPULA.AsDateTime;
  LDescrizione := '';
  if not LNumeroContratto.IsEmpty then
    LDescrizione := Format('%s n. %s', [LDescrizione, LNumeroContratto]);
  if LDataContratto > 0 then
    LDescrizione := Format('%s del %s', [LDescrizione, FormatDateTime('dd/mm/yyyy', LDataContratto)]);
  if not LDescrizione.IsEmpty then
    LDescrizione := 'Contratto' + LDescrizione;
  // Aggiunge/Elimina il rigo di riferimento al contratto
  if LDescrizione.IsEmpty or not AInAbbonamento then
  begin
    RI := OP_RifContratto_GetRecordIndex(False);
    if RI > (-1) then
      DC.DeleteRecord(RI);
  end
  else
  begin
    RI := OP_RifContratto_GetRecordIndex(True);
    DC.Values[RI, tvCorpoROWTYPE.Index] := 'RifContratto';
    DC.Values[RI, tvCorpoDESCRIZIONE.Index] := LDescrizione;
    DC.Values[RI, tvCorpoCODICEIVA.Index] := ImpegnoForm.QryAssCONTRATTO_CODICEIVA.AsInteger;
    DC.Values[RI, tvCorpoALIQUOTAIVA.Index] := ImpegnoForm.QryAssCONTRATTO_ALIQUOTAIVA.AsInteger;
    DC.Values[RI, tvCorpoDESCRIZIONEIVA.Index] := ImpegnoForm.QryAssCONTRATTO_DESCRIZIONEIVA.AsString;
    // IMposta il codice OP a cui il nuovo rigo fa riferimento = -1 che significa che è il rigo relativo
    // alle OP comprese nell'abbonamento/contratto
    DC.Values[RI, tvCorpoIDOPIMPEGNO.Index] := -1;
    // Se deve aggiungere anche l'importo del rinno del contratto...
    if ASetImportoRinnovo then
    begin
      DC.Values[RI, tvCorpoQTA.Index] := 1;
      if DM1.ScorporoIVA then
      begin
        DC.Values[RI, tvCorpoPREZZOUNITARIOIVACOMPRESA.Index] := ImpegnoForm.QryAssCONTRATTO_IMPORTONETTOIVACOMP.AsFloat;
        DC.Values[RI, tvCorpoSCONTORIGO.Index] := 0;
        DC.Values[RI, tvCorpoSCONTORIGO2.Index] := 0;
        DC.Values[RI, tvCorpoSCONTORIGO3.Index] := 0;
        CalcolaPerModificaPrezzoUnitarioIVACompresa(RI, DC);
      end
      else
      begin
        DC.Values[RI, tvCorpoPREZZOUNITARIO.Index] := ImpegnoForm.QryAssCONTRATTO_IMPORTO.AsFloat;
        DC.Values[RI, tvCorpoSCONTORIGO.Index] := ImpegnoForm.QryAssCONTRATTO_SCONTO1.AsFloat;
        DC.Values[RI, tvCorpoSCONTORIGO2.Index] := ImpegnoForm.QryAssCONTRATTO_SCONTO2.AsFloat;
        DC.Values[RI, tvCorpoSCONTORIGO3.Index] := ImpegnoForm.QryAssCONTRATTO_SCONTO3.AsFloat;
        CalcolaPerModificaPrezzoUnitario(RI, DC);
      end;
      CalcolaImportoRigo(DC, RI);
    end;
  end;
  // Se abilitato e necessario ricalcola i totali del documento
  CalcolaTotali(False);
end;

procedure TPreventiviOrdiniForm.OP_RifContrattoDicitura_Check(const AInAbbonamento, ASetImportoRinnovo: Boolean);
var
  DC: TcxCustomDataController;
  LDescrizione: String;
  RI: Integer;
begin
  // Verifiche iniziali
  if ImpegnoForm = nil then
    Exit; // Solo se è un documento con una parte appuntamento (quindi un intervento)
  // Inizializzazione
  DC := tvCorpo.DataController;
  LDescrizione := ImpegnoForm.QryAssPRM_AUTODOC_DICITURATXT.AsString.Trim;
  // Aggiunge/Elimina il rigo di riferimento al contratto
  if LDescrizione.IsEmpty or not AInAbbonamento then
  begin
    RI := OP_RifContrattoDicitura_GetRecordIndex(False);
    if RI > (-1) then
      DC.DeleteRecord(RI);
  end
  else
  begin
    RI := OP_RifContrattoDicitura_GetRecordIndex(True);
    DC.Values[RI, tvCorpoROWTYPE.Index] := 'RifContrattoDicitura';
    DC.Values[RI, tvCorpoDESCRIZIONE.Index] := LDescrizione;
    DC.Values[RI, tvCorpoCODICEIVA.Index] := ImpegnoForm.QryAssCONTRATTO_CODICEIVA.AsInteger;
    DC.Values[RI, tvCorpoALIQUOTAIVA.Index] := ImpegnoForm.QryAssCONTRATTO_ALIQUOTAIVA.AsInteger;
    DC.Values[RI, tvCorpoDESCRIZIONEIVA.Index] := ImpegnoForm.QryAssCONTRATTO_DESCRIZIONEIVA.AsString;
    // IMposta il codice OP a cui il nuovo rigo fa riferimento = -1 che significa che è il rigo relativo
    // alle OP comprese nell'abbonamento/contratto
    DC.Values[RI, tvCorpoIDOPIMPEGNO.Index] := -1;
    // Se deve aggiungere anche l'importo del rinno del contratto...
    if ASetImportoRinnovo then
    begin
      DC.Values[RI, tvCorpoQTA.Index] := 1;
      if DM1.ScorporoIVA then
      begin
        DC.Values[RI, tvCorpoPREZZOUNITARIOIVACOMPRESA.Index] := ImpegnoForm.QryAssCONTRATTO_IMPORTONETTOIVACOMP.AsFloat;
        DC.Values[RI, tvCorpoSCONTORIGO.Index] := 0;
        DC.Values[RI, tvCorpoSCONTORIGO2.Index] := 0;
        DC.Values[RI, tvCorpoSCONTORIGO3.Index] := 0;
        CalcolaPerModificaPrezzoUnitarioIVACompresa(RI, DC);
      end
      else
      begin
        DC.Values[RI, tvCorpoPREZZOUNITARIO.Index] := ImpegnoForm.QryAssCONTRATTO_IMPORTO.AsFloat;
        DC.Values[RI, tvCorpoSCONTORIGO.Index] := ImpegnoForm.QryAssCONTRATTO_SCONTO1.AsFloat;
        DC.Values[RI, tvCorpoSCONTORIGO2.Index] := ImpegnoForm.QryAssCONTRATTO_SCONTO2.AsFloat;
        DC.Values[RI, tvCorpoSCONTORIGO3.Index] := ImpegnoForm.QryAssCONTRATTO_SCONTO3.AsFloat;
        CalcolaPerModificaPrezzoUnitario(RI, DC);
      end;
      CalcolaImportoRigo(DC, RI);
    end;
  end;
  // Se abilitato e necessario ricalcola i totali del documento
  CalcolaTotali(False);
end;

// FUnction che cerca il primo rigo del documento relativo alla OP e all'apparecchio ricevuti come parametro e ne ritorn
// il Record Index oppure -1 se non lo trova
function TPreventiviOrdiniForm.OP_FindByOpApparecchio(DC: TcxCustomDataController; OP_ID: Integer): Integer;
var
  i: Integer;
begin
  // Inizializzazione
  Result := -1;
  // Cicla per tutti i righi
  for i := 0 to DC.RecordCount - 1 do
  begin
    if (not VarIsNull(DC.Values[i, tvCorpoIDOPIMPEGNO.Index])) and (DC.Values[i, tvCorpoIDOPIMPEGNO.Index] = OP_ID) then
    begin
      Result := i;
      break;
    end;
  end;
end;

// Procedure che Aggiunge/Aggiorna l'OP specificata nel corpo del documento
procedure TPreventiviOrdiniForm.OP_AddOrUpdate(OP_ID: Integer; OP_Codice, OP_Descrizione: String; OP_PrzUnit, OP_PrzUnitNettoIvaComp, OP_Sconto1, OP_Sconto2,
  OP_Sconto3: Double; OP_CodiceIva, OP_IdApparecchioPrat: Integer);
var
  DC: TcxCustomDataController;
  RI: Integer;
begin
  // Verifica parametri
  if Trim(OP_Codice) = '' then
    Exit;
  // Inizializzazione
  DC := tvCorpo.DataController;
  // Prima di tutto verifica se un record relativo alla stesso OP dello stesso apparecchio esiste già oppure no
  // Se esiste ne ricava il RecordIndex
  RI := OP_FindByOpApparecchio(DC, OP_ID);
  // Se non esiste lo crea nuovo
  if RI = (-1) then
    RI := DC.AppendRecord;
  // Carica/aggiorna i dati nel rigo
  // NB: Qtà, sconti e importi solo se il prezzo > 0
  DC.Values[RI, tvCorpoCODICEARTICOLO.Index] := OP_Codice;
  DC.Values[RI, tvCorpoCODICEARTICOLOSTM.Index] := OP_Codice;
  DC.Values[RI, tvCorpoIDAPPARECCHIO.Index] := OP_IdApparecchioPrat;
  DC.Values[RI, tvCorpoIDOPIMPEGNO.Index] := OP_ID;
  DC.Values[RI, tvCorpoDESCRIZIONE.Index] := OP_Descrizione;
  DC.Values[RI, tvCorpoMARGINE.Index] := 0;
  DC.Values[RI, tvCorpoIMPORTOMARGINE.Index] := 0;
  DC.Values[RI, tvCorpoPREZZOACQUISTOARTICOLO.Index] := OP_PrzUnit;
  AssegnaAliquotaIVA(OP_CodiceIva, RI, DC);
  if OP_PrzUnit <> 0 then
  begin
    DC.Values[RI, tvCorpoUNITADIMISURA.Index] := 'NR';
    DC.Values[RI, tvCorpoQTA.Index] := 1;
    DC.Values[RI, tvCorpoSCONTORIGO.Index] := OP_Sconto1;
    DC.Values[RI, tvCorpoSCONTORIGO2.Index] := OP_Sconto2;
    DC.Values[RI, tvCorpoSCONTORIGO3.Index] := OP_Sconto3;
  end
  else
  begin
    DC.Values[RI, tvCorpoUNITADIMISURA.Index] := '';
    DC.Values[RI, tvCorpoQTA.Index] := null;
    DC.Values[RI, tvCorpoSCONTORIGO.Index] := null;
    DC.Values[RI, tvCorpoSCONTORIGO2.Index] := null;
    DC.Values[RI, tvCorpoSCONTORIGO3.Index] := null;
  end;
  // Se il documento è IVA compresa con calcolo mediante scorporo...
  if DM1.ScorporoIVA then
  begin
    DC.Values[RI, tvCorpoPREZZOUNITARIOIVACOMPRESA.Index] := OP_PrzUnitNettoIvaComp;
    DC.Post;
    CalcolaPerModificaPrezzoUnitarioIVACompresa(RI, DC);
  end
  // Se invece non è IVA esclusa con calcolo normale...
  else
  begin
    DC.Values[RI, tvCorpoPREZZOUNITARIO.Index] := OP_PrzUnit;
    DC.Post;
    CalcolaPerModificaPrezzoUnitario(RI, DC);
  end;
  // Ricalcola
  CalcolaImportoRigo(DC, RI);
  if not fModificandoDaDatiRigoForm then
    CalcolaTotali(False);
end;

// Procedure che elimina l'OP specificata nel corpo del documento
procedure TPreventiviOrdiniForm.OP_Delete(OP_ID: Integer);
var
  DC: TcxCustomDataController;
  RI: Integer;
begin
  // Verifica parametri
  if OP_ID = 0 then
    Exit;
  // Inizializzazione
  DC := tvCorpo.DataController;
  // Prima di tutto verifica se un record relativo alla stesso OP dello stesso apparecchio esiste già oppure no
  // Se esiste ne ricava il RecordIndex
  RI := OP_FindByOpApparecchio(DC, OP_ID);
  // Se non esiste esce
  if RI = (-1) then
    Exit;
  // Elimina il rigo individuato
  DC.DeleteRecord(RI);
  // Se abilitato e necessario ricalcola i totali del documento
  if not fModificandoDaDatiRigoForm then
    CalcolaTotali(False);
end;

// -----------------------------------------------------------------------------
// FINE - PARTE CHE AGGIORNA LE OP NEL DOCUMENTO DALL'IMPEGNO
// =============================================================================

procedure TPreventiviOrdiniForm.dbeAgentePropertiesEditValueChanged(Sender: TObject);
begin
  // Controlla se il livello successivo (quello eventualmente da azzerare perchè legato a quello
  // che è stato appena modificato) è linkato al presente ed eventualmente poi azzerarlo.
  if (QryDocumento.State = dsEdit) or (QryDocumento.State = dsInsert) then
    DM1.AgenteChanged(1, dbeAgente2);
end;

procedure TPreventiviOrdiniForm.dbeAgente2PropertiesEditValueChanged(Sender: TObject);
begin
  // Controlla se il livello successivo (quello eventualmente da azzerare perchè legato a quello
  // che è stato appena modificato) è linkato al presente ed eventualmente poi azzerarlo.
  if (QryDocumento.State = dsEdit) or (QryDocumento.State = dsInsert) then
    DM1.AgenteChanged(2, dbeAgente3);
end;

procedure TPreventiviOrdiniForm.dbeAgente3PropertiesEditValueChanged(Sender: TObject);
begin
  // Controlla se il livello successivo (quello eventualmente da azzerare perchè legato a quello
  // che è stato appena modificato) è linkato al presente ed eventualmente poi azzerarlo.
  if (QryDocumento.State = dsEdit) or (QryDocumento.State = dsInsert) then
    DM1.AgenteChanged(3, dbeAgente4);
end;

procedure TPreventiviOrdiniForm.dbeAgentePropertiesInitPopup(Sender: TObject);
begin
  // Carica le items
  DM1.CaricaItemsAgenti(dbeAgente.Properties.Items, 1, '');
end;

procedure TPreventiviOrdiniForm.dbeAgente2PropertiesInitPopup(Sender: TObject);
begin
  // Carica le items
  DM1.CaricaItemsAgenti(dbeAgente2.Properties.Items, 2, dbeAgente.Text);
end;

procedure TPreventiviOrdiniForm.dbeAgente3PropertiesInitPopup(Sender: TObject);
begin
  // Carica le items
  DM1.CaricaItemsAgenti(dbeAgente3.Properties.Items, 3, dbeAgente2.Text);
end;

procedure TPreventiviOrdiniForm.dbeAgente4PropertiesInitPopup(Sender: TObject);
begin
  // Carica le items
  DM1.CaricaItemsAgenti(dbeAgente4.Properties.Items, 4, dbeAgente3.Text);
end;

procedure TPreventiviOrdiniForm.tvCorpoQTADAEVADEREGetDisplayText(Sender: TcxCustomGridTableItem; ARecord: TcxCustomGridRecord; var AText: String);
var
  DC: TcxCustomDataController;
  LQtaDaEvadere: Double;
begin
  // DC Punta al DataController attuale
  DC := Sender.GridView.DataController;
  // Calcola il valore da visualizzare
  AText := '';
  // Ovvio che siccome tutto si basa sulla Qtà, se questa è nulla, esce subito
  if VarIsNull(DC.Values[ARecord.RecordIndex, tvCorpoQTA.Index]) then
    Exit;
  // Calcola la QtaDaEvadere
  LQtaDaEvadere := CalcolaQtaDaEvadere(DC, ARecord.RecordIndex);
  if LQtaDaEvadere <> 0 then
    AText := FloatToStr(LQtaDaEvadere);
end;

function TPreventiviOrdiniForm.CalcolaQtaDaEvadere(const DC: TcxCustomDataController; const ARecIdx: Integer): Double;
begin
  Result := DM1.NoNullFloatValue(DC, ARecIdx, tvCorpoQTA.Index) - DM1.NoNullFloatValue(DC, ARecIdx, tvCorpoQTAEVASA.Index);
  Result := SimpleRoundTo(Result, -4);
end;

procedure TPreventiviOrdiniForm.tvCorpoQTAGetDisplayText(Sender: TcxCustomGridTableItem; ARecord: TcxCustomGridRecord; var AText: string);
var
  LRowType: String;
begin
  LRowType := VarToStr(ARecord.Values[tvCorpoROWTYPE.Index]);
  // Se si tratta di un rigo di riepilogo di beni significativi ed esattamente di uno dei tre
  // righi con i totali dei BS al 22&, BS al 10% e manodopera al 10% allora rende invisibili
  // la Qtà e il Prezzo Unitario
  if ((LRowType = TIPORIGODOC_BS_IvaAgevolata) or (LRowType = TIPORIGODOC_BS_IvaOrdinaria) or (LRowType = TIPORIGODOC_BS_AltriCosti)) and
    ((Sender = tvCorpoQTA) or (Sender = tvCorpoPREZZOUNITARIO) or (Sender = tvCorpoPREZZOUNITARIOIVACOMPRESA)) then
    AText := '';
end;

procedure TPreventiviOrdiniForm.tvCorpoROWSECTIONPropertiesInitPopup(Sender: TObject);
var
  i, ColIdx: Integer;
  DC: TcxCustomDataController;
  LItems: TStrings;
  LSection: String;
begin
  LItems := (Sender as TcxComboBox).Properties.Items;
  LItems.Clear;
  LItems.Add('');
  DC := tvCorpo.DataController;
  ColIdx := tvCorpoROWSECTION.Index;
  for i := 0 to DC.RecordCount - 1 do
  begin
    if VarIsNull(DC.Values[i, ColIdx]) then
      Continue;
    LSection := Trim(DC.Values[i, ColIdx]);
    if (LSection <> '') and (LItems.IndexOf(LSection) = -1) then
      LItems.Add(LSection);
  end;
end;

// Procedure che visualiza l'editor per la descrizione del rigo relativo
// ai viaggi per le aziende di trasporto.
procedure TPreventiviOrdiniForm.VisualizzaEditorViaggio;
var
  DC: TcxCustomDataController;
  FRI: Integer;
  UM: String;
begin
  // Inizializzazione
  DC := tvCorpo.DataController;
  FRI := DC.FocusedRecordIndex;
  // Se non c'è alcun record focused esce
  if FRI = -1 then
  begin
    DM1.Messaggi('Levante', 'Prima seleziona il rigo.', '', [mbOk], 0, nil);
    Exit;
  end;
  // Crea la form
  Application.CreateForm(TTedoldiForm, TedoldiForm);
  try
    // Carica alduni dati.
    TedoldiForm.eRifData.EditValue := QryDocumentoDATADOCUMENTO.Value;
    TedoldiForm.eDatiUm.EditValue := DC.Values[FRI, tvCorpoUNITADIMISURA.Index];
    TedoldiForm.eDatiQta.EditValue := DC.Values[FRI, tvCorpoQTA.Index];
    TedoldiForm.eDatiPrzUnit.EditValue := DC.Values[FRI, tvCorpoPREZZOUNITARIO.Index];
    // Determina il check giusto
    UM := Uppercase(DC.DisplayTexts[FRI, tvCorpoUNITADIMISURA.Index]);
    if UM = 'PZ' then
    begin
      TedoldiForm.eCheckColli.Checked := True;
      TedoldiForm.eDatiColli.EditValue := TedoldiForm.eDatiQta.EditValue;
    end
    else if UM = 'KG' then
    begin
      TedoldiForm.eCheckKg.Checked := True;
      TedoldiForm.eDatiKg.EditValue := TedoldiForm.eDatiQta.EditValue;
    end
    else if UM = 'KM' then
    begin
      TedoldiForm.eCheckKm.Checked := True;
      TedoldiForm.eDatiKm.EditValue := TedoldiForm.eDatiQta.EditValue;
    end;
    // Visualizza la form
    TedoldiForm.ShowModal;
  finally
    // Pulizie
    FreeAndNil(TedoldiForm);
  end;
end;

procedure TPreventiviOrdiniForm.QryDocumentoRIFDOC_NUMChange(Sender: TField);
begin
  // Verifica che non ci siano altri interventi che facciano riferimento alla ricevua fiscale
  // NB: L'ho messo prima l'eventuale assegnamento della data e lasciarlo qui
  if Controlla_RifDocNumStessoAnno_GiaUsato then
  begin
    DM1.Messaggi('Levante', 'ATTENZIONE !!!'#13#13'Ci sono altri documenti che fanno riferimento a: ' + QryDocumentoRIFDOC_TIPO.AsString + ' n. ' +
      QryDocumentoRIFDOC_NUM.AsString + QryDocumentoRIFDOC_REG.AsString + ' dello stesso anno', '', [mbOk], 0, nil);
  end;
  // Se l'utente inserisce il numero di un documnto di riferimento il programma
  // propone subito come data dello stesso documento la data dell'intervento
  // perchè di solito coincidono.
  if (not Sender.IsNull) and (not QryDocumentoDATADOCUMENTO.IsNull) and ((QryDocumentoRIFDOC_DATA.IsNull) or (QryDocumentoRIFDOC_DATA.AsFloat = 0)) then
  begin
    QryDocumentoRIFDOC_DATA.Value := QryDocumentoDATADOCUMENTO.Value;
  end;
end;

procedure TPreventiviOrdiniForm.QryDocumentoRIFDOC_TIPOChange(Sender: TField);
begin
  // Verifica che non ci siano altri interventi che facciano riferimento alla ricevua fiscale
  if Controlla_RifDocNumStessoAnno_GiaUsato then
  begin
    DM1.Messaggi('Levante', 'ATTENZIONE !!!'#13#13'Ci sono altri documenti che fanno riferimento a: ' + QryDocumentoRIFDOC_TIPO.AsString + ' n. ' +
      QryDocumentoRIFDOC_NUM.AsString + QryDocumentoRIFDOC_REG.AsString + ' dello stesso anno', '', [mbOk], 0, nil);
  end;
end;

procedure TPreventiviOrdiniForm.SBEspandiPratica1Click(Sender: TObject);
begin
  try
    DM1.ShowWait('Levante', 'Sto caricando i dati...');
    DM1.VisualizzaCantiereImpianto(nil, QryDocumentoPRATICA, QryDocumentoDATAPRATICA1, True);
  finally
    DM1.CloseWait;
  end;
end;

procedure TPreventiviOrdiniForm.SBExpandSoggettiClick(Sender: TObject);
begin
  tvCorpo.ViewData.Expand(False);
end;

procedure TPreventiviOrdiniForm.SBFilterRowSoggettiClick(Sender: TObject);
begin
  // Attiva/Disattiva la Filter Row
  tvCorpo.FilterRow.Visible := (Sender as TSpeedButton).Down;
  if not tvCorpo.FilterRow.Visible then
    tvCorpo.DataController.Filter.Clear;
end;

// =============================================================================
// CALCOLO TOTALI E SUBTOTALI
// -----------------------------------------------------------------------------
procedure TPreventiviOrdiniForm.tvCorpoDataControllerSummaryAfterSummary(ASender: TcxDataSummary);

  procedure CalcFooterSummary;
  var
    V1, V2, VResult: Double;

    function GetFooterSummaryValue(const AItemLink: TObject): Double;
    var
      LValue: Variant;
    begin
      LValue := ASender.FooterSummaryValues[ASender.FooterSummaryItems.IndexOfItemLink(AItemLink)];
      if VarIsNull(LValue) then
        Result := 0
      else
        Result := LValue;
    end;

    procedure SetFooterSummaryValue(const AItemLink: TObject; const AValue: Double);
    begin
      ASender.FooterSummaryValues[ASender.FooterSummaryItems.IndexOfItemLink(AItemLink)] := AValue;
    end;

  begin
    // -------------------------------------------------------------------------
    // Percentuale di ricarido medio complessivo
    V1 := GetFooterSummaryValue(tvCorpoIMPORTOMARGINE);
    V2 := GetFooterSummaryValue(tvCorpoIMPORTOCOSTO);
    if V2 <> 0 then
      VResult := SimpleRoundTo(V1 * 100 / V2, DM1.DecimaliMarginiPercentuali * (-1))
    else
      VResult := 0;
    SetFooterSummaryValue(tvCorpoMARGINE, VResult);
    // Percentuale di ricarido medio componenti
    V1 := GetFooterSummaryValue(tvCorpoIMPORTOMARGINECOMPONENTI);
    V2 := GetFooterSummaryValue(tvCorpoIMPORTOCOSTOCOMPONENTI);
    if V2 <> 0 then
      VResult := SimpleRoundTo(V1 * 100 / V2, DM1.DecimaliMarginiPercentuali * (-1))
    else
      VResult := 0;
    SetFooterSummaryValue(tvCorpoPERCMARGINECOMPONENTI, VResult);
    // Percentuale di ricarido medio opera
    V1 := GetFooterSummaryValue(tvCorpoIMPORTOMARGINEOPERA);
    V2 := GetFooterSummaryValue(tvCorpoIMPORTOCOSTOOPERA);
    if V2 <> 0 then
      VResult := SimpleRoundTo(V1 * 100 / V2, DM1.DecimaliMarginiPercentuali * (-1))
    else
      VResult := 0;
    SetFooterSummaryValue(tvCorpoPERCMARGINEOPERA, VResult);
    // -------------------------------------------------------------------------
  end;

// ---------------------------------------------------------------------------
  procedure CalcGroupSummaries;

    function Groups: TcxDataControllerGroups;
    begin
      Result := tvCorpo.DataController.Groups;
    end;

    function GetGroupSummaryValue(const ADataGroupIndex: Integer; const AItemLink: TObject): Double;
    var
      LValue: Variant;
      ASummaryItems: TcxDataSummaryItems;
    begin
      ASummaryItems := ASender.GroupSummaryItems[Groups.Level[ADataGroupIndex]];
      LValue := ASender.GroupSummaryValues[ADataGroupIndex, ASummaryItems.IndexOfItemLink(AItemLink)];
      if VarIsNull(LValue) then
        Result := 0
      else
        Result := LValue;
    end;

    procedure SetGroupSummaryValue(const ADataGroupIndex: Integer; const AItemLink: TObject; const AValue: Double);
    var
      ASummaryItems: TcxDataSummaryItems;
    begin
      ASummaryItems := ASender.GroupSummaryItems[Groups.Level[ADataGroupIndex]];
      ASender.GroupSummaryValues[ADataGroupIndex, ASummaryItems.IndexOfItemLink(AItemLink)] := AValue;
    end;

    procedure CalcGroupSummary(ADataGroupIndex: Integer);
    var
      V1, V2, VResult: Variant;
    begin
      // Percentuale di ricarico medio complessivo
      V1 := GetGroupSummaryValue(ADataGroupIndex, tvCorpoIMPORTOMARGINE);
      V2 := GetGroupSummaryValue(ADataGroupIndex, tvCorpoIMPORTOCOSTO);
      if V2 <> 0 then
        VResult := SimpleRoundTo(V1 * 100 / V2, DM1.DecimaliMarginiPercentuali * (-1))
      else
        VResult := 0;
      SetGroupSummaryValue(ADataGroupIndex, tvCorpoMARGINE, VResult);
      // Percentuale di ricarico medio componenti
      V1 := GetGroupSummaryValue(ADataGroupIndex, tvCorpoIMPORTOMARGINECOMPONENTI);
      V2 := GetGroupSummaryValue(ADataGroupIndex, tvCorpoIMPORTOCOSTOCOMPONENTI);
      if V2 <> 0 then
        VResult := SimpleRoundTo(V1 * 100 / V2, DM1.DecimaliMarginiPercentuali * (-1))
      else
        VResult := 0;
      SetGroupSummaryValue(ADataGroupIndex, tvCorpoPERCMARGINECOMPONENTI, VResult);
      // Percentuale di ricarico medio opera
      V1 := GetGroupSummaryValue(ADataGroupIndex, tvCorpoIMPORTOMARGINEOPERA);
      V2 := GetGroupSummaryValue(ADataGroupIndex, tvCorpoIMPORTOCOSTOOPERA);
      if V2 <> 0 then
        VResult := SimpleRoundTo(V1 * 100 / V2, DM1.DecimaliMarginiPercentuali * (-1))
      else
        VResult := 0;
      SetGroupSummaryValue(ADataGroupIndex, tvCorpoPERCMARGINEOPERA, VResult);
    end;

    procedure CalcGroupSummariesByDataGroupIndex(ADataGroupIndex: Integer);
    var
      i: Integer;
    begin
      if Groups.Level[ADataGroupIndex] >= Groups.GroupingItemCount - 1 then
        Exit;
      for i := 0 to Groups.ChildCount[ADataGroupIndex] - 1 do
      begin
        CalcGroupSummary(Groups.ChildDataGroupIndex[ADataGroupIndex, i]);
        CalcGroupSummariesByDataGroupIndex(Groups.ChildDataGroupIndex[ADataGroupIndex, i]);
      end;
    end;

  begin
    CalcGroupSummariesByDataGroupIndex(-1);
  end;
// ---------------------------------------------------------------------------

begin
  CalcFooterSummary;
  CalcGroupSummaries;
end;

procedure TPreventiviOrdiniForm.tvCorpoDataControllerSummaryFooterSummaryItemsSummary(ASender: TcxDataSummaryItems; Arguments: TcxSummaryEventArguments;
  var OutArguments: TcxSummaryEventOutArguments);
begin
  // Questa riga fa si che per i summary della griglia non vengano presi in considerazione i righi che hanno
  // il RowType che finisce con il carattere "_" (underscore) perchè ho deciso che questi righi
  // non devono essere calcolati nei totali.
  OutArguments.Done := RightStr(VarToStr(ASender.DataController.Values[Arguments.RecordIndex, tvCorpoROWTYPE.Index]), 1) = TIPORIGODOC_CHAR_GRAYED;
end;

// =============================================================================

{ TSectionGrouped }

class procedure TSectionGrouped.CheckRow(const DC: TcxCustomDataController; const Idx: Integer);
var
  LCurrent: String;
begin
  LCurrent := VarToStr(DC.Values[Idx, PreventiviOrdiniForm.tvCorpoROWSECTION.Index]);
  if (FPrevious <> STARTVALUE) and (LCurrent <> FPrevious) then
    FGrouped := True;
  FPrevious := LCurrent;
end;

class procedure TSectionGrouped.EndCheck;
begin
  if FGrouped then
    PreventiviOrdiniForm.tvCorpoROWSECTION.GroupIndex := 0
  else
    PreventiviOrdiniForm.tvCorpoROWSECTION.GroupIndex := -1;
end;

class procedure TSectionGrouped.StartCheck;
begin
  FGrouped := False;
  FPrevious := STARTVALUE;
end;

end.
